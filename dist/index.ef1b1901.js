// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"j2mbD":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "488913bcef1b1901";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id1][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"9T4CR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
// "proud verify icon then cash odor security educate choice december earth symptom hole frame mirror approve fantasy surround degree future liar walk chair father";
var _tonweb = require("tonweb");
var _tonwebDefault = parcelHelpers.interopDefault(_tonweb);
var _tonwebMnemonic = require("tonweb-mnemonic");
var _tonwebMnemonicDefault = parcelHelpers.interopDefault(_tonwebMnemonic);
async function createPaymentChannel() {
    const providerUrl = "https://testnet.toncenter.com/api/v2/jsonRPC"; // TON HTTP API url. Use this url for testnet
    const apiKey = prompt("Enter your API key (you can get it by https://t.me/tontestnetapibot):");
    window.tonweb = new (0, _tonwebDefault.default)(new (0, _tonwebDefault.default).HttpProvider(providerUrl, {
        apiKey
    })); // Initialize TON SDK
    const mnemonicAString = prompt("Enter you testnet wallet mnemonic (e.g. apple orange ... banan");
    const mnemonicA = mnemonicAString.split(" ");
    const mnemonicB = [
        "cruel",
        "enrich",
        "eye",
        "fade",
        "state",
        "sport",
        "isolate",
        "lemon",
        "tired",
        "front",
        "dog",
        "prison",
        "cool",
        "train",
        "veteran",
        "issue",
        "profit",
        "wall",
        "actor",
        "fatal",
        "senior",
        "dry",
        "diary",
        "donor", 
    ];
    window.keyPairA = await (0, _tonwebMnemonicDefault.default).mnemonicToKeyPair(mnemonicA);
    window.keyPairB = await (0, _tonwebMnemonicDefault.default).mnemonicToKeyPair(mnemonicB);
    const WalletClass = window.tonweb.wallet.all["v4R2"];
    window.walletA = new WalletClass(window.tonweb.provider, {
        publicKey: keyPairA.publicKey,
        wc: 0
    });
    window.walletB = new WalletClass(window.tonweb.provider, {
        publicKey: keyPairB.publicKey
    });
    const walletAddressA = await window.walletA.getAddress(); // address of this wallet in blockchain
    console.log("walletAddressA: ", walletAddressA.toString(true, true, true));
    const walletAddressB = await window.walletB.getAddress(); // address of this wallet in blockchain
    console.log("walletAddressB: ", walletAddressB.toString(true, true, true));
}
window.onload(createPaymentChannel);

},{"tonweb":"9BDPe","tonweb-mnemonic":"jL58h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9BDPe":[function(require,module,exports) {
const utils = require("./utils");
const Address = utils.Address;
const boc = require("./boc");
const AppTon = require("./ledger/AppTon");
const HttpProvider = require("./providers").default;
const { Contract  } = require("./contract");
const Wallets = require("./contract/wallet").default;
const LockupWallets = require("./contract/lockup").default;
const NFT = require("./contract/token/nft").default;
const JETTON = require("./contract/token/ft").default;
const { BlockSubscription , InMemoryBlockStorage  } = require("./providers/blockSubscription");
const { SubscriptionContract  } = require("./contract/subscription/index");
const { Payments , PaymentChannel  } = require("./contract/payments/index");
const TransportWebUSB = require("@ledgerhq/hw-transport-webusb").default;
const TransportWebHID = require("@ledgerhq/hw-transport-webhid").default;
const BluetoothTransport = require("@ledgerhq/hw-transport-web-ble").default;
const { Dns , DnsCollection , DnsItem  } = require("./contract/dns").default;
const version = "0.0.50";
class TonWeb {
    constructor(provider){
        this.version = version;
        this.utils = utils;
        this.Address = Address;
        this.boc = boc;
        this.Contract = Contract;
        this.BlockSubscription = BlockSubscription;
        this.InMemoryBlockStorage = InMemoryBlockStorage;
        this.provider = provider || new HttpProvider();
        this.dns = new Dns(this.provider);
        this.wallet = new Wallets(this.provider);
        this.payments = new Payments(this.provider);
        this.lockupWallet = LockupWallets;
    }
    /**
     * Use this method to get transaction history of a given address.
     * @param address   {Address | string}
     * @param limit?    {number}
     * @param lt?    {number}
     * @param txhash?    {string}   in HEX
     * @param to_lt?    {number}
     * @return array of transaction objects
     */ async getTransactions(address, limit = 20, lt, txhash, to_lt) {
        return this.provider.getTransactions(address.toString(), limit, lt, txhash, to_lt);
    }
    /**
     * @param address   {Address | string}
     * @return {Promise<string>} - The current balance for the given address in nanograms.
     */ async getBalance(address) {
        return this.provider.getBalance(address.toString());
    }
    /**
     * Use this method to send serialized boc file: fully packed and serialized external message.
     * @param bytes {Uint8Array}
     */ async sendBoc(bytes) {
        return this.provider.sendBoc(utils.bytesToBase64(bytes));
    }
    /**
     * Invoke get-method of smart contract
     * @param address   {Address | string}    contract address
     * @param method   {string | number}        method name or method id
     * @param params?   Array of stack elements: [['num',3], ['cell', cell_object], ['slice', slice_object]]
     */ async call(address, method, params = []) {
        return this.provider.call(address.toString(), method, params);
    }
}
TonWeb.version = version;
TonWeb.utils = utils;
TonWeb.Address = Address;
TonWeb.boc = boc;
TonWeb.HttpProvider = HttpProvider;
TonWeb.Contract = Contract;
TonWeb.Wallets = Wallets;
TonWeb.LockupWallets = LockupWallets;
TonWeb.SubscriptionContract = SubscriptionContract;
TonWeb.BlockSubscription = BlockSubscription;
TonWeb.InMemoryBlockStorage = InMemoryBlockStorage;
TonWeb.ledger = {
    TransportWebUSB,
    TransportWebHID,
    BluetoothTransport,
    AppTon
};
TonWeb.token = {
    nft: NFT,
    ft: JETTON,
    jetton: JETTON
};
TonWeb.dns = Dns;
TonWeb.dns.DnsCollection = DnsCollection;
TonWeb.dns.DnsItem = DnsItem;
TonWeb.payments = Payments;
TonWeb.payments.PaymentChannel = PaymentChannel;
module.exports = TonWeb;

},{"./utils":"57M1Z","./boc":"4fqdK","./ledger/AppTon":"aM11n","./providers":"lMDUL","./contract":"drIoA","./contract/wallet":"h00EC","./contract/lockup":"5i9kN","./contract/token/nft":"8v2Xc","./contract/token/ft":"7I7oy","./providers/blockSubscription":"klRLG","./contract/subscription/index":"726RW","./contract/payments/index":"gIMhG","@ledgerhq/hw-transport-webusb":"9zmIA","@ledgerhq/hw-transport-webhid":"8O295","@ledgerhq/hw-transport-web-ble":"gICot","./contract/dns":"abvtp"}],"57M1Z":[function(require,module,exports) {
const { BN , nacl , sha256 , fromNano , toNano , bytesToHex , hexToBytes , stringToBytes , crc32c , crc16 , concatBytes , bytesToBase64 , base64ToBytes , base64toString , stringToBase64 , compareBytes , readNBytesUIntFromArray , keyPairFromSeed , newKeyPair , newSeed  } = require("./Utils");
const Address = require("./Address").default;
// ton://transfer/EQA0i8-CdGnF_DhUHHf92R1ONH6sIA9vLZ_WLcCIhfBBXwtG
// ton://transfer/EQA0i8-CdGnF_DhUHHf92R1ONH6sIA9vLZ_WLcCIhfBBXwtG?amount=1000000000
// ton://transfer/EQA0i8-CdGnF_DhUHHf92R1ONH6sIA9vLZ_WLcCIhfBBXwtG?amount=1000000000&text=data
// ton://transfer/EQA0i8-CdGnF_DhUHHf92R1ONH6sIA9vLZ_WLcCIhfBBXwtG?amount=1000000000&text=foo%3A%2F%2Fbar%2C%2Fbaz%3Famount%3D1%26text%3D%D1%80%D1%83
/**
 * @param url {string}
 * @return {{address: string, amount?: string, text?: string}}
 * @throws if invalid url
 */ function parseTransferUrl(url) {
    const PREFIX = "ton://transfer/";
    if (!url.startsWith(PREFIX)) throw new Error("must starts with " + PREFIX);
    const arr = url.substring(PREFIX.length).split("?");
    if (arr.length > 2) throw new Error('multiple "?"');
    const address = arr[0];
    if (!Address.isValid(address)) throw new Error("invalid address format " + address);
    const result = {
        address: address
    };
    const rest = arr[1];
    if (rest && rest.length) {
        const pairs = rest.split("&").map((s)=>s.split("="));
        for (const pair of pairs){
            if (pair.length !== 2) throw new Error("invalid url pair");
            const key = pair[0];
            const value = pair[1];
            if (key === "amount") {
                if (result.amount) throw new Error("amount already set");
                const bn = new BN(value);
                if (bn.isNeg()) throw new Error("negative amount");
                result.amount = value;
            } else if (key === "text") {
                if (result.text) throw new Error("text already set");
                result.text = decodeURIComponent(value);
            } else throw new Error("unknown url var " + key);
        }
    }
    return result;
}
/**
 * @param address   {string}
 * @param amount?    {string} in nano
 * @param text?   {string}
 * @return {string}
 */ function formatTransferUrl(address, amount, text) {
    let url = "ton://transfer/" + address;
    const params = [];
    if (amount) params.push("amount=" + amount);
    if (text) params.push("text=" + encodeURIComponent(text));
    if (params.length === 0) return url;
    return url + "?" + params.join("&");
}
module.exports = {
    Address,
    BN,
    nacl,
    sha256,
    fromNano,
    toNano,
    bytesToHex,
    hexToBytes,
    stringToBytes,
    crc32c,
    crc16,
    concatBytes,
    bytesToBase64,
    base64ToBytes,
    base64toString,
    stringToBase64,
    compareBytes,
    readNBytesUIntFromArray,
    parseTransferUrl,
    formatTransferUrl,
    keyPairFromSeed,
    newKeyPair,
    newSeed
};

},{"./Utils":"dop5X","./Address":"loGF4"}],"dop5X":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
const BN = require("bn.js");
const nacl = require("tweetnacl");
const ethunit = require("ethjs-unit");
const isCryptoAvailable = typeof self !== "undefined" && self.crypto && self.crypto.subtle;
let myCrypto = null;
if (isCryptoAvailable) ;
else myCrypto = require("isomorphic-webcrypto");
/**
 * @param bytes {Uint8Array}
 * @return  {Promise<ArrayBuffer>}
 */ function sha256(bytes) {
    if (isCryptoAvailable) return crypto.subtle.digest("SHA-256", bytes);
    else return myCrypto.subtle.digest({
        name: "SHA-256"
    }, bytes);
}
/**
 * from coins to nanocoins
 * @param amount {BN | string}
 * @return {BN}
 */ function toNano(amount) {
    if (!BN.isBN(amount) && !(typeof amount === "string")) throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
    return ethunit.toWei(amount, "gwei");
}
/**
 * from nanocoins to coins
 * @param amount  {BN | string}
 * @return {string}
 */ function fromNano(amount) {
    if (!BN.isBN(amount) && !(typeof amount === "string")) throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
    return ethunit.fromWei(amount, "gwei");
}
// look up tables
const to_hex_array = [];
const to_byte_map = {};
for(let ord = 0; ord <= 0xff; ord++){
    let s = ord.toString(16);
    if (s.length < 2) s = "0" + s;
    to_hex_array.push(s);
    to_byte_map[s] = ord;
}
//  converter using lookups
/**
 * @param buffer  {Uint8Array}
 * @return {string}
 */ function bytesToHex(buffer) {
    const hex_array = [];
    //(new Uint8Array(buffer)).forEach((v) => { hex_array.push(to_hex_array[v]) });
    for(let i = 0; i < buffer.byteLength; i++)hex_array.push(to_hex_array[buffer[i]]);
    return hex_array.join("");
}
// reverse conversion using lookups
/**
 * @param s {string}
 * @return {Uint8Array}
 */ function hexToBytes(s) {
    s = s.toLowerCase();
    const length2 = s.length;
    if (length2 % 2 !== 0) throw "hex string must have length a multiple of 2";
    const length = length2 / 2;
    const result = new Uint8Array(length);
    for(let i = 0; i < length; i++){
        const i2 = i * 2;
        const b = s.substring(i2, i2 + 2);
        if (!to_byte_map.hasOwnProperty(b)) throw new Error("invalid hex character " + b);
        result[i] = to_byte_map[b];
    }
    return result;
}
/**
 * @param str {string}
 * @param size  {number}
 * @return {Uint8Array}
 */ function stringToBytes(str, size = 1) {
    let buf;
    let bufView;
    if (size === 1) {
        buf = new ArrayBuffer(str.length);
        bufView = new Uint8Array(buf);
    }
    if (size === 2) {
        buf = new ArrayBuffer(str.length * 2);
        bufView = new Uint16Array(buf);
    }
    if (size === 4) {
        buf = new ArrayBuffer(str.length * 4);
        bufView = new Uint32Array(buf);
    }
    for(let i = 0, strLen = str.length; i < strLen; i++)bufView[i] = str.charCodeAt(i);
    return new Uint8Array(bufView.buffer);
}
/**
 * @private
 * @param crc {number}
 * @param bytes {Uint8Array}
 * @return {number}
 */ function _crc32c(crc, bytes) {
    const POLY = 0x82f63b78;
    crc ^= 0xffffffff;
    for(let n = 0; n < bytes.length; n++){
        crc ^= bytes[n];
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
        crc = crc & 1 ? crc >>> 1 ^ POLY : crc >>> 1;
    }
    return crc ^ 0xffffffff;
}
/**
 * @param bytes {Uint8Array}
 * @return {Uint8Array}
 */ function crc32c(bytes) {
    //Version suitable for crc32-c of BOC
    const int_crc = _crc32c(0, bytes);
    const arr = new ArrayBuffer(4);
    const view = new DataView(arr);
    view.setUint32(0, int_crc, false);
    return new Uint8Array(arr).reverse();
}
/**
 * @param data  {ArrayLike<number>}
 * @return {Uint8Array}
 */ function crc16(data) {
    const poly = 0x1021;
    let reg = 0;
    const message = new Uint8Array(data.length + 2);
    message.set(data);
    for (let byte of message){
        let mask = 0x80;
        while(mask > 0){
            reg <<= 1;
            if (byte & mask) reg += 1;
            mask >>= 1;
            if (reg > 0xffff) {
                reg &= 0xffff;
                reg ^= poly;
            }
        }
    }
    return new Uint8Array([
        Math.floor(reg / 256),
        reg % 256
    ]);
}
/**
 * @param a {Uint8Array}
 * @param b {Uint8Array}
 * @return {Uint8Array}
 */ function concatBytes(a, b) {
    const c = new Uint8Array(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}
/**
 * @param a {Uint8Array}
 * @param b {Uint8Array}
 * @return {boolean}
 */ function compareBytes(a, b) {
    // TODO Make it smarter
    return a.toString() === b.toString();
}
const base64abc = (()=>{
    const abc = [];
    const A = "A".charCodeAt(0);
    const a = "a".charCodeAt(0);
    const n = "0".charCodeAt(0);
    for(let i = 0; i < 26; ++i)abc.push(String.fromCharCode(A + i));
    for(let i1 = 0; i1 < 26; ++i1)abc.push(String.fromCharCode(a + i1));
    for(let i3 = 0; i3 < 10; ++i3)abc.push(String.fromCharCode(n + i3));
    abc.push("+");
    abc.push("/");
    return abc;
})();
/**
 * @param bytes {Uint8Array}
 * @return {string}
 */ function bytesToBase64(bytes) {
    let result = "";
    let i;
    const l = bytes.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];
        result += base64abc[bytes[i] & 0x3f];
    }
    if (i === l + 1) {
        // 1 octet missing
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        // 2 octets missing
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
// todo: base64 decoding process could ignore one extra character at the end of string and the byte-length check below won't be able to catch it.
function base64toString(base64) {
    if (typeof self === "undefined") return Buffer.from(base64, "base64").toString("binary"); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error
    else return atob(base64);
}
function stringToBase64(s) {
    if (typeof self === "undefined") return Buffer.from(s, "binary").toString("base64"); // todo: (tolya-yanot) Buffer silently ignore incorrect base64 symbols, we need to throw error
    else return btoa(s);
}
/**
 * @param base64  {string}
 * @return {Uint8Array}
 */ function base64ToBytes(base64) {
    const binary_string = base64toString(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for(let i = 0; i < len; i++)bytes[i] = binary_string.charCodeAt(i);
    return bytes;
}
/**
 * @param n  {number}
 * @param ui8array  {Uint8Array}
 * @return {number}
 */ function readNBytesUIntFromArray(n, ui8array) {
    let res = 0;
    for(let c = 0; c < n; c++){
        res *= 256;
        res += ui8array[c];
    }
    return res;
}
/**
 * @param seed  {Uint8Array}
 * @returns {nacl.SignKeyPair}
 */ function keyPairFromSeed(seed) {
    return nacl.sign.keyPair.fromSeed(seed);
}
/**
 * @returns {nacl.SignKeyPair}
 */ function newKeyPair() {
    return nacl.sign.keyPair();
}
/**
 * @returns {Uint8Array}
 */ function newSeed() {
    return nacl.sign.keyPair().secretKey.slice(0, 32);
}
module.exports = {
    BN,
    nacl,
    sha256,
    fromNano,
    toNano,
    bytesToHex,
    hexToBytes,
    stringToBytes,
    crc32c,
    crc16,
    concatBytes,
    bytesToBase64,
    base64ToBytes,
    base64toString,
    stringToBase64,
    compareBytes,
    readNBytesUIntFromArray,
    keyPairFromSeed,
    newKeyPair,
    newSeed
};

},{"buffer":"fCgem","bn.js":"VopIn","tweetnacl":"3J9rh","ethjs-unit":"dabOl","isomorphic-webcrypto":"1hTeY"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("base64-js");
const ieee754 = require("ieee754");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i1;
    if (dir) {
        let foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength1 && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2];
    let mul = 1;
    while(byteLength2 > 0 && (mul *= 0x100))val += this[offset + --byteLength2] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength3 && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
    offset = offset >>> 0;
    byteLength4 = byteLength4 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength4, this.length);
    let i = byteLength4;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength5 = byteLength5 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength5) - 1;
        checkInt(this, value, offset, byteLength5, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength5 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength5;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength6) - 1;
        checkInt(this, value, offset, byteLength6, maxBytes, 0);
    }
    let i = byteLength6 - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength6;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength7 - 1);
        checkInt(this, value, offset, byteLength7, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength7 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength7;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength8 - 1);
        checkInt(this, value, offset, byteLength8, limit - 1, -limit);
    }
    let i = byteLength8 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength8;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength9) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength9] === undefined) boundsError(offset, buf.length - (byteLength9 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength10) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength10 > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength10 + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength10 + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength10 + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength10);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len2; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i2 = start; i2 < end; i2 += 3){
        tmp = (uint8[i2] << 16 & 0xFF0000) + (uint8[i2 + 1] << 8 & 0xFF00) + (uint8[i2 + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len3 = uint8.length;
    var extraBytes = len3 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i3 = 0, len2 = len3 - extraBytes; i3 < len2; i3 += maxChunkLength)parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len3 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"VopIn":[function(require,module,exports) {
(function(module, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module === "object") module.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        Buffer = require("buffer").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") start++;
        if (base === 16) this._parseHex(number, start);
        else this._parseBase(number, base, start);
        if (number[0] === "-") this.negative = 1;
        this._strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        var z = 0;
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            var b;
            // 'a' - 'f'
            if (c >= 49 && c <= 54) b = c - 49 + 0xa;
            else if (c >= 17 && c <= 22) b = c - 17 + 0xa;
            else b = c;
            r |= b;
            z |= b;
        }
        assert(!(z & 0xf0), "Invalid character in " + str);
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        // Scan 24-bit chunks and add them to the number
        var off = 0;
        for(i = number.length - 6, j = 0; i >= start; i -= 6){
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"buffer":"jhUEF"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"3J9rh":[function(require,module,exports) {
(function(nacl) {
    "use strict";
    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/
    var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];
        return r;
    };
    //  Pluggable, initialized in high-level API below.
    var randombytes = function() {
        throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([
        1
    ]), _121665 = gf([
        0xdb41,
        1
    ]), D = gf([
        0x78a3,
        0x1359,
        0x4dca,
        0x75eb,
        0xd8ab,
        0x4141,
        0x0a4d,
        0x0070,
        0xe898,
        0x7779,
        0x4079,
        0x8cc7,
        0xfe73,
        0x2b6f,
        0x6cee,
        0x5203
    ]), D2 = gf([
        0xf159,
        0x26b2,
        0x9b94,
        0xebd6,
        0xb156,
        0x8283,
        0x149a,
        0x00e0,
        0xd130,
        0xeef3,
        0x80f2,
        0x198e,
        0xfce7,
        0x56df,
        0xd9dc,
        0x2406
    ]), X = gf([
        0xd51a,
        0x8f25,
        0x2d60,
        0xc956,
        0xa7b2,
        0x9525,
        0xc760,
        0x692c,
        0xdc5c,
        0xfdd6,
        0xe231,
        0xc0a4,
        0x53fe,
        0xcd6e,
        0x36d3,
        0x2169
    ]), Y = gf([
        0x6658,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666
    ]), I = gf([
        0xa0b0,
        0x4a0e,
        0x1b27,
        0xc4ee,
        0xe478,
        0xad2f,
        0x1806,
        0x2f43,
        0xd7a7,
        0x3dfb,
        0x0099,
        0x2b4d,
        0xdf0b,
        0x4fc1,
        0x2480,
        0x2b83
    ]);
    function ts64(x, i, h, l) {
        x[i] = h >> 24 & 0xff;
        x[i + 1] = h >> 16 & 0xff;
        x[i + 2] = h >> 8 & 0xff;
        x[i + 3] = h & 0xff;
        x[i + 4] = l >> 24 & 0xff;
        x[i + 5] = l >> 16 & 0xff;
        x[i + 6] = l >> 8 & 0xff;
        x[i + 7] = l & 0xff;
    }
    function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 25;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 19;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 25;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 19;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 25;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 19;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 25;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 19;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 14;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 25;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 19;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 25;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 19;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 25;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 19;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 25;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 19;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 14;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x1 >>> 0 & 0xff;
        o[5] = x1 >>> 8 & 0xff;
        o[6] = x1 >>> 16 & 0xff;
        o[7] = x1 >>> 24 & 0xff;
        o[8] = x2 >>> 0 & 0xff;
        o[9] = x2 >>> 8 & 0xff;
        o[10] = x2 >>> 16 & 0xff;
        o[11] = x2 >>> 24 & 0xff;
        o[12] = x3 >>> 0 & 0xff;
        o[13] = x3 >>> 8 & 0xff;
        o[14] = x3 >>> 16 & 0xff;
        o[15] = x3 >>> 24 & 0xff;
        o[16] = x4 >>> 0 & 0xff;
        o[17] = x4 >>> 8 & 0xff;
        o[18] = x4 >>> 16 & 0xff;
        o[19] = x4 >>> 24 & 0xff;
        o[20] = x5 >>> 0 & 0xff;
        o[21] = x5 >>> 8 & 0xff;
        o[22] = x5 >>> 16 & 0xff;
        o[23] = x5 >>> 24 & 0xff;
        o[24] = x6 >>> 0 & 0xff;
        o[25] = x6 >>> 8 & 0xff;
        o[26] = x6 >>> 16 & 0xff;
        o[27] = x6 >>> 24 & 0xff;
        o[28] = x7 >>> 0 & 0xff;
        o[29] = x7 >>> 8 & 0xff;
        o[30] = x7 >>> 16 & 0xff;
        o[31] = x7 >>> 24 & 0xff;
        o[32] = x8 >>> 0 & 0xff;
        o[33] = x8 >>> 8 & 0xff;
        o[34] = x8 >>> 16 & 0xff;
        o[35] = x8 >>> 24 & 0xff;
        o[36] = x9 >>> 0 & 0xff;
        o[37] = x9 >>> 8 & 0xff;
        o[38] = x9 >>> 16 & 0xff;
        o[39] = x9 >>> 24 & 0xff;
        o[40] = x10 >>> 0 & 0xff;
        o[41] = x10 >>> 8 & 0xff;
        o[42] = x10 >>> 16 & 0xff;
        o[43] = x10 >>> 24 & 0xff;
        o[44] = x11 >>> 0 & 0xff;
        o[45] = x11 >>> 8 & 0xff;
        o[46] = x11 >>> 16 & 0xff;
        o[47] = x11 >>> 24 & 0xff;
        o[48] = x12 >>> 0 & 0xff;
        o[49] = x12 >>> 8 & 0xff;
        o[50] = x12 >>> 16 & 0xff;
        o[51] = x12 >>> 24 & 0xff;
        o[52] = x13 >>> 0 & 0xff;
        o[53] = x13 >>> 8 & 0xff;
        o[54] = x13 >>> 16 & 0xff;
        o[55] = x13 >>> 24 & 0xff;
        o[56] = x14 >>> 0 & 0xff;
        o[57] = x14 >>> 8 & 0xff;
        o[58] = x14 >>> 16 & 0xff;
        o[59] = x14 >>> 24 & 0xff;
        o[60] = x15 >>> 0 & 0xff;
        o[61] = x15 >>> 8 & 0xff;
        o[62] = x15 >>> 16 & 0xff;
        o[63] = x15 >>> 24 & 0xff;
    }
    function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 25;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 19;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 25;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 19;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 25;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 19;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 25;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 19;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 14;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 25;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 23;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 19;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 14;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 25;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 23;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 19;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 14;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 25;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 23;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 19;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 14;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 25;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 23;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 19;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 14;
        }
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x5 >>> 0 & 0xff;
        o[5] = x5 >>> 8 & 0xff;
        o[6] = x5 >>> 16 & 0xff;
        o[7] = x5 >>> 24 & 0xff;
        o[8] = x10 >>> 0 & 0xff;
        o[9] = x10 >>> 8 & 0xff;
        o[10] = x10 >>> 16 & 0xff;
        o[11] = x10 >>> 24 & 0xff;
        o[12] = x15 >>> 0 & 0xff;
        o[13] = x15 >>> 8 & 0xff;
        o[14] = x15 >>> 16 & 0xff;
        o[15] = x15 >>> 24 & 0xff;
        o[16] = x6 >>> 0 & 0xff;
        o[17] = x6 >>> 8 & 0xff;
        o[18] = x6 >>> 16 & 0xff;
        o[19] = x6 >>> 24 & 0xff;
        o[20] = x7 >>> 0 & 0xff;
        o[21] = x7 >>> 8 & 0xff;
        o[22] = x7 >>> 16 & 0xff;
        o[23] = x7 >>> 24 & 0xff;
        o[24] = x8 >>> 0 & 0xff;
        o[25] = x8 >>> 8 & 0xff;
        o[26] = x8 >>> 16 & 0xff;
        o[27] = x8 >>> 24 & 0xff;
        o[28] = x9 >>> 0 & 0xff;
        o[29] = x9 >>> 8 & 0xff;
        o[30] = x9 >>> 16 & 0xff;
        o[31] = x9 >>> 24 & 0xff;
    }
    function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([
        101,
        120,
        112,
        97,
        110,
        100,
        32,
        51,
        50,
        45,
        98,
        121,
        116,
        101,
        32,
        107
    ]);
    // "expand 32-byte k"
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = x[i];
        }
        return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/ var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
        this.r[0] = t0 & 0x1fff;
        t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f;
        this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
        this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
        this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
        this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
        this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
        this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
        this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
        this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 2048;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while(bytes >= 16){
            t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
            h0 += t0 & 0x1fff;
            t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
            t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
            t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
            t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
            h5 += t4 >>> 1 & 0x1fff;
            t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
            t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
            t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 0x1fff;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 0x1fff;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 0x1fff;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 0x1fff;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 0x1fff;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 0x1fff;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 0x1fff;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 0x1fff;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 0x1fff;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 0x1fff;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 0x1fff;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for(; i < 16; i++)this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        for(i = 2; i < 10; i++){
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 0x1fff;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 0x1fff;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(i = 1; i < 10; i++){
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 8192;
        mask = (c ^ 1) - 1;
        for(i = 0; i < 10; i++)g[i] &= mask;
        mask = ~mask;
        for(i = 0; i < 10; i++)this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 0xffff;
        for(i = 1; i < 8; i++){
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
        mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
        mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
        mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
        mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
        mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
        mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
        mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
        mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
        mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
        mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
        mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
        mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
        mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
        mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
        mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes) want = bytes;
            for(i = 0; i < want; i++)this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16) return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for(i = 0; i < bytes; i++)this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
        }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for(i = 0; i < 16; i++)c[i] = 0;
        return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for(i = 0; i < 32; i++)m[i] = 0;
        return 0;
    }
    function set25519(r, a) {
        var i;
        for(i = 0; i < 16; i++)r[i] = a[i] | 0;
    }
    function car25519(o) {
        var i, v, c = 1;
        for(i = 0; i < 16; i++){
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for(var i = 0; i < 16; i++){
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for(i = 0; i < 16; i++)t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for(j = 0; j < 2; j++){
            m[0] = t[0] - 0xffed;
            for(i = 1; i < 15; i++){
                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for(i = 0; i < 16; i++){
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
    }
    function unpack25519(o, n) {
        var i;
        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 0x7fff;
    }
    function A(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        // t15 left as is
        // first car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        // second car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
    }
    function S(o, a) {
        M(o, a, a);
    }
    function inv25519(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 253; a >= 0; a--){
            S(c, c);
            if (a !== 2 && a !== 4) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function pow2523(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 250; a >= 0; a--){
            S(c, c);
            if (a !== 1) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for(i = 0; i < 31; i++)z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for(i = 0; i < 16; i++){
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for(i = 254; i >= 0; --i){
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
        }
        for(i = 0; i < 16; i++){
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
    }
    function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
        0x428a2f98,
        0xd728ae22,
        0x71374491,
        0x23ef65cd,
        0xb5c0fbcf,
        0xec4d3b2f,
        0xe9b5dba5,
        0x8189dbbc,
        0x3956c25b,
        0xf348b538,
        0x59f111f1,
        0xb605d019,
        0x923f82a4,
        0xaf194f9b,
        0xab1c5ed5,
        0xda6d8118,
        0xd807aa98,
        0xa3030242,
        0x12835b01,
        0x45706fbe,
        0x243185be,
        0x4ee4b28c,
        0x550c7dc3,
        0xd5ffb4e2,
        0x72be5d74,
        0xf27b896f,
        0x80deb1fe,
        0x3b1696b1,
        0x9bdc06a7,
        0x25c71235,
        0xc19bf174,
        0xcf692694,
        0xe49b69c1,
        0x9ef14ad2,
        0xefbe4786,
        0x384f25e3,
        0x0fc19dc6,
        0x8b8cd5b5,
        0x240ca1cc,
        0x77ac9c65,
        0x2de92c6f,
        0x592b0275,
        0x4a7484aa,
        0x6ea6e483,
        0x5cb0a9dc,
        0xbd41fbd4,
        0x76f988da,
        0x831153b5,
        0x983e5152,
        0xee66dfab,
        0xa831c66d,
        0x2db43210,
        0xb00327c8,
        0x98fb213f,
        0xbf597fc7,
        0xbeef0ee4,
        0xc6e00bf3,
        0x3da88fc2,
        0xd5a79147,
        0x930aa725,
        0x06ca6351,
        0xe003826f,
        0x14292967,
        0x0a0e6e70,
        0x27b70a85,
        0x46d22ffc,
        0x2e1b2138,
        0x5c26c926,
        0x4d2c6dfc,
        0x5ac42aed,
        0x53380d13,
        0x9d95b3df,
        0x650a7354,
        0x8baf63de,
        0x766a0abb,
        0x3c77b2a8,
        0x81c2c92e,
        0x47edaee6,
        0x92722c85,
        0x1482353b,
        0xa2bfe8a1,
        0x4cf10364,
        0xa81a664b,
        0xbc423001,
        0xc24b8b70,
        0xd0f89791,
        0xc76c51a3,
        0x0654be30,
        0xd192e819,
        0xd6ef5218,
        0xd6990624,
        0x5565a910,
        0xf40e3585,
        0x5771202a,
        0x106aa070,
        0x32bbd1b8,
        0x19a4c116,
        0xb8d2d0c8,
        0x1e376c08,
        0x5141ab53,
        0x2748774c,
        0xdf8eeb99,
        0x34b0bcb5,
        0xe19b48a8,
        0x391c0cb3,
        0xc5c95a63,
        0x4ed8aa4a,
        0xe3418acb,
        0x5b9cca4f,
        0x7763e373,
        0x682e6ff3,
        0xd6b2b8a3,
        0x748f82ee,
        0x5defb2fc,
        0x78a5636f,
        0x43172f60,
        0x84c87814,
        0xa1f0ab72,
        0x8cc70208,
        0x1a6439ec,
        0x90befffa,
        0x23631e28,
        0xa4506ceb,
        0xde82bde9,
        0xbef9a3f7,
        0xb2c67915,
        0xc67178f2,
        0xe372532b,
        0xca273ece,
        0xea26619c,
        0xd186b8c7,
        0x21c0c207,
        0xeada7dd6,
        0xcde0eb1e,
        0xf57d4f7f,
        0xee6ed178,
        0x06f067aa,
        0x72176fba,
        0x0a637dc5,
        0xa2c898a6,
        0x113f9804,
        0xbef90dae,
        0x1b710b35,
        0x131c471b,
        0x28db77f5,
        0x23047d84,
        0x32caab7b,
        0x40c72493,
        0x3c9ebe0a,
        0x15c9bebc,
        0x431d67c4,
        0x9c100d4c,
        0x4cc5d4be,
        0xcb3e42b6,
        0x597f299c,
        0xfc657e2a,
        0x5fcb6fab,
        0x3ad6faec,
        0x6c44198c,
        0x4a475817
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while(n >= 128){
            for(i = 0; i < 16; i++){
                j = 8 * i + pos;
                wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for(i = 0; i < 80; i++){
                bh0 = ah0;
                bh1 = ah1;
                bh2 = ah2;
                bh3 = ah3;
                bh4 = ah4;
                bh5 = ah5;
                bh6 = ah6;
                bh7 = ah7;
                bl0 = al0;
                bl1 = al1;
                bl2 = al2;
                bl3 = al3;
                bl4 = al4;
                bl5 = al5;
                bl6 = al6;
                bl7 = al7;
                // add
                h = ah7;
                l = al7;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma1
                h = (ah4 >>> 14 | al4 << 18) ^ (ah4 >>> 18 | al4 << 14) ^ (al4 >>> 9 | ah4 << 23);
                l = (al4 >>> 14 | ah4 << 18) ^ (al4 >>> 18 | ah4 << 14) ^ (ah4 >>> 9 | al4 << 23);
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Ch
                h = ah4 & ah5 ^ ~ah4 & ah6;
                l = al4 & al5 ^ ~al4 & al6;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // K
                h = K[i * 2];
                l = K[i * 2 + 1];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // w
                h = wh[i % 16];
                l = wl[i % 16];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                th = c & 0xffff | d << 16;
                tl = a & 0xffff | b << 16;
                // add
                h = th;
                l = tl;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma0
                h = (ah0 >>> 28 | al0 << 4) ^ (al0 >>> 2 | ah0 << 30) ^ (al0 >>> 7 | ah0 << 25);
                l = (al0 >>> 28 | ah0 << 4) ^ (ah0 >>> 2 | al0 << 30) ^ (ah0 >>> 7 | al0 << 25);
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Maj
                h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh7 = c & 0xffff | d << 16;
                bl7 = a & 0xffff | b << 16;
                // add
                h = bh3;
                l = bl3;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = th;
                l = tl;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh3 = c & 0xffff | d << 16;
                bl3 = a & 0xffff | b << 16;
                ah1 = bh0;
                ah2 = bh1;
                ah3 = bh2;
                ah4 = bh3;
                ah5 = bh4;
                ah6 = bh5;
                ah7 = bh6;
                ah0 = bh7;
                al1 = bl0;
                al2 = bl1;
                al3 = bl2;
                al4 = bl3;
                al5 = bl4;
                al6 = bl5;
                al7 = bl6;
                al0 = bl7;
                if (i % 16 === 15) for(j = 0; j < 16; j++){
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = (th >>> 1 | tl << 31) ^ (th >>> 8 | tl << 24) ^ th >>> 7;
                    l = (tl >>> 1 | th << 31) ^ (tl >>> 8 | th << 24) ^ (tl >>> 7 | th << 25);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = (th >>> 19 | tl << 13) ^ (tl >>> 29 | th << 3) ^ th >>> 6;
                    l = (tl >>> 19 | th << 13) ^ (th >>> 29 | tl << 3) ^ (tl >>> 6 | th << 26);
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = c & 0xffff | d << 16;
                    wl[j] = a & 0xffff | b << 16;
                }
            }
            // add
            h = ah0;
            l = al0;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 0xffff | d << 16;
            hl[0] = al0 = a & 0xffff | b << 16;
            h = ah1;
            l = al1;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 0xffff | d << 16;
            hl[1] = al1 = a & 0xffff | b << 16;
            h = ah2;
            l = al2;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 0xffff | d << 16;
            hl[2] = al2 = a & 0xffff | b << 16;
            h = ah3;
            l = al3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 0xffff | d << 16;
            hl[3] = al3 = a & 0xffff | b << 16;
            h = ah4;
            l = al4;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 0xffff | d << 16;
            hl[4] = al4 = a & 0xffff | b << 16;
            h = ah5;
            l = al5;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 0xffff | d << 16;
            hl[5] = al5 = a & 0xffff | b << 16;
            h = ah6;
            l = al6;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 0xffff | d << 16;
            hl[6] = al6 = a & 0xffff | b << 16;
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 0xffff | d << 16;
            hl[7] = al7 = a & 0xffff | b << 16;
            pos += 128;
            n -= 128;
        }
        return n;
    }
    function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 0x6a09e667;
        hh[1] = 0xbb67ae85;
        hh[2] = 0x3c6ef372;
        hh[3] = 0xa54ff53a;
        hh[4] = 0x510e527f;
        hh[5] = 0x9b05688c;
        hh[6] = 0x1f83d9ab;
        hh[7] = 0x5be0cd19;
        hl[0] = 0xf3bcc908;
        hl[1] = 0x84caa73b;
        hl[2] = 0xfe94f82b;
        hl[3] = 0x5f1d36f1;
        hl[4] = 0xade682d1;
        hl[5] = 0x2b3e6c1f;
        hl[6] = 0xfb41bd6b;
        hl[7] = 0x137e2179;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for(i = 0; i < n; i++)x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for(i = 0; i < 8; i++)ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
    }
    function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
    }
    function cswap(p, q, b) {
        var i;
        for(i = 0; i < 4; i++)sel25519(p[i], q[i], b);
    }
    function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for(i = 255; i >= 0; --i){
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    function scalarbase(p, s) {
        var q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];
        return 0;
    }
    var L = new Float64Array([
        0xed,
        0xd3,
        0xf5,
        0x5c,
        0x1a,
        0x63,
        0x12,
        0x58,
        0xd6,
        0x9c,
        0xf7,
        0xa2,
        0xde,
        0xf9,
        0xde,
        0x14,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0x10
    ]);
    function modL(r, x) {
        var carry, i, j, k;
        for(i = 63; i >= 32; --i){
            carry = 0;
            for(j = i - 32, k = i - 12; j < k; ++j){
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256);
                x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
        }
        carry = 0;
        for(j = 0; j < 32; j++){
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for(j = 0; j < 32; j++)x[j] -= carry * L[j];
        for(i = 0; i < 32; i++){
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
    }
    function reduce(r) {
        var x = new Float64Array(64), i;
        for(i = 0; i < 64; i++)x[i] = r[i];
        for(i = 0; i < 64; i++)r[i] = 0;
        modL(r, x);
    }
    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for(i = 0; i < n; i++)sm[64 + i] = m[i];
        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for(i = 32; i < 64; i++)sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for(i = 0; i < 64; i++)x[i] = 0;
        for(i = 0; i < 32; i++)x[i] = r[i];
        for(i = 0; i < 32; i++)for(j = 0; j < 32; j++)x[i + j] += h[i] * d[j];
        modL(sm.subarray(32), x);
        return smlen;
    }
    function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ], q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for(i = 0; i < n; i++)m[i] = sm[i];
        for(i = 0; i < 32; i++)m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
            for(i = 0; i < n; i++)m[i] = 0;
            return -1;
        }
        for(i = 0; i < n; i++)m[i] = sm[i + 64];
        return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
        crypto_core_hsalsa20: crypto_core_hsalsa20,
        crypto_stream_xor: crypto_stream_xor,
        crypto_stream: crypto_stream,
        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
        crypto_stream_salsa20: crypto_stream_salsa20,
        crypto_onetimeauth: crypto_onetimeauth,
        crypto_onetimeauth_verify: crypto_onetimeauth_verify,
        crypto_verify_16: crypto_verify_16,
        crypto_verify_32: crypto_verify_32,
        crypto_secretbox: crypto_secretbox,
        crypto_secretbox_open: crypto_secretbox_open,
        crypto_scalarmult: crypto_scalarmult,
        crypto_scalarmult_base: crypto_scalarmult_base,
        crypto_box_beforenm: crypto_box_beforenm,
        crypto_box_afternm: crypto_box_afternm,
        crypto_box: crypto_box,
        crypto_box_open: crypto_box_open,
        crypto_box_keypair: crypto_box_keypair,
        crypto_hash: crypto_hash,
        crypto_sign: crypto_sign,
        crypto_sign_keypair: crypto_sign_keypair,
        crypto_sign_open: crypto_sign_open,
        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES: crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
        crypto_hash_BYTES: crypto_hash_BYTES,
        gf: gf,
        D: D,
        L: L,
        pack25519: pack25519,
        unpack25519: unpack25519,
        M: M,
        A: A,
        S: S,
        Z: Z,
        pow2523: pow2523,
        add: add,
        set25519: set25519,
        modL: modL,
        scalarmult: scalarmult,
        scalarbase: scalarbase
    };
    /* High-level API */ function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
        for(var i = 0; i < arguments.length; i++){
            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
        }
    }
    function cleanup(arr) {
        for(var i = 0; i < arr.length; i++)arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
    };
    nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for(var i = 0; i < m.length; i++)m[i] = tmp[i];
        return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];
        return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];
        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for(var i = 0; i < 32; i++)sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        // Zero length arguments are considered not equal.
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
        randombytes = fn;
    };
    (function() {
        // Initialize PRNG if environment provides CSPRNG.
        // If not, methods calling randombytes will throw.
        var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
            // Browsers.
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
                var i, v = new Uint8Array(n);
                for(i = 0; i < n; i += QUOTA)crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        } else {
            // Node.js.
            crypto = require("crypto");
            if (crypto && crypto.randomBytes) nacl.setPRNG(function(x, n) {
                var i, v = crypto.randomBytes(n);
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        }
    })();
})(module.exports ? module.exports : self.nacl = self.nacl || {});

},{"crypto":"jhUEF"}],"dabOl":[function(require,module,exports) {
"use strict";
var BN = require("bn.js");
var numberToBN = require("number-to-bn");
var zero = new BN(0);
var negative1 = new BN(-1);
// complete ethereum unit map
var unitMap = {
    "noether": "0",
    "wei": "1",
    "kwei": "1000",
    "Kwei": "1000",
    "babbage": "1000",
    "femtoether": "1000",
    "mwei": "1000000",
    "Mwei": "1000000",
    "lovelace": "1000000",
    "picoether": "1000000",
    "gwei": "1000000000",
    "Gwei": "1000000000",
    "shannon": "1000000000",
    "nanoether": "1000000000",
    "nano": "1000000000",
    "szabo": "1000000000000",
    "microether": "1000000000000",
    "micro": "1000000000000",
    "finney": "1000000000000000",
    "milliether": "1000000000000000",
    "milli": "1000000000000000",
    "ether": "1000000000000000000",
    "kether": "1000000000000000000000",
    "grand": "1000000000000000000000",
    "mether": "1000000000000000000000000",
    "gether": "1000000000000000000000000000",
    "tether": "1000000000000000000000000000000"
};
/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */ function getValueOfUnit(unitInput) {
    var unit = unitInput ? unitInput.toLowerCase() : "ether";
    var unitValue = unitMap[unit]; // eslint-disable-line
    if (typeof unitValue !== "string") throw new Error("[ethjs-unit] the unit provided " + unitInput + " doesn't exists, please use the one of the following units " + JSON.stringify(unitMap, null, 2));
    return new BN(unitValue, 10);
}
function numberToString(arg) {
    if (typeof arg === "string") {
        if (!arg.match(/^-?[0-9.]+$/)) throw new Error("while converting number to string, invalid number value '" + arg + "', should be a number matching (^-?[0-9.]+).");
        return arg;
    } else if (typeof arg === "number") return String(arg);
    else if (typeof arg === "object" && arg.toString && (arg.toTwos || arg.dividedToIntegerBy)) {
        if (arg.toPrecision) return String(arg.toPrecision());
        else // eslint-disable-line
        return arg.toString(10);
    }
    throw new Error("while converting number to string, invalid number value '" + arg + "' type " + typeof arg + ".");
}
function fromWei(weiInput, unit, optionsInput) {
    var wei = numberToBN(weiInput); // eslint-disable-line
    var negative = wei.lt(zero); // eslint-disable-line
    var base = getValueOfUnit(unit);
    var baseLength = unitMap[unit].length - 1 || 1;
    var options = optionsInput || {};
    if (negative) wei = wei.mul(negative1);
    var fraction = wei.mod(base).toString(10); // eslint-disable-line
    while(fraction.length < baseLength)fraction = "0" + fraction;
    if (!options.pad) fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    var whole = wei.div(base).toString(10); // eslint-disable-line
    if (options.commify) whole = whole.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    var value = "" + whole + (fraction == "0" ? "" : "." + fraction); // eslint-disable-line
    if (negative) value = "-" + value;
    return value;
}
function toWei(etherInput, unit) {
    var ether = numberToString(etherInput); // eslint-disable-line
    var base = getValueOfUnit(unit);
    var baseLength = unitMap[unit].length - 1 || 1;
    // Is it negative?
    var negative = ether.substring(0, 1) === "-"; // eslint-disable-line
    if (negative) ether = ether.substring(1);
    if (ether === ".") throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, invalid value");
    // Split it into a whole and fractional part
    var comps = ether.split("."); // eslint-disable-line
    if (comps.length > 2) throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei,  too many decimal points");
    var whole = comps[0], fraction = comps[1]; // eslint-disable-line
    if (!whole) whole = "0";
    if (!fraction) fraction = "0";
    if (fraction.length > baseLength) throw new Error("[ethjs-unit] while converting number " + etherInput + " to wei, too many decimal places");
    while(fraction.length < baseLength)fraction += "0";
    whole = new BN(whole);
    fraction = new BN(fraction);
    var wei = whole.mul(base).add(fraction); // eslint-disable-line
    if (negative) wei = wei.mul(negative1);
    return new BN(wei.toString(10), 10);
}
module.exports = {
    unitMap: unitMap,
    numberToString: numberToString,
    getValueOfUnit: getValueOfUnit,
    fromWei: fromWei,
    toWei: toWei
};

},{"bn.js":"eSoQd","number-to-bn":"b7NYl"}],"eSoQd":[function(require,module,exports) {
(function(module, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module === "object") module.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        Buffer = require("buffer").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") start++;
        if (base === 16) this._parseHex(number, start);
        else this._parseBase(number, base, start);
        if (number[0] === "-") this.negative = 1;
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            // 'a' - 'f'
            if (c >= 49 && c <= 54) r |= c - 49 + 0xa;
            else if (c >= 17 && c <= 22) r |= c - 17 + 0xa;
            else r |= c & 0xf;
        }
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        // Scan 24-bit chunks and add them to the number
        var off = 0;
        for(i = number.length - 6, j = 0; i >= start; i -= 6){
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else r.strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"buffer":"fCgem"}],"b7NYl":[function(require,module,exports) {
var BN = require("bn.js");
var stripHexPrefix = require("strip-hex-prefix");
/**
 * Returns a BN object, converts a number value to a BN
 * @param {String|Number|Object} `arg` input a string number, hex string number, number, BigNumber or BN object
 * @return {Object} `output` BN object of the number
 * @throws if the argument is not an array, object that isn't a bignumber, not a string number or number
 */ module.exports = function numberToBN(arg) {
    if (typeof arg === "string" || typeof arg === "number") {
        var multiplier = new BN(1); // eslint-disable-line
        var formattedString = String(arg).toLowerCase().trim();
        var isHexPrefixed = formattedString.substr(0, 2) === "0x" || formattedString.substr(0, 3) === "-0x";
        var stringArg = stripHexPrefix(formattedString); // eslint-disable-line
        if (stringArg.substr(0, 1) === "-") {
            stringArg = stripHexPrefix(stringArg.slice(1));
            multiplier = new BN(-1, 10);
        }
        stringArg = stringArg === "" ? "0" : stringArg;
        if (!stringArg.match(/^-?[0-9]+$/) && stringArg.match(/^[0-9A-Fa-f]+$/) || stringArg.match(/^[a-fA-F]+$/) || isHexPrefixed === true && stringArg.match(/^[0-9A-Fa-f]+$/)) return new BN(stringArg, 16).mul(multiplier);
        if ((stringArg.match(/^-?[0-9]+$/) || stringArg === "") && isHexPrefixed === false) return new BN(stringArg, 10).mul(multiplier);
    } else if (typeof arg === "object" && arg.toString && !arg.pop && !arg.push) {
        if (arg.toString(10).match(/^-?[0-9]+$/) && (arg.mul || arg.dividedToIntegerBy)) return new BN(arg.toString(10), 10);
    }
    throw new Error("[number-to-bn] while converting number " + JSON.stringify(arg) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.");
};

},{"bn.js":"3dklp","strip-hex-prefix":"5tFR0"}],"3dklp":[function(require,module,exports) {
(function(module, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module === "object") module.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        Buffer = require("buffer").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") start++;
        if (base === 16) this._parseHex(number, start);
        else this._parseBase(number, base, start);
        if (number[0] === "-") this.negative = 1;
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            // 'a' - 'f'
            if (c >= 49 && c <= 54) r |= c - 49 + 0xa;
            else if (c >= 17 && c <= 22) r |= c - 17 + 0xa;
            else r |= c & 0xf;
        }
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        // Scan 24-bit chunks and add them to the number
        var off = 0;
        for(i = number.length - 6, j = 0; i >= start; i -= 6){
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] |= w >>> 26 - off & 0x3fffff;
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else r.strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"buffer":"fCgem"}],"5tFR0":[function(require,module,exports) {
var isHexPrefixed = require("is-hex-prefixed");
/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */ module.exports = function stripHexPrefix(str) {
    if (typeof str !== "string") return str;
    return isHexPrefixed(str) ? str.slice(2) : str;
};

},{"is-hex-prefixed":"1YjCl"}],"1YjCl":[function(require,module,exports) {
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */ module.exports = function isHexPrefixed(str) {
    if (typeof str !== "string") throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str + ", while checking isHexPrefixed.");
    return str.slice(0, 2) === "0x";
};

},{}],"1hTeY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webcryptoShimMjs = require("./webcrypto-shim.mjs");
exports.default = window.crypto;

},{"./webcrypto-shim.mjs":"jpoeZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jpoeZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @file Web Cryptography API shim
 * @author Artem S Vybornov <vybornov@gmail.com>
 * @license MIT
 */ (function(global, factory) {
    if (typeof define === "function" && define.amd) // AMD. Register as an anonymous module.
    define([], function() {
        return factory(global);
    });
    else if (module.exports) // CommonJS-like environments that support module.exports
    module.exports = factory(global);
    else factory(global);
})(typeof self !== "undefined" ? self : undefined, function(global) {
    "use strict";
    if (typeof Promise !== "function") throw "Promise support required";
    var _crypto = global.crypto || global.msCrypto;
    if (!_crypto) return;
    var _subtle = _crypto.subtle || _crypto.webkitSubtle;
    if (!_subtle) return;
    var _Crypto = global.Crypto || _crypto.constructor || Object, _SubtleCrypto = global.SubtleCrypto || _subtle.constructor || Object, _CryptoKey = global.CryptoKey || global.Key || Object;
    var isEdge = global.navigator.userAgent.indexOf("Edge/") > -1;
    var isIE = !!global.msCrypto && !isEdge;
    var isWebkit = !_crypto.subtle && !!_crypto.webkitSubtle;
    if (!isIE && !isWebkit) return;
    function s2a(s) {
        return btoa(s).replace(/\=+$/, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function a2s(s) {
        s += "===", s = s.slice(0, -s.length % 4);
        return atob(s.replace(/-/g, "+").replace(/_/g, "/"));
    }
    function s2b(s) {
        var b = new Uint8Array(s.length);
        for(var i = 0; i < s.length; i++)b[i] = s.charCodeAt(i);
        return b;
    }
    function b2s(b) {
        if (b instanceof ArrayBuffer) b = new Uint8Array(b);
        return String.fromCharCode.apply(String, b);
    }
    function alg1(a) {
        var r = {
            "name": (a.name || a || "").toUpperCase().replace("V", "v")
        };
        switch(r.name){
            case "SHA-1":
            case "SHA-256":
            case "SHA-384":
            case "SHA-512":
                break;
            case "AES-CBC":
            case "AES-GCM":
            case "AES-KW":
                if (a.length) r["length"] = a.length;
                break;
            case "HMAC":
                if (a.hash) r["hash"] = alg1(a.hash);
                if (a.length) r["length"] = a.length;
                break;
            case "RSAES-PKCS1-v1_5":
                if (a.publicExponent) r["publicExponent"] = new Uint8Array(a.publicExponent);
                if (a.modulusLength) r["modulusLength"] = a.modulusLength;
                break;
            case "RSASSA-PKCS1-v1_5":
            case "RSA-OAEP":
                if (a.hash) r["hash"] = alg1(a.hash);
                if (a.publicExponent) r["publicExponent"] = new Uint8Array(a.publicExponent);
                if (a.modulusLength) r["modulusLength"] = a.modulusLength;
                break;
            default:
                throw new SyntaxError("Bad algorithm name");
        }
        return r;
    }
    function jwkAlg(a) {
        return ({
            "HMAC": {
                "SHA-1": "HS1",
                "SHA-256": "HS256",
                "SHA-384": "HS384",
                "SHA-512": "HS512"
            },
            "RSASSA-PKCS1-v1_5": {
                "SHA-1": "RS1",
                "SHA-256": "RS256",
                "SHA-384": "RS384",
                "SHA-512": "RS512"
            },
            "RSAES-PKCS1-v1_5": {
                "": "RSA1_5"
            },
            "RSA-OAEP": {
                "SHA-1": "RSA-OAEP",
                "SHA-256": "RSA-OAEP-256"
            },
            "AES-KW": {
                "128": "A128KW",
                "192": "A192KW",
                "256": "A256KW"
            },
            "AES-GCM": {
                "128": "A128GCM",
                "192": "A192GCM",
                "256": "A256GCM"
            },
            "AES-CBC": {
                "128": "A128CBC",
                "192": "A192CBC",
                "256": "A256CBC"
            }
        })[a.name][(a.hash || {}).name || a.length || ""];
    }
    function b2jwk(k) {
        if (k instanceof ArrayBuffer || k instanceof Uint8Array) k = JSON.parse(decodeURIComponent(escape(b2s(k))));
        var jwk = {
            "kty": k.kty,
            "alg": k.alg,
            "ext": k.ext || k.extractable
        };
        switch(jwk.kty){
            case "oct":
                jwk.k = k.k;
            case "RSA":
                [
                    "n",
                    "e",
                    "d",
                    "p",
                    "q",
                    "dp",
                    "dq",
                    "qi",
                    "oth"
                ].forEach(function(x) {
                    if (x in k) jwk[x] = k[x];
                });
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        return jwk;
    }
    function jwk2b(k) {
        var jwk = b2jwk(k);
        if (isIE) jwk["extractable"] = jwk.ext, delete jwk.ext;
        return s2b(unescape(encodeURIComponent(JSON.stringify(jwk)))).buffer;
    }
    function pkcs2jwk(k) {
        var info = b2der(k), prv = false;
        if (info.length > 2) prv = true, info.shift(); // remove version from PKCS#8 PrivateKeyInfo structure
        var jwk = {
            "ext": true
        };
        switch(info[0][0]){
            case "1.2.840.113549.1.1.1":
                var rsaComp = [
                    "n",
                    "e",
                    "d",
                    "p",
                    "q",
                    "dp",
                    "dq",
                    "qi"
                ], rsaKey = b2der(info[1]);
                if (prv) rsaKey.shift(); // remove version from PKCS#1 RSAPrivateKey structure
                for(var i = 0; i < rsaKey.length; i++){
                    if (!rsaKey[i][0]) rsaKey[i] = rsaKey[i].subarray(1);
                    jwk[rsaComp[i]] = s2a(b2s(rsaKey[i]));
                }
                jwk["kty"] = "RSA";
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        return jwk;
    }
    function jwk2pkcs(k) {
        var key, info = [
            [
                "",
                null
            ]
        ], prv = false;
        switch(k.kty){
            case "RSA":
                var rsaComp = [
                    "n",
                    "e",
                    "d",
                    "p",
                    "q",
                    "dp",
                    "dq",
                    "qi"
                ], rsaKey = [];
                for(var i = 0; i < rsaComp.length; i++){
                    if (!(rsaComp[i] in k)) break;
                    var b = rsaKey[i] = s2b(a2s(k[rsaComp[i]]));
                    if (b[0] & 0x80) rsaKey[i] = new Uint8Array(b.length + 1), rsaKey[i].set(b, 1);
                }
                if (rsaKey.length > 2) prv = true, rsaKey.unshift(new Uint8Array([
                    0
                ])); // add version to PKCS#1 RSAPrivateKey structure
                info[0][0] = "1.2.840.113549.1.1.1";
                key = rsaKey;
                break;
            default:
                throw new TypeError("Unsupported key type");
        }
        info.push(new Uint8Array(der2b(key)).buffer);
        if (!prv) info[1] = {
            "tag": 0x03,
            "value": info[1]
        };
        else info.unshift(new Uint8Array([
            0
        ])); // add version to PKCS#8 PrivateKeyInfo structure
        return new Uint8Array(der2b(info)).buffer;
    }
    var oid2str = {
        "KoZIhvcNAQEB": "1.2.840.113549.1.1.1"
    }, str2oid = {
        "1.2.840.113549.1.1.1": "KoZIhvcNAQEB"
    };
    function b2der(buf, ctx) {
        if (buf instanceof ArrayBuffer) buf = new Uint8Array(buf);
        if (!ctx) ctx = {
            pos: 0,
            end: buf.length
        };
        if (ctx.end - ctx.pos < 2 || ctx.end > buf.length) throw new RangeError("Malformed DER");
        var tag = buf[ctx.pos++], len = buf[ctx.pos++];
        if (len >= 0x80) {
            len &= 0x7f;
            if (ctx.end - ctx.pos < len) throw new RangeError("Malformed DER");
            for(var xlen = 0; len--;)xlen <<= 8, xlen |= buf[ctx.pos++];
            len = xlen;
        }
        if (ctx.end - ctx.pos < len) throw new RangeError("Malformed DER");
        var rv;
        switch(tag){
            case 0x02:
                rv = buf.subarray(ctx.pos, ctx.pos += len);
                break;
            case 0x03:
                if (buf[ctx.pos++]) throw new Error("Unsupported bit string");
                len--;
            case 0x04:
                rv = new Uint8Array(buf.subarray(ctx.pos, ctx.pos += len)).buffer;
                break;
            case 0x05:
                rv = null;
                break;
            case 0x06:
                var oid = btoa(b2s(buf.subarray(ctx.pos, ctx.pos += len)));
                if (!(oid in oid2str)) throw new Error("Unsupported OBJECT ID " + oid);
                rv = oid2str[oid];
                break;
            case 0x30:
                rv = [];
                for(var end = ctx.pos + len; ctx.pos < end;)rv.push(b2der(buf, ctx));
                break;
            default:
                throw new Error("Unsupported DER tag 0x" + tag.toString(16));
        }
        return rv;
    }
    function der2b(val, buf) {
        if (!buf) buf = [];
        var tag = 0, len = 0, pos = buf.length + 2;
        buf.push(0, 0); // placeholder
        if (val instanceof Uint8Array) {
            tag = 0x02, len = val.length;
            for(var i = 0; i < len; i++)buf.push(val[i]);
        } else if (val instanceof ArrayBuffer) {
            tag = 0x04, len = val.byteLength, val = new Uint8Array(val);
            for(var i = 0; i < len; i++)buf.push(val[i]);
        } else if (val === null) tag = 0x05, len = 0;
        else if (typeof val === "string" && val in str2oid) {
            var oid = s2b(atob(str2oid[val]));
            tag = 0x06, len = oid.length;
            for(var i = 0; i < len; i++)buf.push(oid[i]);
        } else if (val instanceof Array) {
            for(var i = 0; i < val.length; i++)der2b(val[i], buf);
            tag = 0x30, len = buf.length - pos;
        } else if (typeof val === "object" && val.tag === 0x03 && val.value instanceof ArrayBuffer) {
            val = new Uint8Array(val.value), tag = 0x03, len = val.byteLength;
            buf.push(0);
            for(var i = 0; i < len; i++)buf.push(val[i]);
            len++;
        } else throw new Error("Unsupported DER value " + val);
        if (len >= 0x80) {
            var xlen = len, len = 4;
            buf.splice(pos, 0, xlen >> 24 & 0xff, xlen >> 16 & 0xff, xlen >> 8 & 0xff, xlen & 0xff);
            while(len > 1 && !(xlen >> 24))xlen <<= 8, len--;
            if (len < 4) buf.splice(pos, 4 - len);
            len |= 0x80;
        }
        buf.splice(pos - 2, 2, tag, len);
        return buf;
    }
    function CryptoKey(key, alg, ext, use) {
        Object.defineProperties(this, {
            _key: {
                value: key
            },
            type: {
                value: key.type,
                enumerable: true
            },
            extractable: {
                value: ext === undefined ? key.extractable : ext,
                enumerable: true
            },
            algorithm: {
                value: alg === undefined ? key.algorithm : alg,
                enumerable: true
            },
            usages: {
                value: use === undefined ? key.usages : use,
                enumerable: true
            }
        });
    }
    function isPubKeyUse(u) {
        return u === "verify" || u === "encrypt" || u === "wrapKey";
    }
    function isPrvKeyUse(u) {
        return u === "sign" || u === "decrypt" || u === "unwrapKey";
    }
    [
        "generateKey",
        "importKey",
        "unwrapKey"
    ].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c) {
            var args = [].slice.call(arguments), ka, kx, ku;
            switch(m){
                case "generateKey":
                    ka = alg1(a), kx = b, ku = c;
                    break;
                case "importKey":
                    ka = alg1(c), kx = args[3], ku = args[4];
                    if (a === "jwk") {
                        b = b2jwk(b);
                        if (!b.alg) b.alg = jwkAlg(ka);
                        if (!b.key_ops) b.key_ops = b.kty !== "oct" ? "d" in b ? ku.filter(isPrvKeyUse) : ku.filter(isPubKeyUse) : ku.slice();
                        args[1] = jwk2b(b);
                    }
                    break;
                case "unwrapKey":
                    ka = args[4], kx = args[5], ku = args[6];
                    args[2] = c._key;
                    break;
            }
            if (m === "generateKey" && ka.name === "HMAC" && ka.hash) {
                ka.length = ka.length || ({
                    "SHA-1": 512,
                    "SHA-256": 512,
                    "SHA-384": 1024,
                    "SHA-512": 1024
                })[ka.hash.name];
                return _subtle.importKey("raw", _crypto.getRandomValues(new Uint8Array(ka.length + 7 >> 3)), ka, kx, ku);
            }
            if (isWebkit && m === "generateKey" && ka.name === "RSASSA-PKCS1-v1_5" && (!ka.modulusLength || ka.modulusLength >= 2048)) {
                a = alg1(a), a.name = "RSAES-PKCS1-v1_5", delete a.hash;
                return _subtle.generateKey(a, true, [
                    "encrypt",
                    "decrypt"
                ]).then(function(k) {
                    return Promise.all([
                        _subtle.exportKey("jwk", k.publicKey),
                        _subtle.exportKey("jwk", k.privateKey), 
                    ]);
                }).then(function(keys) {
                    keys[0].alg = keys[1].alg = jwkAlg(ka);
                    keys[0].key_ops = ku.filter(isPubKeyUse), keys[1].key_ops = ku.filter(isPrvKeyUse);
                    return Promise.all([
                        _subtle.importKey("jwk", keys[0], ka, true, keys[0].key_ops),
                        _subtle.importKey("jwk", keys[1], ka, kx, keys[1].key_ops), 
                    ]);
                }).then(function(keys) {
                    return {
                        publicKey: keys[0],
                        privateKey: keys[1]
                    };
                });
            }
            if ((isWebkit || isIE && (ka.hash || {}).name === "SHA-1") && m === "importKey" && a === "jwk" && ka.name === "HMAC" && b.kty === "oct") return _subtle.importKey("raw", s2b(a2s(b.k)), c, args[3], args[4]);
            if (isWebkit && m === "importKey" && (a === "spki" || a === "pkcs8")) return _subtle.importKey("jwk", pkcs2jwk(b), c, args[3], args[4]);
            if (isIE && m === "unwrapKey") return _subtle.decrypt(args[3], c, b).then(function(k) {
                return _subtle.importKey(a, k, args[4], args[5], args[6]);
            });
            var op;
            try {
                op = _fn.apply(_subtle, args);
            } catch (e1) {
                return Promise.reject(e1);
            }
            if (isIE) op = new Promise(function(res, rej) {
                op.onabort = op.onerror = function(e) {
                    rej(e);
                };
                op.oncomplete = function(r) {
                    res(r.target.result);
                };
            });
            op = op.then(function(k) {
                if (ka.name === "HMAC") {
                    if (!ka.length) ka.length = 8 * k.algorithm.length;
                }
                if (ka.name.search("RSA") == 0) {
                    if (!ka.modulusLength) ka.modulusLength = (k.publicKey || k).algorithm.modulusLength;
                    if (!ka.publicExponent) ka.publicExponent = (k.publicKey || k).algorithm.publicExponent;
                }
                if (k.publicKey && k.privateKey) k = {
                    publicKey: new CryptoKey(k.publicKey, ka, kx, ku.filter(isPubKeyUse)),
                    privateKey: new CryptoKey(k.privateKey, ka, kx, ku.filter(isPrvKeyUse))
                };
                else k = new CryptoKey(k, ka, kx, ku);
                return k;
            });
            return op;
        };
    });
    [
        "exportKey",
        "wrapKey"
    ].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c) {
            var args = [].slice.call(arguments);
            switch(m){
                case "exportKey":
                    args[1] = b._key;
                    break;
                case "wrapKey":
                    args[1] = b._key, args[2] = c._key;
                    break;
            }
            if ((isWebkit || isIE && (b.algorithm.hash || {}).name === "SHA-1") && m === "exportKey" && a === "jwk" && b.algorithm.name === "HMAC") args[0] = "raw";
            if (isWebkit && m === "exportKey" && (a === "spki" || a === "pkcs8")) args[0] = "jwk";
            if (isIE && m === "wrapKey") return _subtle.exportKey(a, b).then(function(k) {
                if (a === "jwk") k = s2b(unescape(encodeURIComponent(JSON.stringify(b2jwk(k)))));
                return _subtle.encrypt(args[3], c, k);
            });
            var op;
            try {
                op = _fn.apply(_subtle, args);
            } catch (e2) {
                return Promise.reject(e2);
            }
            if (isIE) op = new Promise(function(res, rej) {
                op.onabort = op.onerror = function(e) {
                    rej(e);
                };
                op.oncomplete = function(r) {
                    res(r.target.result);
                };
            });
            if (m === "exportKey" && a === "jwk") op = op.then(function(k) {
                if ((isWebkit || isIE && (b.algorithm.hash || {}).name === "SHA-1") && b.algorithm.name === "HMAC") return {
                    "kty": "oct",
                    "alg": jwkAlg(b.algorithm),
                    "key_ops": b.usages.slice(),
                    "ext": true,
                    "k": s2a(b2s(k))
                };
                k = b2jwk(k);
                if (!k.alg) k["alg"] = jwkAlg(b.algorithm);
                if (!k.key_ops) k["key_ops"] = b.type === "public" ? b.usages.filter(isPubKeyUse) : b.type === "private" ? b.usages.filter(isPrvKeyUse) : b.usages.slice();
                return k;
            });
            if (isWebkit && m === "exportKey" && (a === "spki" || a === "pkcs8")) op = op.then(function(k) {
                k = jwk2pkcs(b2jwk(k));
                return k;
            });
            return op;
        };
    });
    [
        "encrypt",
        "decrypt",
        "sign",
        "verify"
    ].forEach(function(m) {
        var _fn = _subtle[m];
        _subtle[m] = function(a, b, c1, d) {
            if (isIE && (!c1.byteLength || d && !d.byteLength)) throw new Error("Empy input is not allowed");
            var args = [].slice.call(arguments), ka = alg1(a);
            if (isIE && m === "decrypt" && ka.name === "AES-GCM") {
                var tl = a.tagLength >> 3;
                args[2] = (c1.buffer || c1).slice(0, c1.byteLength - tl), a.tag = (c1.buffer || c1).slice(c1.byteLength - tl);
            }
            args[1] = b._key;
            var op;
            try {
                op = _fn.apply(_subtle, args);
            } catch (e3) {
                return Promise.reject(e3);
            }
            if (isIE) op = new Promise(function(res, rej) {
                op.onabort = op.onerror = function(e) {
                    rej(e);
                };
                op.oncomplete = function(r) {
                    var r = r.target.result;
                    if (m === "encrypt" && r instanceof AesGcmEncryptResult) {
                        var c = r.ciphertext, t = r.tag;
                        r = new Uint8Array(c.byteLength + t.byteLength);
                        r.set(new Uint8Array(c), 0);
                        r.set(new Uint8Array(t), c.byteLength);
                        r = r.buffer;
                    }
                    res(r);
                };
            });
            return op;
        };
    });
    if (isIE) {
        var _digest = _subtle.digest;
        _subtle["digest"] = function(a, b) {
            if (!b.byteLength) throw new Error("Empy input is not allowed");
            var op;
            try {
                op = _digest.call(_subtle, a, b);
            } catch (e4) {
                return Promise.reject(e4);
            }
            op = new Promise(function(res, rej) {
                op.onabort = op.onerror = function(e) {
                    rej(e);
                };
                op.oncomplete = function(r) {
                    res(r.target.result);
                };
            });
            return op;
        };
        global.crypto = Object.create(_crypto, {
            getRandomValues: {
                value: function(a) {
                    return _crypto.getRandomValues(a);
                }
            },
            subtle: {
                value: _subtle
            }
        });
        global.CryptoKey = CryptoKey;
    }
    if (isWebkit) {
        _crypto.subtle = _subtle;
        global.Crypto = _Crypto;
        global.SubtleCrypto = _SubtleCrypto;
        global.CryptoKey = CryptoKey;
    }
});
exports.default = {} // section modified by isomorphic-webcrypto build 
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"loGF4":[function(require,module,exports) {
const { crc16 , hexToBytes , bytesToHex , stringToBytes , base64toString , stringToBase64  } = require("./Utils");
const bounceable_tag = 0x11;
const non_bounceable_tag = 0x51;
const test_flag = 0x80;
/**
 * @private
 * @param addressString {string}
 * @return {{isTestOnly: boolean, workchain: number, hashPart: Uint8Array, isBounceable: boolean}}
 */ function parseFriendlyAddress(addressString) {
    if (addressString.length !== 48) throw new Error(`User-friendly address should contain strictly 48 characters`);
    const data = stringToBytes(base64toString(addressString));
    if (data.length !== 36) throw "Unknown address type: byte length is not equal to 36";
    const addr = data.slice(0, 34);
    const crc = data.slice(34, 36);
    const calcedCrc = crc16(addr);
    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) throw "Wrong crc16 hashsum";
    let tag = addr[0];
    let isTestOnly = false;
    let isBounceable = false;
    if (tag & test_flag) {
        isTestOnly = true;
        tag = tag ^ test_flag;
    }
    if (tag !== bounceable_tag && tag !== non_bounceable_tag) throw "Unknown address tag";
    isBounceable = tag === bounceable_tag;
    let workchain = null;
    if (addr[1] === 0xff) workchain = -1;
    else workchain = addr[1];
    if (workchain !== 0 && workchain !== -1) throw new Error("Invalid address wc " + workchain);
    const hashPart = addr.slice(2, 34);
    return {
        isTestOnly,
        isBounceable,
        workchain,
        hashPart
    };
}
class Address {
    /**
     * @param anyForm {string | Address}
     */ static isValid(anyForm) {
        try {
            new Address(anyForm);
            return true;
        } catch (e) {
            return false;
        }
    }
    /**
     * @param anyForm {string | Address}
     */ constructor(anyForm){
        if (anyForm == null) throw "Invalid address";
        if (anyForm instanceof Address) {
            this.wc = anyForm.wc;
            this.hashPart = anyForm.hashPart;
            this.isTestOnly = anyForm.isTestOnly;
            this.isUserFriendly = anyForm.isUserFriendly;
            this.isBounceable = anyForm.isBounceable;
            this.isUrlSafe = anyForm.isUrlSafe;
            return;
        }
        if (anyForm.search(/\-/) > 0 || anyForm.search(/_/) > 0) {
            this.isUrlSafe = true;
            anyForm = anyForm.replace(/\-/g, "+").replace(/_/g, "/");
        } else this.isUrlSafe = false;
        if (anyForm.indexOf(":") > -1) {
            const arr = anyForm.split(":");
            if (arr.length !== 2) throw new Error("Invalid address " + anyForm);
            const wc = parseInt(arr[0]);
            if (wc !== 0 && wc !== -1) throw new Error("Invalid address wc " + anyForm);
            const hex = arr[1];
            if (hex.length !== 64) throw new Error("Invalid address hex " + anyForm);
            this.isUserFriendly = false;
            this.wc = wc;
            this.hashPart = hexToBytes(hex);
            this.isTestOnly = false;
            this.isBounceable = false;
        } else {
            this.isUserFriendly = true;
            const parseResult = parseFriendlyAddress(anyForm);
            this.wc = parseResult.workchain;
            this.hashPart = parseResult.hashPart;
            this.isTestOnly = parseResult.isTestOnly;
            this.isBounceable = parseResult.isBounceable;
        }
    }
    /**
     * @param isUserFriendly? {boolean}
     * @param isUrlSafe? {boolean}
     * @param isBounceable? {boolean}
     * @param isTestOnly? {boolean}
     * @return {string}
     */ toString(isUserFriendly, isUrlSafe, isBounceable, isTestOnly) {
        if (isUserFriendly === undefined) isUserFriendly = this.isUserFriendly;
        if (isUrlSafe === undefined) isUrlSafe = this.isUrlSafe;
        if (isBounceable === undefined) isBounceable = this.isBounceable;
        if (isTestOnly === undefined) isTestOnly = this.isTestOnly;
        if (!isUserFriendly) return this.wc + ":" + bytesToHex(this.hashPart);
        else {
            let tag = isBounceable ? bounceable_tag : non_bounceable_tag;
            if (isTestOnly) tag |= test_flag;
            const addr = new Int8Array(34);
            addr[0] = tag;
            addr[1] = this.wc;
            addr.set(this.hashPart, 2);
            const addressWithChecksum = new Uint8Array(36);
            addressWithChecksum.set(addr);
            addressWithChecksum.set(crc16(addr), 34);
            let addressBase64 = stringToBase64(String.fromCharCode.apply(null, new Uint8Array(addressWithChecksum)));
            if (isUrlSafe) addressBase64 = addressBase64.replace(/\+/g, "-").replace(/\//g, "_");
            return addressBase64;
        }
    }
}
module.exports.default = Address;

},{"./Utils":"dop5X"}],"4fqdK":[function(require,module,exports) {
const { BitString  } = require("./BitString");
const { Cell  } = require("./Cell");
module.exports = {
    BitString,
    Cell
};

},{"./BitString":"kWQHd","./Cell":"7xj2T"}],"kWQHd":[function(require,module,exports) {
const { BN , bytesToHex  } = require("../utils");
class BitString {
    /**
     * @param length {number}    length of BitString in bits
     */ constructor(length){
        this.array = Uint8Array.from({
            length: Math.ceil(length / 8)
        }, ()=>0);
        this.cursor = 0;
        this.length = length;
    }
    /**
     * @return {number}
     */ getFreeBits() {
        return this.length - this.cursor;
    }
    /**
     * @return {number}
     */ getUsedBits() {
        return this.cursor;
    }
    /**
     * @return {number}
     */ getUsedBytes() {
        return Math.ceil(this.cursor / 8);
    }
    /**
     * @param n {number}
     * @return {boolean}    bit value at position `n`
     */ get(n) {
        return (this.array[n / 8 | 0] & 1 << 7 - n % 8) > 0;
    }
    /**
     * @private
     * @param n {number}
     */ checkRange(n) {
        if (n > this.length) throw Error("BitString overflow");
    }
    /**
     * Set bit value to 1 at position `n`
     * @param n {number}
     */ on(n) {
        this.checkRange(n);
        this.array[n / 8 | 0] |= 1 << 7 - n % 8;
    }
    /**
     * Set bit value to 0 at position `n`
     * @param n {number}
     */ off(n) {
        this.checkRange(n);
        this.array[n / 8 | 0] &= ~(1 << 7 - n % 8);
    }
    /**
     * Toggle bit value at position `n`
     * @param n {number}
     */ toggle(n) {
        this.checkRange(n);
        this.array[n / 8 | 0] ^= 1 << 7 - n % 8;
    }
    /**
     * forEach every bit
     * @param callback  {function(boolean): void}
     */ forEach(callback) {
        const max = this.cursor;
        for(let x = 0; x < max; x++)callback(this.get(x));
    }
    /**
     * Write bit and increase cursor
     * @param b  {boolean | number}
     */ writeBit(b) {
        if (b && b > 0) this.on(this.cursor);
        else this.off(this.cursor);
        this.cursor = this.cursor + 1;
    }
    /**
     * @param ba  {Array<boolean | number>}
     */ writeBitArray(ba) {
        for(let i = 0; i < ba.length; i++)this.writeBit(ba[i]);
    }
    /**
     * Write unsigned int
     * @param number  {number | BN}
     * @param bitLength  {number}  size of uint in bits
     */ writeUint(number, bitLength) {
        number = new BN(number);
        if (bitLength == 0 || number.toString(2).length > bitLength) {
            if (number == 0) return;
            throw Error("bitLength is too small for number, got number=" + number + ",bitLength=" + bitLength);
        }
        const s = number.toString(2, bitLength);
        for(let i = 0; i < bitLength; i++)this.writeBit(s[i] == 1);
    }
    /**
     * Write signed int
     * @param number  {number | BN}
     * @param bitLength  {number}  size of int in bits
     */ writeInt(number, bitLength) {
        number = new BN(number);
        if (bitLength == 1) {
            if (number == -1) {
                this.writeBit(true);
                return;
            }
            if (number == 0) {
                this.writeBit(false);
                return;
            }
            throw Error("Bitlength is too small for number");
        } else if (number.isNeg()) {
            this.writeBit(true);
            const b = new BN(2);
            const nb = b.pow(new BN(bitLength - 1));
            this.writeUint(nb.add(number), bitLength - 1);
        } else {
            this.writeBit(false);
            this.writeUint(number, bitLength - 1);
        }
    }
    /**
     * Write unsigned 8-bit int
     * @param ui8 {number}
     */ writeUint8(ui8) {
        this.writeUint(ui8, 8);
    }
    /**
     * Write array of unsigned 8-bit ints
     * @param ui8 {Uint8Array}
     */ writeBytes(ui8) {
        for(let i = 0; i < ui8.length; i++)this.writeUint8(ui8[i]);
    }
    /**
     * Write UTF-8 string
     *
     * @param value {string}
     */ writeString(value) {
        this.writeBytes(new TextEncoder().encode(value));
    }
    /**
     * @param amount  {number | BN} in nanograms
     */ writeGrams(amount) {
        if (amount == 0) this.writeUint(0, 4);
        else {
            amount = new BN(amount);
            const l = Math.ceil(amount.toString(16).length / 2);
            this.writeUint(l, 4);
            this.writeUint(amount, l * 8);
        }
    }
    /**
     * @param amount  {number | BN} in nanotons
     */ writeCoins(amount) {
        this.writeGrams(amount);
    }
    //addr_none$00 = MsgAddressExt;
    //addr_std$10 anycast:(Maybe Anycast)
    // workchain_id:int8 address:uint256 = MsgAddressInt;
    /**
     * @param address {Address | null}
     */ writeAddress(address) {
        if (address == null) this.writeUint(0, 2);
        else {
            this.writeUint(2, 2);
            this.writeUint(0, 1); // TODO split addresses (anycast)
            this.writeInt(address.wc, 8);
            this.writeBytes(address.hashPart);
        }
    }
    /**
     * write another BitString to this BitString
     * @param anotherBitString  {BitString}
     */ writeBitString(anotherBitString) {
        anotherBitString.forEach((x)=>{
            this.writeBit(x);
        });
    }
    clone() {
        const result = new BitString(0);
        result.array = this.array.slice(0);
        result.length = this.length;
        result.cursor = this.cursor;
        return result;
    }
    /**
     * @return {string} hex
     */ toString() {
        return this.toHex();
    }
    /**
     * @return {Uint8Array}
     */ getTopUppedArray() {
        const ret = this.clone();
        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;
        if (tu > 0) {
            tu = tu - 1;
            ret.writeBit(true);
            while(tu > 0){
                tu = tu - 1;
                ret.writeBit(false);
            }
        }
        ret.array = ret.array.slice(0, Math.ceil(ret.cursor / 8));
        return ret.array;
    }
    /**
     * like Fift
     * @return {string}
     */ toHex() {
        if (this.cursor % 4 === 0) {
            const s = bytesToHex(this.array.slice(0, Math.ceil(this.cursor / 8))).toUpperCase();
            if (this.cursor % 8 === 0) return s;
            else return s.substr(0, s.length - 1);
        } else {
            const temp = this.clone();
            temp.writeBit(1);
            while(temp.cursor % 4 !== 0)temp.writeBit(0);
            const hex = temp.toHex().toUpperCase();
            return hex + "_";
        }
    }
    /**
     * set this cell data to match provided topUppedArray
     * @param array  {Uint8Array}
     * @param fullfilledBytes  {boolean}
     */ setTopUppedArray(array, fullfilledBytes = true) {
        this.length = array.length * 8;
        this.array = array;
        this.cursor = this.length;
        if (fullfilledBytes || !this.length) return;
        else {
            let foundEndBit = false;
            for(let c = 0; c < 7; c++){
                this.cursor -= 1;
                if (this.get(this.cursor)) {
                    foundEndBit = true;
                    this.off(this.cursor);
                    break;
                }
            }
            if (!foundEndBit) {
                console.log(array, fullfilledBytes);
                throw new Error("Incorrect TopUppedArray");
            }
        }
    }
}
module.exports = {
    BitString
};

},{"../utils":"57M1Z"}],"7xj2T":[function(require,module,exports) {
const { BitString  } = require("./BitString");
const { bytesToBase64 , compareBytes , concatBytes , crc32c , hexToBytes , readNBytesUIntFromArray , sha256 , bytesToHex  } = require("../utils");
const reachBocMagicPrefix = hexToBytes("B5EE9C72");
const leanBocMagicPrefix = hexToBytes("68ff65f3");
const leanBocMagicPrefixCRC = hexToBytes("acc3a728");
class Cell {
    constructor(){
        this.bits = new BitString(1023);
        this.refs = [];
        this.isExotic = false;
    }
    /**
     * @param serializedBoc  {string | Uint8Array} hex or bytearray
     * @return {Cell[]} root cells
     */ static fromBoc(serializedBoc) {
        return deserializeBoc(serializedBoc);
    }
    /**
     * @param serializedBoc  {string | Uint8Array} hex or bytearray
     * @return {Cell} root cell
     */ static oneFromBoc(serializedBoc) {
        const cells = deserializeBoc(serializedBoc);
        if (cells.length !== 1) throw new Error("expected 1 root cell but have " + cells.length);
        return cells[0];
    }
    /**
     * Write another cell to this cell
     * @param anotherCell  {Cell}
     */ writeCell(anotherCell) {
        // XXX we do not check that there are anough place in cell
        this.bits.writeBitString(anotherCell.bits);
        this.refs = this.refs.concat(anotherCell.refs);
    }
    /**
     * @return {number}
     */ getMaxLevel() {
        //TODO level calculation differ for exotic cells
        let maxLevel = 0;
        for(let k in this.refs){
            const i = this.refs[k];
            if (i.getMaxLevel() > maxLevel) maxLevel = i.getMaxLevel();
        }
        return maxLevel;
    }
    /**
     * @return {number}
     */ isExplicitlyStoredHashes() {
        return 0;
    }
    /**
     * @return {number}
     */ getMaxDepth() {
        let maxDepth = 0;
        if (this.refs.length > 0) {
            for(let k in this.refs){
                const i = this.refs[k];
                if (i.getMaxDepth() > maxDepth) maxDepth = i.getMaxDepth();
            }
            maxDepth = maxDepth + 1;
        }
        return maxDepth;
    }
    /**
     * @private
     * @return {Uint8Array}
     */ getMaxDepthAsArray() {
        const maxDepth = this.getMaxDepth();
        const d = Uint8Array.from({
            length: 2
        }, ()=>0);
        d[1] = maxDepth % 256;
        d[0] = Math.floor(maxDepth / 256);
        return d;
    }
    /**
     * @return {Uint8Array}
     */ getRefsDescriptor() {
        const d1 = Uint8Array.from({
            length: 1
        }, ()=>0);
        d1[0] = this.refs.length + this.isExotic * 8 + this.getMaxLevel() * 32;
        return d1;
    }
    /**
     * @return {Uint8Array}
     */ getBitsDescriptor() {
        const d2 = Uint8Array.from({
            length: 1
        }, ()=>0);
        d2[0] = Math.ceil(this.bits.cursor / 8) + Math.floor(this.bits.cursor / 8);
        return d2;
    }
    /**
     * @return {Uint8Array}
     */ getDataWithDescriptors() {
        const d1 = this.getRefsDescriptor();
        const d2 = this.getBitsDescriptor();
        const tuBits = this.bits.getTopUppedArray();
        return concatBytes(concatBytes(d1, d2), tuBits);
    }
    /**
     * @return {Promise<Uint8Array>}
     */ async getRepr() {
        const reprArray = [];
        reprArray.push(this.getDataWithDescriptors());
        for(let k in this.refs){
            const i = this.refs[k];
            reprArray.push(i.getMaxDepthAsArray());
        }
        for(let k1 in this.refs){
            const i = this.refs[k1];
            reprArray.push(await i.hash());
        }
        let x = new Uint8Array();
        for(let k2 in reprArray){
            const i = reprArray[k2];
            x = concatBytes(x, i);
        }
        return x;
    }
    /**
     * @return {Promise<Uint8Array>}
     */ async hash() {
        return new Uint8Array(await sha256(await this.getRepr()));
    }
    /**
     * Recursively prints cell's content like Fift
     * @return  {string}
     */ print(indent) {
        indent = indent || "";
        let s = indent + "x{" + this.bits.toHex() + "}\n";
        for(let k in this.refs){
            const i = this.refs[k];
            s += i.print(indent + " ");
        }
        return s;
    }
    //serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)
    //  has_cache_bits:(## 1) flags:(## 2) { flags = 0 }
    //  size:(## 3) { size <= 4 }
    //  off_bytes:(## 8) { off_bytes <= 8 }
    //  cells:(##(size * 8))
    //  roots:(##(size * 8)) { roots >= 1 }
    //  absent:(##(size * 8)) { roots + absent <= cells }
    //  tot_cells_size:(##(off_bytes * 8))
    //  root_list:(roots * ##(size * 8))
    //  index:has_idx?(cells * ##(off_bytes * 8))
    //  cell_data:(tot_cells_size * [ uint8 ])
    //  crc32c:has_crc32c?uint32
    // = BagOfCells;
    /**
     * create boc bytearray
     * @param has_idx? {boolean}
     * @param hash_crc32?  {boolean}
     * @param has_cache_bits?  {boolean}
     * @param flags? {number}
     * @return {Promise<Uint8Array>}
     */ async toBoc(has_idx = true, hash_crc32 = true, has_cache_bits = false, flags = 0) {
        const root_cell = this;
        const allcells = await root_cell.treeWalk();
        const topologicalOrder = allcells[0];
        const cellsIndex = allcells[1];
        const cells_num = topologicalOrder.length;
        const s = cells_num.toString(2).length; // Minimal number of bits to represent reference (unused?)
        const s_bytes = Math.min(Math.ceil(s / 8), 1);
        let full_size = 0;
        let sizeIndex = [];
        for (let cell_info of topologicalOrder){
            //TODO it should be async map or async for
            sizeIndex.push(full_size);
            full_size = full_size + await cell_info[1].bocSerializationSize(cellsIndex, s_bytes);
        }
        const offset_bits = full_size.toString(2).length; // Minimal number of bits to offset/len (unused?)
        const offset_bytes = Math.max(Math.ceil(offset_bits / 8), 1);
        const serialization = new BitString(1247 * topologicalOrder.length);
        serialization.writeBytes(reachBocMagicPrefix);
        serialization.writeBitArray([
            has_idx,
            hash_crc32,
            has_cache_bits
        ]);
        serialization.writeUint(flags, 2);
        serialization.writeUint(s_bytes, 3);
        serialization.writeUint8(offset_bytes);
        serialization.writeUint(cells_num, s_bytes * 8);
        serialization.writeUint(1, s_bytes * 8); // One root for now
        serialization.writeUint(0, s_bytes * 8); // Complete BOCs only
        serialization.writeUint(full_size, offset_bytes * 8);
        serialization.writeUint(0, s_bytes * 8); // Root shoulh have index 0
        if (has_idx) topologicalOrder.forEach((cell_data, index)=>serialization.writeUint(sizeIndex[index], offset_bytes * 8));
        for (let cell_info1 of topologicalOrder){
            //TODO it should be async map or async for
            const refcell_ser = await cell_info1[1].serializeForBoc(cellsIndex, s_bytes);
            serialization.writeBytes(refcell_ser);
        }
        let ser_arr = serialization.getTopUppedArray();
        if (hash_crc32) ser_arr = concatBytes(ser_arr, crc32c(ser_arr));
        return ser_arr;
    }
    /**
     * @private
     * @param cellsIndex
     * @param refSize
     * @return {Promise<Uint8Array>}
     */ async serializeForBoc(cellsIndex, refSize) {
        const reprArray = [];
        reprArray.push(this.getDataWithDescriptors());
        if (this.isExplicitlyStoredHashes()) throw new Error("Cell hashes explicit storing is not implemented");
        for(let k in this.refs){
            const i = this.refs[k];
            const refHash = await i.hash();
            const refIndexInt = cellsIndex[refHash];
            let refIndexHex = refIndexInt.toString(16);
            if (refIndexHex.length % 2) refIndexHex = "0" + refIndexHex;
            const reference = hexToBytes(refIndexHex);
            reprArray.push(reference);
        }
        let x = new Uint8Array();
        for(let k3 in reprArray){
            const i = reprArray[k3];
            x = concatBytes(x, i);
        }
        return x;
    }
    /**
     * @private
     * @param cellsIndex
     * @param refSize
     * @return {Promise<number>}
     */ async bocSerializationSize(cellsIndex, refSize) {
        return (await this.serializeForBoc(cellsIndex, refSize)).length;
    }
    /**
     * @private
     * @return {[[], {}]} topologicalOrderArray and indexHashmap
     */ async treeWalk() {
        return treeWalk(this, [], {});
    }
}
async function moveToTheEnd(indexHashmap, topologicalOrderArray, target) {
    const targetIndex = indexHashmap[target];
    for(let h in indexHashmap)if (indexHashmap[h] > targetIndex) indexHashmap[h] = indexHashmap[h] - 1;
    indexHashmap[target] = topologicalOrderArray.length - 1;
    const data = topologicalOrderArray.splice(targetIndex, 1)[0];
    topologicalOrderArray.push(data);
    for (let subCell of data[1].refs)await moveToTheEnd(indexHashmap, topologicalOrderArray, await subCell.hash());
}
/**
 * @param cell  {Cell}
 * @param topologicalOrderArray array of pairs: cellHash: Uint8Array, cell: Cell, ...
 * @param indexHashmap cellHash: Uint8Array -> cellIndex: number
 * @return {[[], {}]} topologicalOrderArray and indexHashmap
 */ async function treeWalk(cell, topologicalOrderArray, indexHashmap, parentHash = null) {
    const cellHash = await cell.hash();
    if (cellHash in indexHashmap) {
        //it is possible that already seen cell is a children of more deep cell
        if (parentHash) {
            if (indexHashmap[parentHash] > indexHashmap[cellHash]) await moveToTheEnd(indexHashmap, topologicalOrderArray, cellHash);
        }
        return [
            topologicalOrderArray,
            indexHashmap
        ];
    }
    indexHashmap[cellHash] = topologicalOrderArray.length;
    topologicalOrderArray.push([
        cellHash,
        cell
    ]);
    for (let subCell of cell.refs){
        const res = await treeWalk(subCell, topologicalOrderArray, indexHashmap, cellHash);
        topologicalOrderArray = res[0];
        indexHashmap = res[1];
    }
    return [
        topologicalOrderArray,
        indexHashmap
    ];
}
function parseBocHeader(serializedBoc) {
    // snake_case is used to match TON docs
    if (serializedBoc.length < 5) throw "Not enough bytes for magic prefix";
    const inputData = serializedBoc; // Save copy for crc32
    const prefix = serializedBoc.slice(0, 4);
    serializedBoc = serializedBoc.slice(4);
    let has_idx, hash_crc32, has_cache_bits, flags, size_bytes;
    if (compareBytes(prefix, reachBocMagicPrefix)) {
        const flags_byte = serializedBoc[0];
        has_idx = flags_byte & 128;
        hash_crc32 = flags_byte & 64;
        has_cache_bits = flags_byte & 32;
        flags = (flags_byte & 16) * 2 + (flags_byte & 8);
        size_bytes = flags_byte % 8;
    }
    if (compareBytes(prefix, leanBocMagicPrefix)) {
        has_idx = 1;
        hash_crc32 = 0;
        has_cache_bits = 0;
        flags = 0;
        size_bytes = serializedBoc[0];
    }
    if (compareBytes(prefix, leanBocMagicPrefixCRC)) {
        has_idx = 1;
        hash_crc32 = 1;
        has_cache_bits = 0;
        flags = 0;
        size_bytes = serializedBoc[0];
    }
    serializedBoc = serializedBoc.slice(1);
    if (serializedBoc.length < 1 + 5 * size_bytes) throw "Not enough bytes for encoding cells counters";
    const offset_bytes = serializedBoc[0];
    serializedBoc = serializedBoc.slice(1);
    const cells_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
    serializedBoc = serializedBoc.slice(size_bytes);
    const roots_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
    serializedBoc = serializedBoc.slice(size_bytes);
    const absent_num = readNBytesUIntFromArray(size_bytes, serializedBoc);
    serializedBoc = serializedBoc.slice(size_bytes);
    const tot_cells_size = readNBytesUIntFromArray(offset_bytes, serializedBoc);
    serializedBoc = serializedBoc.slice(offset_bytes);
    if (serializedBoc.length < roots_num * size_bytes) throw "Not enough bytes for encoding root cells hashes";
    let root_list = [];
    for(let c = 0; c < roots_num; c++){
        root_list.push(readNBytesUIntFromArray(size_bytes, serializedBoc));
        serializedBoc = serializedBoc.slice(size_bytes);
    }
    let index = false;
    if (has_idx) {
        index = [];
        if (serializedBoc.length < offset_bytes * cells_num) throw "Not enough bytes for index encoding";
        for(let c = 0; c < cells_num; c++){
            index.push(readNBytesUIntFromArray(offset_bytes, serializedBoc));
            serializedBoc = serializedBoc.slice(offset_bytes);
        }
    }
    if (serializedBoc.length < tot_cells_size) throw "Not enough bytes for cells data";
    const cells_data = serializedBoc.slice(0, tot_cells_size);
    serializedBoc = serializedBoc.slice(tot_cells_size);
    if (hash_crc32) {
        if (serializedBoc.length < 4) throw "Not enough bytes for crc32c hashsum";
        const length = inputData.length;
        if (!compareBytes(crc32c(inputData.slice(0, length - 4)), serializedBoc.slice(0, 4))) throw "Crc32c hashsum mismatch";
        serializedBoc = serializedBoc.slice(4);
    }
    if (serializedBoc.length) throw "Too much bytes in BoC serialization";
    return {
        has_idx: has_idx,
        hash_crc32: hash_crc32,
        has_cache_bits: has_cache_bits,
        flags: flags,
        size_bytes: size_bytes,
        off_bytes: offset_bytes,
        cells_num: cells_num,
        roots_num: roots_num,
        absent_num: absent_num,
        tot_cells_size: tot_cells_size,
        root_list: root_list,
        index: index,
        cells_data: cells_data
    };
}
function deserializeCellData(cellData, referenceIndexSize) {
    if (cellData.length < 2) throw "Not enough bytes to encode cell descriptors";
    const d1 = cellData[0], d2 = cellData[1];
    cellData = cellData.slice(2);
    const level = Math.floor(d1 / 32);
    const isExotic = d1 & 8;
    const refNum = d1 % 8;
    const dataBytesize = Math.ceil(d2 / 2);
    const fullfilledBytes = !(d2 % 2);
    let cell = new Cell();
    cell.isExotic = isExotic;
    if (cellData.length < dataBytesize + referenceIndexSize * refNum) throw "Not enough bytes to encode cell data";
    cell.bits.setTopUppedArray(cellData.slice(0, dataBytesize), fullfilledBytes);
    cellData = cellData.slice(dataBytesize);
    for(let r = 0; r < refNum; r++){
        cell.refs.push(readNBytesUIntFromArray(referenceIndexSize, cellData));
        cellData = cellData.slice(referenceIndexSize);
    }
    return {
        cell: cell,
        residue: cellData
    };
}
/**
 * @param serializedBoc  {string | Uint8Array} hex or bytearray
 * @return {Cell[]} root cells
 */ function deserializeBoc(serializedBoc) {
    if (typeof serializedBoc == "string") serializedBoc = hexToBytes(serializedBoc);
    const header = parseBocHeader(serializedBoc);
    let cells_data = header.cells_data;
    let cells_array = [];
    for(let ci = 0; ci < header.cells_num; ci++){
        let dd = deserializeCellData(cells_data, header.size_bytes);
        cells_data = dd.residue;
        cells_array.push(dd.cell);
    }
    for(let ci1 = header.cells_num - 1; ci1 >= 0; ci1--){
        let c = cells_array[ci1];
        for(let ri = 0; ri < c.refs.length; ri++){
            const r = c.refs[ri];
            if (r < ci1) throw "Topological order is broken";
            c.refs[ri] = cells_array[r];
        }
    }
    let root_cells = [];
    for (let ri of header.root_list)root_cells.push(cells_array[ri]);
    return root_cells;
}
module.exports = {
    Cell
};

},{"./BitString":"kWQHd","../utils":"57M1Z"}],"aM11n":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
const { Cell  } = require("../boc");
const { Address , BN , bytesToHex  } = require("../utils");
const { Contract  } = require("../contract");
class AppTon {
    /**
     * @param transport {Transport} @ledgerhq/hw-transport
     * @param ton   {TonWeb}
     */ constructor(transport, ton){
        this.transport = transport;
        this.ton = ton;
        this.ADDRESS_FORMAT_HEX = 0;
        this.ADDRESS_FORMAT_USER_FRIENDLY = 1;
        this.ADDRESS_FORMAT_URL_SAFE = 2;
        this.ADDRESS_FORMAT_BOUNCEABLE = 4;
        this.ADDRESS_FORMAT_TEST_ONLY = 8;
    // todo: —É–∑–Ω–∞—Ç—å –∑–∞—á–µ–º –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è decorateAppAPIMethods
    // const scrambleKey = "w0w";
    // transport.decorateAppAPIMethods(
    //     this,
    //     [
    //         "getAppConfiguration",
    //         "getAddress",
    //         "sign",
    //         "signTransfer",
    //     ],
    //     scrambleKey
    // );
    }
    /***
     * Get App version
     * @return {{version: string}}
     */ async getAppConfiguration() {
        const response = await this.transport.send(0xe0, 0x01, 0x00, 0x00);
        return {
            version: "" + response[0] + "." + response[1] + "." + response[2] // major version, minor version, patch version
        };
    }
    /**
     * This command returns a public key for the given account number
     * @param accountNumber {number}
     * @param isDisplay {boolean} display public key and confirm before returning
     * @return {{publicKey: Uint8Array}}
     */ async getPublicKey(accountNumber, isDisplay) {
        const buffer = Buffer.alloc(4);
        buffer.writeInt32BE(accountNumber);
        const response = await this.transport.send(0xe0, 0x02, isDisplay ? 0x01 : 0x00, 0x00, buffer);
        const len = response[0];
        const publicKey = new Uint8Array(response.slice(1, 1 + len));
        return {
            publicKey
        };
    }
    /**
     * This command returns a wallet v3R1 address for the given account number
     * @param accountNumber {number}
     * @param isDisplay {boolean} display address and confirm before returning
     * @param addressFormat {number} display address format (use sum of ADDRESS_FORMAT_ constants)
     * @return {{address: Address}}
     */ async getAddress(accountNumber, isDisplay, addressFormat) {
        const buffer = Buffer.alloc(4);
        buffer.writeInt32BE(accountNumber);
        const response = await this.transport.send(0xe0, 0x05, isDisplay ? 0x01 : 0x00, addressFormat, buffer);
        const len = response[0];
        const addressHex = new Uint8Array(response.slice(1, 1 + len));
        const address = new Address("0:" + bytesToHex(addressHex));
        return {
            address
        };
    }
    /**
     * Sign a bytes
     * @param accountNumber {number}
     * @param buffer    {Buffer}
     * @return {{signature: Buffer}}
     */ async sign(accountNumber, buffer) {
        const accountNumberBuffer = Buffer.alloc(4);
        accountNumberBuffer.writeInt32BE(accountNumber);
        const signBuffer = Buffer.concat([
            accountNumberBuffer,
            Buffer.from(buffer)
        ]);
        const response = await this.transport.send(0xe0, 0x03, 0x00, 0x00, signBuffer);
        const len = response[0];
        const signature = response.slice(1, 1 + len);
        return {
            signature
        };
    }
    /**
     * Sign a transfer coins message (same with TonWeb.WalletContract.createTransferMessage)
     * if seqno === 0 it will be deploy wallet + transfer coins message
     * @param accountNumber {number}
     * @param wallet {WalletContract}  Sender wallet
     * @param toAddress {String | Address}  Destination address in any format
     * @param amount    {BN | number}  Transfer value in nanograms
     * @param seqno {number}
     * @param addressFormat {number} display address format (use sum of ADDRESS_FORMAT_ constants)
     * @return
     */ async transfer(accountNumber, wallet, toAddress, amount, seqno, addressFormat) {
        const sendMode = 3;
        const query = await wallet.createTransferMessage(null, toAddress, amount, seqno, null, sendMode, true);
        const accountNumberBuffer = Buffer.alloc(4);
        accountNumberBuffer.writeInt32BE(accountNumber);
        const msgBuffer = Buffer.concat([
            accountNumberBuffer,
            Buffer.from(await query.signingMessage.toBoc())
        ]);
        const response = await this.transport.send(0xe0, 0x04, addressFormat, 0x00, msgBuffer);
        const len = response[0];
        const signatureBuffer = response.slice(1, 1 + len);
        const signature = new Uint8Array(signatureBuffer);
        const body = new Cell();
        body.bits.writeBytes(signature);
        body.writeCell(query.signingMessage);
        let stateInit = null, code = null, data = null;
        if (seqno === 0) {
            const deploy = await wallet.createStateInit();
            stateInit = deploy.stateInit;
            code = deploy.code;
            data = deploy.data;
        }
        const selfAddress = await wallet.getAddress();
        const header = Contract.createExternalMessageHeader(selfAddress);
        const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);
        const resultPromise = new Promise((resolve)=>{
            resolve({
                address: selfAddress,
                message: resultMessage,
                body: body,
                signature: signature,
                signingMessage: query.signingMessage,
                stateInit,
                code,
                data
            });
        });
        return Contract.createMethod(this.ton.provider, resultPromise);
    }
}
module.exports = AppTon;

},{"buffer":"fCgem","../boc":"4fqdK","../utils":"57M1Z","../contract":"drIoA"}],"drIoA":[function(require,module,exports) {
const { Cell  } = require("../boc");
const { Address , bytesToBase64 , bytesToHex  } = require("../utils");
class Contract {
    /**
     * @param provider    {HttpProvider}
     * @param options    {{code?: Cell, address?: Address | string, wc?: number}}
     */ constructor(provider, options){
        this.provider = provider;
        this.options = options;
        this.address = options.address ? new Address(options.address) : null;
        if (!options.wc) options.wc = this.address ? this.address.wc : 0;
        this.methods = {};
    }
    /**
     * @return {Promise<Address>}
     */ async getAddress() {
        if (!this.address) this.address = (await this.createStateInit()).address;
        return this.address;
    }
    /**
     * @private
     * @return {Cell} cell contains contact code
     */ createCodeCell() {
        if (!this.options.code) throw new Error("Contract: options.code is not defined");
        return this.options.code;
    }
    /**
     * Method to override
     * @protected
     * @return {Cell} cell contains contract data
     */ createDataCell() {
        return new Cell();
    }
    /**
     * @protected
     * @return {Promise<{stateInit: Cell, address: Address, code: Cell, data: Cell}>}
     */ async createStateInit() {
        const codeCell = this.createCodeCell();
        const dataCell = this.createDataCell();
        const stateInit = Contract.createStateInit(codeCell, dataCell);
        const stateInitHash = await stateInit.hash();
        const address = new Address(this.options.wc + ":" + bytesToHex(stateInitHash));
        return {
            stateInit: stateInit,
            address: address,
            code: codeCell,
            data: dataCell
        };
    }
    // _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    // code:(Maybe ^Cell) data:(Maybe ^Cell)
    // library:(Maybe ^Cell) = StateInit;
    /**
     * @param code  {Cell}
     * @param data  {Cell}
     * @param library {null}
     * @param splitDepth {null}
     * @param ticktock  {null}
     * @return {Cell}
     */ static createStateInit(code, data, library = null, splitDepth = null, ticktock = null) {
        if (library) throw "Library in state init is not implemented";
        if (splitDepth) throw "Split depth in state init is not implemented";
        if (ticktock) throw "Ticktock in state init is not implemented";
        const stateInit = new Cell();
        stateInit.bits.writeBitArray([
            Boolean(splitDepth),
            Boolean(ticktock),
            Boolean(code),
            Boolean(data),
            Boolean(library)
        ]);
        if (code) stateInit.refs.push(code);
        if (data) stateInit.refs.push(data);
        if (library) stateInit.refs.push(library);
        return stateInit;
    }
    // extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))
    // = ExtraCurrencyCollection;
    // currencies$_ grams:Grams other:ExtraCurrencyCollection
    // = CurrencyCollection;
    //int_msg_info$0 ihr_disabled:Bool bounce:Bool
    //src:MsgAddressInt dest:MsgAddressInt
    //value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    //created_lt:uint64 created_at:uint32 = CommonMsgInfo;
    /**
     * @param dest  {Address | string}
     * @param gramValue  {number | BN}
     * @param ihrDisabled  {boolean}
     * @param bounce  {null | boolean}
     * @param bounced {boolean}
     * @param src  {Address | string}
     * @param currencyCollection  {null}
     * @param ihrFees  {number | BN}
     * @param fwdFees  {number | BN}
     * @param createdLt  {number | BN}
     * @param createdAt  {number | BN}
     * @return {Cell}
     */ static createInternalMessageHeader(dest, gramValue = 0, ihrDisabled = true, bounce = null, bounced = false, src = null, currencyCollection = null, ihrFees = 0, fwdFees = 0, createdLt = 0, createdAt = 0) {
        const message = new Cell();
        message.bits.writeBit(false);
        message.bits.writeBit(ihrDisabled);
        if (!(bounce === null)) message.bits.writeBit(bounce);
        else message.bits.writeBit(new Address(dest).isBounceable);
        message.bits.writeBit(bounced);
        message.bits.writeAddress(src ? new Address(src) : null);
        message.bits.writeAddress(new Address(dest));
        message.bits.writeGrams(gramValue);
        if (currencyCollection) throw "Currency collections are not implemented yet";
        message.bits.writeBit(Boolean(currencyCollection));
        message.bits.writeGrams(ihrFees);
        message.bits.writeGrams(fwdFees);
        message.bits.writeUint(createdLt, 64);
        message.bits.writeUint(createdAt, 32);
        return message;
    }
    //ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt
    //import_fee:Grams = CommonMsgInfo;
    /**
     * @param dest  {Address | string}
     * @param src  {Address | string}
     * @param importFee  {number | BN}
     * @return {Cell}
     */ static createExternalMessageHeader(dest, src = null, importFee = 0) {
        const message = new Cell();
        message.bits.writeUint(2, 2);
        message.bits.writeAddress(src ? new Address(src) : null);
        message.bits.writeAddress(new Address(dest));
        message.bits.writeGrams(importFee);
        return message;
    }
    //tblkch.pdf, page 57
    /**
     * Create CommonMsgInfo contains header, stateInit, body
     * @param header {Cell}
     * @param stateInit?  {Cell}
     * @param body?  {Cell}
     * @return {Cell}
     */ static createCommonMsgInfo(header, stateInit = null, body = null) {
        const commonMsgInfo = new Cell();
        commonMsgInfo.writeCell(header);
        if (stateInit) {
            commonMsgInfo.bits.writeBit(true);
            //-1:  need at least one bit for body
            // TODO we also should check for free refs here
            if (commonMsgInfo.bits.getFreeBits() - 1 >= stateInit.bits.getUsedBits()) {
                commonMsgInfo.bits.writeBit(false);
                commonMsgInfo.writeCell(stateInit);
            } else {
                commonMsgInfo.bits.writeBit(true);
                commonMsgInfo.refs.push(stateInit);
            }
        } else commonMsgInfo.bits.writeBit(false);
        // TODO we also should check for free refs here
        if (body) {
            if (commonMsgInfo.bits.getFreeBits() >= body.bits.getUsedBits()) {
                commonMsgInfo.bits.writeBit(false);
                commonMsgInfo.writeCell(body);
            } else {
                commonMsgInfo.bits.writeBit(true);
                commonMsgInfo.refs.push(body);
            }
        } else commonMsgInfo.bits.writeBit(false);
        return commonMsgInfo;
    }
    static createMethod(provider, queryPromise) {
        return {
            getQuery: async ()=>{
                return (await queryPromise).message;
            },
            send: async ()=>{
                const query = await queryPromise;
                const boc = bytesToBase64(await query.message.toBoc(false));
                return provider.sendBoc(boc);
            },
            estimateFee: async ()=>{
                const query = await queryPromise;
                const serialized = query.code ? {
                    address: query.address.toString(true, true, false),
                    body: bytesToBase64(await query.body.toBoc(false)),
                    init_code: bytesToBase64(await query.code.toBoc(false)),
                    init_data: bytesToBase64(await query.data.toBoc(false))
                } : {
                    address: query.address.toString(true, true, true),
                    body: bytesToBase64(await query.body.toBoc(false))
                };
                return provider.getEstimateFee(serialized);
            }
        };
    }
}
module.exports = {
    Contract
};

},{"../boc":"4fqdK","../utils":"57M1Z"}],"lMDUL":[function(require,module,exports) {
const HttpProviderUtils = require("./HttpProviderUtils").default;
if (typeof fetch === "undefined") fetch = require("node-fetch");
const SHARD_ID_ALL = "-9223372036854775808"; // 0x8000000000000000
class HttpProvider {
    /**
     * @param host? {string}
     * @param options? {{apiKey: string}}
     */ constructor(host, options){
        this.host = host || "https://toncenter.com/api/v2/jsonRPC";
        this.options = options || {};
    }
    /**
     * @private
     * @param apiUrl   {string}
     * @param request   {any}
     * @return {Promise<any>}
     */ sendImpl(apiUrl, request) {
        const headers = {
            "Content-Type": "application/json"
        };
        if (this.options.apiKey) headers["X-API-Key"] = this.options.apiKey;
        return fetch(apiUrl, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(request)
        }).then((response)=>response.json()).then(({ result , error  })=>result || Promise.reject(error));
    }
    /**
     * @param method    {string}
     * @param params    {any}  todo: Array<any>
     * @return {Promise<any>}
     */ send(method, params) {
        return this.sendImpl(this.host, {
            id: 1,
            jsonrpc: "2.0",
            method: method,
            params: params
        });
    }
    /**
     * Use this method to get information about address: balance, code, data, last_transaction_id.
     * @param address {string}
     */ async getAddressInfo(address) {
        return this.send("getAddressInformation", {
            address: address
        });
    }
    /**
     * Similar to previous one but tries to parse additional information for known contract types. This method is based on generic.getAccountState thus number of recognizable contracts may grow. For wallets we recommend to use getWalletInformation.
     * @param address {string}
     */ async getExtendedAddressInfo(address) {
        return this.send("getExtendedAddressInformation", {
            address: address
        });
    }
    /**
     * Use this method to retrieve wallet information, this method parse contract state and currently supports more wallet types than getExtendedAddressInformation: simple wallet, stadart wallet and v3 wallet.
     * @param address {string}
     */ async getWalletInfo(address) {
        return this.send("getWalletInformation", {
            address: address
        });
    }
    /**
     * Use this method to get transaction history of a given address.
     * @param address   {string}
     * @param limit?    {number}
     * @param lt?    {number}
     * @param hash?    {string}
     * @param to_lt?    {number}
     * @return array of transaction object
     */ async getTransactions(address, limit = 20, lt, hash, to_lt, archival) {
        return this.send("getTransactions", {
            address,
            limit,
            lt,
            hash,
            to_lt,
            archival
        });
    }
    /**
     * Use this method to get balance (in nanograms) of a given address.
     * @param address {string}
     */ async getBalance(address) {
        return this.send("getAddressBalance", {
            address: address
        });
    }
    /**
     * Use this method to send serialized boc file: fully packed and serialized external message.
     * @param base64 {string} base64 of boc bytes Cell.toBoc
     */ async sendBoc(base64) {
        return this.send("sendBoc", {
            "boc": base64
        });
    }
    /**
     * @deprecated
     * Send external message
     * @param query     object as described https://toncenter.com/api/test/v2/#sendQuerySimple
     */ async sendQuery(query) {
        return this.send("sendQuerySimple", query);
    }
    /**
     * @param query     object as described https://toncenter.com/api/test/v2/#estimateFee
     * @return fees object
     */ async getEstimateFee(query) {
        return this.send("estimateFee", query);
    }
    /**
     * Invoke get-method of smart contract
     * todo: think about throw error if result.exit_code !== 0 (the change breaks backward compatibility)
     * @param address   {string}    contract address
     * @param method   {string | number}        method name or method id
     * @param params?   Array of stack elements: [['num',3], ['cell', cell_object], ['slice', slice_object]]
     */ async call(address, method, params = []) {
        return this.send("runGetMethod", {
            address: address,
            method: method,
            stack: params
        });
    }
    /**
     * Invoke get-method of smart contract
     * @param address   {string}    contract address
     * @param method   {string | number}        method name or method id
     * @param params?   Array of stack elements: [['num',3], ['cell', cell_object], ['slice', slice_object]]
     */ async call2(address, method, params = []) {
        const result = await this.send("runGetMethod", {
            address: address,
            method: method,
            stack: params
        });
        return HttpProviderUtils.parseResponse(result);
    }
    /**
     * Returns ID's of last and init block of masterchain
     */ async getMasterchainInfo() {
        return this.send("getMasterchainInfo", {});
    }
    /**
     * Returns ID's of shardchain blocks included in this masterchain block
     * @param masterchainBlockNumber {number}
     */ async getBlockShards(masterchainBlockNumber) {
        return this.send("shards", {
            seqno: masterchainBlockNumber
        });
    }
    /**
     * Returns transactions hashes included in this block
     * @param workchain {number}
     * @param shardId   {string}
     * @param shardBlockNumber  {number}
     */ async getBlockTransactions(workchain, shardId, shardBlockNumber) {
        return this.send("getBlockTransactions", {
            workchain: workchain,
            shard: shardId,
            seqno: shardBlockNumber
        });
    }
    /**
     * Returns transactions hashes included in this masterhcain block
     * @param masterchainBlockNumber  {number}
     */ async getMasterchainBlockTransactions(masterchainBlockNumber) {
        return this.getBlockTransactions(-1, SHARD_ID_ALL, masterchainBlockNumber);
    }
    /**
     * Returns block header and his previous blocks ID's
     * @param workchain {number}
     * @param shardId   {string}
     * @param shardBlockNumber  {number}
     */ async getBlockHeader(workchain, shardId, shardBlockNumber) {
        return this.send("getBlockHeader", {
            workchain: workchain,
            shard: shardId,
            seqno: shardBlockNumber
        });
    }
    /**
     * Returns masterchain block header and his previous block ID
     * @param masterchainBlockNumber  {number}
     */ async getMasterchainBlockHeader(masterchainBlockNumber) {
        return this.getBlockHeader(-1, SHARD_ID_ALL, masterchainBlockNumber);
    }
}
HttpProvider.SHARD_ID_ALL = SHARD_ID_ALL;
module.exports.default = HttpProvider;

},{"./HttpProviderUtils":"jDmwF","node-fetch":"jhUEF"}],"jDmwF":[function(require,module,exports) {
const { BN , base64ToBytes  } = require("../utils");
const { Cell  } = require("../boc");
class HttpProviderUtils {
    static parseObject(x) {
        const typeName = x["@type"];
        switch(typeName){
            case "tvm.list":
            case "tvm.tuple":
                return x.elements.map(HttpProviderUtils.parseObject);
            case "tvm.cell":
                return Cell.oneFromBoc(base64ToBytes(x.bytes));
            case "tvm.stackEntryCell":
                return HttpProviderUtils.parseObject(x.cell);
            case "tvm.stackEntryTuple":
                return HttpProviderUtils.parseObject(x.tuple);
            case "tvm.stackEntryNumber":
                return HttpProviderUtils.parseObject(x.number);
            case "tvm.numberDecimal":
                return new BN(x.number, 10);
            default:
                throw new Error("unknown type " + typeName);
        }
    }
    /**
     * @param pair  {any[]}
     * @return {any}
     */ static parseResponseStack(pair) {
        const typeName = pair[0];
        const value = pair[1];
        switch(typeName){
            case "num":
                return new BN(value.replace(/0x/, ""), 16);
            case "list":
            case "tuple":
                return HttpProviderUtils.parseObject(value);
            case "cell":
                const contentBytes = base64ToBytes(value.bytes);
                return Cell.oneFromBoc(contentBytes);
            default:
                throw new Error("unknown type " + typeName);
        }
    }
    static parseResponse(result) {
        if (result.exit_code !== 0) {
            const err = new Error("http provider parse response error");
            err.result = result;
            throw err;
        }
        const arr = result.stack.map(HttpProviderUtils.parseResponseStack);
        return arr.length === 1 ? arr[0] : arr;
    }
    static makeArg(arg) {
        if (arg instanceof BN || arg instanceof Number) return [
            "num",
            arg
        ];
        else throw new Error("unknown arg type " + arg);
    }
    static makeArgs(args) {
        return args.map(this.makeArg);
    }
}
module.exports.default = HttpProviderUtils;

},{"../utils":"57M1Z","../boc":"4fqdK"}],"h00EC":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { Address , BN , toNano , bytesToHex , hexToBytes , nacl , stringToBytes , bytesToBase64  } = require("../../utils");
const { Contract  } = require("../index.js");
const { SimpleWalletContractR1 , SimpleWalletContractR2 , SimpleWalletContractR3  } = require("./WalletContractSimple");
const { WalletV2ContractR1 , WalletV2ContractR2  } = require("./WalletContractV2");
const { WalletV3ContractR1 , WalletV3ContractR2  } = require("./WalletContractV3");
const { WalletV4ContractR1  } = require("./WalletContractV4");
const { WalletV4ContractR2  } = require("./WalletContractV4R2");
const ALL = {
    "simpleR1": SimpleWalletContractR1,
    "simpleR2": SimpleWalletContractR2,
    "simpleR3": SimpleWalletContractR3,
    "v2R1": WalletV2ContractR1,
    "v2R2": WalletV2ContractR2,
    "v3R1": WalletV3ContractR1,
    "v3R2": WalletV3ContractR2,
    "v4R1": WalletV4ContractR1,
    "v4R2": WalletV4ContractR2
};
const LIST = [
    SimpleWalletContractR1,
    SimpleWalletContractR2,
    SimpleWalletContractR3,
    WalletV2ContractR1,
    WalletV2ContractR2,
    WalletV3ContractR1,
    WalletV3ContractR2,
    WalletV4ContractR1,
    WalletV4ContractR2
];
class Wallets {
    /**
     * @param provider    {HttpProvider}
     */ constructor(provider){
        this.provider = provider;
        this.all = ALL;
        this.list = LIST;
        this.defaultVersion = "v3R1";
        this.default = this.all[this.defaultVersion];
    }
    create(options) {
        return new this.default(this.provider, options);
    }
}
Wallets.all = ALL;
Wallets.list = LIST;
module.exports.default = Wallets;

},{"../../boc":"4fqdK","../../utils":"57M1Z","../index.js":"drIoA","./WalletContractSimple":"aJS8N","./WalletContractV2":"2JYwm","./WalletContractV3":"85xar","./WalletContractV4":"KwK9c","./WalletContractV4R2":"eBbEg"}],"aJS8N":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { WalletContract  } = require("./WalletContract");
// attention: no seqno get-method in this wallet
class SimpleWalletContractR1 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options? {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C72410101010044000084FF0020DDA4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED5441FDF089");
        super(provider, options);
    }
    getName() {
        return "simpleR1";
    }
}
class SimpleWalletContractR2 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options? {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C724101010100530000A2FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54D0E2786F");
        super(provider, options);
    }
    getName() {
        return "simpleR2";
    }
}
class SimpleWalletContractR3 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options? {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C7241010101005F0000BAFF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F260810200D71820D70B1FED44D0D31FD3FFD15112BAF2A122F901541044F910F2A2F80001D31F3120D74A96D307D402FB00DED1A4C8CB1FCBFFC9ED54B5B86E42");
        super(provider, options);
    }
    getName() {
        return "simpleR3";
    }
}
module.exports = {
    SimpleWalletContractR1,
    SimpleWalletContractR2,
    SimpleWalletContractR3
};

},{"../../boc":"4fqdK","./WalletContract":"aWdv6"}],"aWdv6":[function(require,module,exports) {
const { Contract  } = require("../index.js");
const { Cell  } = require("../../boc");
const { nacl , stringToBytes , Address , BN  } = require("../../utils");
/**
 * Abstract standard wallet class
 */ class WalletContract extends Contract {
    /**
     * @param provider    {HttpProvider}
     * @param options?    {{code: Uint8Array, publicKey?: Uint8Array, address?: Address | string, wc?: number}}
     */ constructor(provider, options){
        if (!options.publicKey && !options.address) throw new Error("WalletContract required publicKey or address in options");
        super(provider, options);
        this.methods = {
            /**
             * @param   params {{secretKey: Uint8Array, toAddress: Address | string, amount: BN | number, seqno: number, payload: string | Uint8Array | Cell, sendMode: number, stateInit?: Cell}}
             */ transfer: (params)=>Contract.createMethod(provider, this.createTransferMessage(params.secretKey, params.toAddress, params.amount, params.seqno, params.payload, params.sendMode, !Boolean(params.secretKey), params.stateInit)),
            seqno: ()=>{
                return {
                    /**
                     * @return {Promise<number>}
                     */ call: async ()=>{
                        const address = await this.getAddress();
                        let n = null;
                        try {
                            n = (await provider.call2(address.toString(), "seqno")).toNumber();
                        } catch (e) {}
                        return n;
                    }
                };
            }
        };
        /**
         * @param secretKey {Uint8Array}
         */ this.deploy = (secretKey)=>Contract.createMethod(provider, this.createInitExternalMessage(secretKey));
    }
    getName() {
        throw new Error("override me");
    }
    /**
     * @override
     * @protected
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        // 4 byte seqno, 32 byte publicKey
        const cell = new Cell();
        cell.bits.writeUint(0, 32); // seqno
        cell.bits.writeBytes(this.options.publicKey);
        return cell;
    }
    /**
     * @protected
     * @param   seqno?   {number}
     * @return {Cell}
     */ createSigningMessage(seqno) {
        seqno = seqno || 0;
        const cell = new Cell();
        cell.bits.writeUint(seqno, 32);
        return cell;
    }
    /**
     * External message for initialization
     * @param secretKey  {Uint8Array} nacl.KeyPair.secretKey
     * @return {{address: Address, message: Cell, body: Cell, sateInit: Cell, code: Cell, data: Cell}}
     */ async createInitExternalMessage(secretKey) {
        if (!this.options.publicKey) {
            const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);
            this.options.publicKey = keyPair.publicKey;
        }
        const { stateInit , address , code , data  } = await this.createStateInit();
        const signingMessage = this.createSigningMessage();
        const signature = nacl.sign.detached(await signingMessage.hash(), secretKey);
        const body = new Cell();
        body.bits.writeBytes(signature);
        body.writeCell(signingMessage);
        const header = Contract.createExternalMessageHeader(address);
        const externalMessage = Contract.createCommonMsgInfo(header, stateInit, body);
        return {
            address: address,
            message: externalMessage,
            body,
            signingMessage,
            stateInit,
            code,
            data
        };
    }
    /**
     * @protected
     * @param signingMessage {Cell}
     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey
     * @param seqno {number}
     * @param dummySignature?    {boolean}
     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}
     */ async createExternalMessage(signingMessage, secretKey, seqno, dummySignature = false) {
        const signature = dummySignature ? new Uint8Array(64) : nacl.sign.detached(await signingMessage.hash(), secretKey);
        const body = new Cell();
        body.bits.writeBytes(signature);
        body.writeCell(signingMessage);
        let stateInit = null, code = null, data = null;
        if (seqno === 0) {
            if (!this.options.publicKey) {
                const keyPair = nacl.sign.keyPair.fromSecretKey(secretKey);
                this.options.publicKey = keyPair.publicKey;
            }
            const deploy = await this.createStateInit();
            stateInit = deploy.stateInit;
            code = deploy.code;
            data = deploy.data;
        }
        const selfAddress = await this.getAddress();
        const header = Contract.createExternalMessageHeader(selfAddress);
        const resultMessage = Contract.createCommonMsgInfo(header, stateInit, body);
        return {
            address: selfAddress,
            message: resultMessage,
            body: body,
            signature: signature,
            signingMessage: signingMessage,
            stateInit,
            code,
            data
        };
    }
    /**
     * @param secretKey {Uint8Array}  nacl.KeyPair.secretKey
     * @param address   {Address | string}
     * @param amount    {BN | number} in nanograms
     * @param seqno {number}
     * @param payload?   {string | Uint8Array | Cell}
     * @param sendMode?  {number}
     * @param dummySignature?    {boolean}
     * @param stateInit? {Cell}
     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}
     */ async createTransferMessage(secretKey, address, amount, seqno, payload = "", sendMode = 3, dummySignature = false, stateInit = null) {
        let payloadCell = new Cell();
        if (payload) {
            if (payload.refs) payloadCell = payload;
            else if (typeof payload === "string") {
                if (payload.length > 0) {
                    payloadCell.bits.writeUint(0, 32);
                    payloadCell.bits.writeString(payload);
                }
            } else payloadCell.bits.writeBytes(payload);
        }
        const orderHeader = Contract.createInternalMessageHeader(new Address(address), new BN(amount));
        const order = Contract.createCommonMsgInfo(orderHeader, stateInit, payloadCell);
        const signingMessage = this.createSigningMessage(seqno);
        signingMessage.bits.writeUint8(sendMode);
        signingMessage.refs.push(order);
        return this.createExternalMessage(signingMessage, secretKey, seqno, dummySignature);
    }
}
module.exports = {
    WalletContract
};

},{"../index.js":"drIoA","../../boc":"4fqdK","../../utils":"57M1Z"}],"2JYwm":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { WalletContract  } = require("./WalletContract");
class WalletV2ContractBase extends WalletContract {
    /**
     * @override
     * @private
     * @param   seqno?   {number}
     * @return {Cell}
     */ createSigningMessage(seqno) {
        seqno = seqno || 0;
        const message = new Cell();
        message.bits.writeUint(seqno, 32);
        if (seqno === 0) // message.bits.writeInt(-1, 32);// todo: dont work
        for(let i = 0; i < 32; i++)message.bits.writeBit(1);
        else {
            const date = new Date();
            const timestamp = Math.floor(date.getTime() / 1e3);
            message.bits.writeUint(timestamp + 60, 32);
        }
        return message;
    }
}
class WalletV2ContractR1 extends WalletV2ContractBase {
    /**
     * @param provider    {HttpProvider}
     * @param options? {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C724101010100570000AAFF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54A1370BB6");
        super(provider, options);
    }
    getName() {
        return "v2R1";
    }
}
class WalletV2ContractR2 extends WalletV2ContractBase {
    /**
     * @param provider    {HttpProvider}
     * @param options? {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C724101010100630000C2FF0020DD2082014C97BA218201339CBAB19C71B0ED44D0D31FD70BFFE304E0A4F2608308D71820D31FD31F01F823BBF263ED44D0D31FD3FFD15131BAF2A103F901541042F910F2A2F800029320D74A96D307D402FB00E8D1A4C8CB1FCBFFC9ED54044CD7A1");
        super(provider, options);
    }
    getName() {
        return "v2R2";
    }
}
module.exports = {
    WalletV2ContractR1,
    WalletV2ContractR2
};

},{"../../boc":"4fqdK","./WalletContract":"aWdv6"}],"85xar":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { WalletContract  } = require("./WalletContract");
class WalletV3ContractBase extends WalletContract {
    /**
     * @override
     * @private
     * @param   seqno?   {number}
     * @return {Cell}
     */ createSigningMessage(seqno) {
        seqno = seqno || 0;
        const message = new Cell();
        message.bits.writeUint(this.options.walletId, 32);
        if (seqno === 0) // message.bits.writeInt(-1, 32);// todo: dont work
        for(let i = 0; i < 32; i++)message.bits.writeBit(1);
        else {
            const date = new Date();
            const timestamp = Math.floor(date.getTime() / 1e3);
            message.bits.writeUint(timestamp + 60, 32);
        }
        message.bits.writeUint(seqno, 32);
        return message;
    }
    /**
     * @override
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeUint(0, 32);
        cell.bits.writeUint(this.options.walletId, 32);
        cell.bits.writeBytes(this.options.publicKey);
        return cell;
    }
}
class WalletV3ContractR1 extends WalletV3ContractBase {
    /**
     * @param provider    {HttpProvider}
     * @param options {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C724101010100620000C0FF0020DD2082014C97BA9730ED44D0D70B1FE0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED543FBE6EE0");
        super(provider, options);
        if (!this.options.walletId) this.options.walletId = 698983191 + this.options.wc;
    }
    getName() {
        return "v3R1";
    }
}
class WalletV3ContractR2 extends WalletV3ContractBase {
    /**
     * @param provider    {HttpProvider}
     * @param options {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C724101010100710000DEFF0020DD2082014C97BA218201339CBAB19F71B0ED44D0D31FD31F31D70BFFE304E0A4F2608308D71820D31FD31FD31FF82313BBF263ED44D0D31FD31FD3FFD15132BAF2A15144BAF2A204F901541055F910F2A3F8009320D74A96D307D402FB00E8D101A4C8CB1FCB1FCBFFC9ED5410BD6DAD");
        super(provider, options);
        if (!this.options.walletId) this.options.walletId = 698983191 + this.options.wc;
    }
    getName() {
        return "v3R2";
    }
}
module.exports = {
    WalletV3ContractR1,
    WalletV3ContractR2
};

},{"../../boc":"4fqdK","./WalletContract":"aWdv6"}],"KwK9c":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { Contract  } = require("../index.js");
const { Address , bytesToHex , BN  } = require("../../utils");
const { WalletContract  } = require("./WalletContract");
class WalletV4ContractR1 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C72410215010002F5000114FF00F4A413F4BCF2C80B010201200203020148040504F8F28308D71820D31FD31FD31F02F823BBF263ED44D0D31FD31FD3FFF404D15143BAF2A15151BAF2A205F901541064F910F2A3F80024A4C8CB1F5240CB1F5230CBFF5210F400C9ED54F80F01D30721C0009F6C519320D74A96D307D402FB00E830E021C001E30021C002E30001C0039130E30D03A4C8CB1F12CB1FCBFF1112131403EED001D0D3030171B0915BE021D749C120915BE001D31F218210706C7567BD228210626C6E63BDB022821064737472BDB0925F03E002FA403020FA4401C8CA07CBFFC9D0ED44D0810140D721F404305C810108F40A6FA131B3925F05E004D33FC8258210706C7567BA9131E30D248210626C6E63BAE30004060708020120090A005001FA00F404308210706C7567831EB17080185005CB0527CF165003FA02F40012CB69CB1F5210CB3F0052F8276F228210626C6E63831EB17080185005CB0527CF1624FA0214CB6A13CB1F5230CB3F01FA02F4000092821064737472BA8E3504810108F45930ED44D0810140D720C801CF16F400C9ED54821064737472831EB17080185004CB0558CF1622FA0212CB6ACB1FCB3F9410345F04E2C98040FB000201200B0C0059BD242B6F6A2684080A06B90FA0218470D4080847A4937D29910CE6903E9FF9837812801B7810148987159F31840201580D0E0011B8C97ED44D0D70B1F8003DB29DFB513420405035C87D010C00B23281F2FFF274006040423D029BE84C600201200F100019ADCE76A26840206B90EB85FFC00019AF1DF6A26840106B90EB858FC0006ED207FA00D4D422F90005C8CA0715CBFFC9D077748018C8CB05CB0222CF165005FA0214CB6B12CCCCC971FB00C84014810108F451F2A702006C810108D718C8542025810108F451F2A782106E6F746570748018C8CB05CB025004CF16821005F5E100FA0213CB6A12CB1FC971FB00020072810108D718305202810108F459F2A7F82582106473747270748018C8CB05CB025005CF16821005F5E100FA0214CB6A13CB1F12CB3FC973FB00000AF400C9ED5446A9F34F");
        super(provider, options);
        if (!this.options.walletId) this.options.walletId = 698983191 + this.options.wc;
        this.methods.getPublicKey = this.getPublicKey.bind(this);
    }
    getName() {
        return "v4R1";
    }
    /**
     * @override
     * @private
     * @param   seqno?   {number}
     * @param   withoutOp? {boolean}
     * @return {Cell}
     */ createSigningMessage(seqno, withoutOp) {
        seqno = seqno || 0;
        const message = new Cell();
        message.bits.writeUint(this.options.walletId, 32);
        if (seqno === 0) // message.bits.writeInt(-1, 32);// todo: dont work
        for(let i = 0; i < 32; i++)message.bits.writeBit(1);
        else {
            const date = new Date();
            const timestamp = Math.floor(date.getTime() / 1e3);
            message.bits.writeUint(timestamp + 60, 32);
        }
        message.bits.writeUint(seqno, 32);
        if (!withoutOp) message.bits.writeUint(0, 8); // op
        return message;
    }
    /**
     * @override
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeUint(0, 32);
        cell.bits.writeUint(this.options.walletId, 32);
        cell.bits.writeBytes(this.options.publicKey);
        cell.bits.writeUint(0, 1); // plugins dict empty
        return cell;
    }
    /**
     * @return {Promise<BN>}
     */ async getPublicKey() {
        const myAddress = await this.getAddress();
        return this.provider.call2(myAddress.toString(), "get_public_key");
    }
}
module.exports = {
    WalletV4ContractR1
};

},{"../../boc":"4fqdK","../index.js":"drIoA","../../utils":"57M1Z","./WalletContract":"aWdv6"}],"eBbEg":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { Contract  } = require("../index.js");
const { Address , bytesToHex , BN , toNano  } = require("../../utils");
const { WalletContract  } = require("./WalletContract");
class WalletV4ContractR2 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options {any}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C72410214010002D4000114FF00F4A413F4BCF2C80B010201200203020148040504F8F28308D71820D31FD31FD31F02F823BBF264ED44D0D31FD31FD3FFF404D15143BAF2A15151BAF2A205F901541064F910F2A3F80024A4C8CB1F5240CB1F5230CBFF5210F400C9ED54F80F01D30721C0009F6C519320D74A96D307D402FB00E830E021C001E30021C002E30001C0039130E30D03A4C8CB1F12CB1FCBFF1011121302E6D001D0D3032171B0925F04E022D749C120925F04E002D31F218210706C7567BD22821064737472BDB0925F05E003FA403020FA4401C8CA07CBFFC9D0ED44D0810140D721F404305C810108F40A6FA131B3925F07E005D33FC8258210706C7567BA923830E30D03821064737472BA925F06E30D06070201200809007801FA00F40430F8276F2230500AA121BEF2E0508210706C7567831EB17080185004CB0526CF1658FA0219F400CB6917CB1F5260CB3F20C98040FB0006008A5004810108F45930ED44D0810140D720C801CF16F400C9ED540172B08E23821064737472831EB17080185005CB055003CF1623FA0213CB6ACB1FCB3FC98040FB00925F03E20201200A0B0059BD242B6F6A2684080A06B90FA0218470D4080847A4937D29910CE6903E9FF9837812801B7810148987159F31840201580C0D0011B8C97ED44D0D70B1F8003DB29DFB513420405035C87D010C00B23281F2FFF274006040423D029BE84C600201200E0F0019ADCE76A26840206B90EB85FFC00019AF1DF6A26840106B90EB858FC0006ED207FA00D4D422F90005C8CA0715CBFFC9D077748018C8CB05CB0222CF165005FA0214CB6B12CCCCC973FB00C84014810108F451F2A7020070810108D718FA00D33FC8542047810108F451F2A782106E6F746570748018C8CB05CB025006CF165004FA0214CB6A12CB1FCB3FC973FB0002006C810108D718FA00D33F305224810108F459F2A782106473747270748018C8CB05CB025005CF165003FA0213CB6ACB1F12CB3FC973FB00000AF400C9ED54696225E5");
        super(provider, options);
        if (!this.options.walletId) this.options.walletId = 698983191 + this.options.wc;
        this.methods.deployAndInstallPlugin = (params)=>Contract.createMethod(provider, this.deployAndInstallPlugin(params));
        this.methods.installPlugin = (params)=>Contract.createMethod(provider, this.installPlugin(params));
        this.methods.removePlugin = (params)=>Contract.createMethod(provider, this.removePlugin(params));
        this.methods.getPublicKey = this.getPublicKey.bind(this);
        this.methods.getWalletId = this.getWalletId.bind(this);
        this.methods.isPluginInstalled = this.isPluginInstalled.bind(this);
        this.methods.getPluginsList = this.getPluginsList.bind(this);
    }
    getName() {
        return "v4R2";
    }
    /**
     * @override
     * @private
     * @param   seqno?   {number}
     * @param   withoutOp? {boolean}
     * @return {Cell}
     */ createSigningMessage(seqno, withoutOp) {
        seqno = seqno || 0;
        const message = new Cell();
        message.bits.writeUint(this.options.walletId, 32);
        if (seqno === 0) // message.bits.writeInt(-1, 32);// todo: dont work
        for(let i = 0; i < 32; i++)message.bits.writeBit(1);
        else {
            const date = new Date();
            const timestamp = Math.floor(date.getTime() / 1e3);
            message.bits.writeUint(timestamp + 60, 32);
        }
        message.bits.writeUint(seqno, 32);
        if (!withoutOp) message.bits.writeUint(0, 8); // op
        return message;
    }
    /**
     * @override
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeUint(0, 32); // seqno
        cell.bits.writeUint(this.options.walletId, 32);
        cell.bits.writeBytes(this.options.publicKey);
        cell.bits.writeUint(0, 1); // plugins dict empty
        return cell;
    }
    /**
     * @param   params {{secretKey: Uint8Array, seqno: number, pluginWc: number, amount: BN, stateInit: Cell, body: Cell}}
     */ async deployAndInstallPlugin(params) {
        const { secretKey , seqno , pluginWc , amount , stateInit , body  } = params;
        const signingMessage = this.createSigningMessage(seqno, true);
        signingMessage.bits.writeUint(1, 8); // op
        signingMessage.bits.writeInt(pluginWc, 8);
        signingMessage.bits.writeGrams(amount);
        signingMessage.refs.push(stateInit);
        signingMessage.refs.push(body);
        return this.createExternalMessage(signingMessage, secretKey, seqno, false);
    }
    /**
     * @private
     * @param   params {{secretKey: Uint8Array, seqno: number, pluginAddress: string | Address, amount?: BN, queryId?: number}}
     * @param   isInstall {boolean} install or uninstall
     */ async _setPlugin(params, isInstall) {
        const { secretKey , seqno , amount , queryId  } = params;
        const pluginAddress = new Address(params.pluginAddress);
        const signingMessage = this.createSigningMessage(seqno, true);
        signingMessage.bits.writeUint(isInstall ? 2 : 3, 8); // op
        signingMessage.bits.writeInt(pluginAddress.wc, 8);
        signingMessage.bits.writeBytes(pluginAddress.hashPart);
        signingMessage.bits.writeGrams(amount || toNano("0.1"));
        signingMessage.bits.writeUint(queryId || 0, 64);
        return this.createExternalMessage(signingMessage, secretKey, seqno, false);
    }
    /**
     * @param   params {{secretKey: Uint8Array, seqno: number, pluginAddress: string | Address, amount?: BN, queryId?: number}}
     */ async installPlugin(params) {
        return this._setPlugin(params, true);
    }
    /**
     * @param   params {{secretKey: Uint8Array, seqno: number, pluginAddress: string | Address, amount?: BN, queryId?: number}}
     */ async removePlugin(params) {
        return this._setPlugin(params, false);
    }
    /**
     * @return {Promise<number>}
     */ async getWalletId() {
        const myAddress = await this.getAddress();
        const id = await this.provider.call2(myAddress.toString(), "get_subwallet_id");
        return id.toNumber();
    }
    /**
     * @return {Promise<BN>}
     */ async getPublicKey() {
        const myAddress = await this.getAddress();
        return this.provider.call2(myAddress.toString(), "get_public_key");
    }
    /**
     * @param pluginAddress {string | Address}
     * @return {Promise<boolean>}
     */ async isPluginInstalled(pluginAddress) {
        pluginAddress = new Address(pluginAddress);
        const hashPart = "0x" + bytesToHex(pluginAddress.hashPart);
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "is_plugin_installed", [
            [
                "num",
                pluginAddress.wc
            ],
            [
                "num",
                hashPart
            ]
        ]);
        return !result.isZero();
    }
    /**
     * @return {Promise<string[]>} plugins addresses
     */ async getPluginsList() {
        const parseAddress = (tuple)=>tuple[0].toNumber() + ":" + tuple[1].toString(16);
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_plugin_list");
        return result.map(parseAddress);
    }
}
module.exports = {
    WalletV4ContractR2
};

},{"../../boc":"4fqdK","../index.js":"drIoA","../../utils":"57M1Z","./WalletContract":"aWdv6"}],"5i9kN":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { Address , BN , toNano , bytesToHex , hexToBytes , nacl , stringToBytes , bytesToBase64 , base64ToBytes  } = require("../../utils");
const { Contract  } = require("../index.js");
const { WalletContract  } = require("../wallet/WalletContract");
const WALLET_ID_BASE = 698983191;
class LockupWalletV1 extends WalletContract {
    /**
     * @param provider    {HttpProvider}
     * @param options {{publicKey?: Uint8Array, address?: Address | string, wc?: number, config: any}}
     *
     * Config json is {config}
     */ constructor(provider, options){
        // options.config:
        // {
        //     wallet_type: "lockup-0.1",
        //     config_pubkey: <base64-encoded pubkey>,
        //     allowed_destinations: [ "addr1", "addr2", ... ]
        // }
        options.code = Cell.oneFromBoc("B5EE9C7241021E01000261000114FF00F4A413F4BCF2C80B010201200203020148040501F2F28308D71820D31FD31FD31F802403F823BB13F2F2F003802251A9BA1AF2F4802351B7BA1BF2F4801F0BF9015410C5F9101AF2F4F8005057F823F0065098F823F0062071289320D74A8E8BD30731D4511BDB3C12B001E8309229A0DF72FB02069320D74A96D307D402FB00E8D103A4476814154330F004ED541D0202CD0607020120131402012008090201200F100201200A0B002D5ED44D0D31FD31FD3FFD3FFF404FA00F404FA00F404D1803F7007434C0C05C6C2497C0F83E900C0871C02497C0F80074C7C87040A497C1383C00D46D3C00608420BABE7114AC2F6C2497C338200A208420BABE7106EE86BCBD20084AE0840EE6B2802FBCBD01E0C235C62008087E4055040DBE4404BCBD34C7E00A60840DCEAA7D04EE84BCBD34C034C7CC0078C3C412040DD78CA00C0D0E00130875D27D2A1BE95B0C60000C1039480AF00500161037410AF0050810575056001010244300F004ED540201201112004548E1E228020F4966FA520933023BB9131E2209835FA00D113A14013926C21E2B3E6308003502323287C5F287C572FFC4F2FFFD00007E80BD00007E80BD00326000431448A814C4E0083D039BE865BE803444E800A44C38B21400FE809004E0083D10C06002012015160015BDE9F780188242F847800C02012017180201481B1C002DB5187E006D88868A82609E00C6207E00C63F04EDE20B30020158191A0017ADCE76A268699F98EB85FFC00017AC78F6A268698F98EB858FC00011B325FB513435C2C7E00017B1D1BE08E0804230FB50F620002801D0D3030178B0925B7FE0FA4031FA403001F001A80EDAA4");
        super(provider, options);
        if (!this.options.walletId) this.options.walletId = WALLET_ID_BASE + this.options.wc;
        this.methods.getPublicKey = this.getPublicKey.bind(this);
        this.methods.getWalletId = this.getWalletId.bind(this);
        this.methods.getLiquidBalance = this.getLiquidBalance.bind(this);
        this.methods.getNominalRestrictedBalance = this.getNominalRestrictedBalance.bind(this);
        this.methods.getNominalLockedBalance = this.getNominalLockedBalance.bind(this);
    }
    getName() {
        return "lockup-0.1";
    }
    /**
     * @override
     * @private
     * @param   seqno?   {number}
     * @param   withoutOp? {boolean}
     * @return {Cell}
     */ createSigningMessage(seqno, withoutOp) {
        seqno = seqno || 0;
        const message = new Cell();
        message.bits.writeUint(this.options.walletId, 32);
        if (seqno === 0) // message.bits.writeInt(-1, 32);// todo: dont work
        for(let i = 0; i < 32; i++)message.bits.writeBit(1);
        else {
            const date = new Date();
            const timestamp = Math.floor(date.getTime() / 1e3);
            message.bits.writeUint(timestamp + 60, 32);
        }
        message.bits.writeUint(seqno, 32);
        return message;
    }
    /**
     * @override
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        // from restricted.fc:
        // .store_int(seqno, 32)
        // .store_int(subwallet_id, 32)
        // .store_uint(public_key, 256)
        // .store_uint(config_public_key, 256)
        // .store_dict(allowed_destinations)
        // .store_grams(total_locked_value)
        // .store_dict(locked)
        // .store_grams(total_restricted_value)
        // .store_dict(restricted).end_cell();
        const cell = new Cell();
        cell.bits.writeUint(0, 32); // seqno
        cell.bits.writeUint(this.options.walletId, 32);
        cell.bits.writeBytes(this.options.publicKey);
        // TODO: write config.config_public_key (need to sort out encoding - the params come in base64),
        // TODO: write the dict of allowed destinations (address is a key to an empty value).
        cell.bits.writeBytes(base64ToBytes(this.options.config.config_public_key));
        if (this.options.config.allowed_destinations) {
            cell.bits.writeUint(1, 1);
            cell.refs.push(Cell.oneFromBoc(base64ToBytes(this.options.config.allowed_destinations)));
        } else cell.bits.writeUint(0, 1);
        cell.bits.writeGrams(0); // .store_grams(total_locked_value)
        cell.bits.writeUint(0, 1); // empty locked dict
        cell.bits.writeGrams(0); // .store_grams(total_restricted_value)
        cell.bits.writeUint(0, 1); // empty locked dict
        return cell;
    }
    /**
     * @return {Promise<number>}
     */ async getWalletId() {
        const myAddress = await this.getAddress();
        const id = await this.provider.call2(myAddress.toString(), "get_subwallet_id");
        return id.toNumber();
    }
    /**
     * @return {Promise<BN>}
     */ async getPublicKey() {
        const myAddress = await this.getAddress();
        return this.provider.call2(myAddress.toString(), "get_public_key");
    }
    /**
     * @return {Promise<BN>} Amount of nanotoncoins that can be spent immediately.
     */ async getLiquidBalance() {
        const balances = await this.getBalances();
        return balances[0] - balances[1] - balances[2];
    }
    /**
     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock OR to the whitelisted addresses.
     */ async getNominalRestrictedBalance() {
        return await this.getBalances()[1];
    }
    /**
     * @return {Promise<BN>} Amount of nanotoncoins that can be spent after the timelock only (whitelisted addresses not used).
     */ async getNominalLockedBalance() {
        return await this.getBalances()[2];
    }
    /**
     * @return {Promise<[BN,BN,BN]>} Total amount of nanotoncoins on the contract,
     * nominal restricted value
     * nominal locked value
     */ async getBalances() {
        const myAddress = await this.getAddress();
        return this.provider.call2(myAddress.toString(), "get_balances");
    }
}
module.exports.default = {
    LockupWalletV1,
    all: {
        "lockup-0.1": LockupWalletV1
    },
    list: [
        LockupWalletV1
    ]
};

},{"../../boc":"4fqdK","../../utils":"57M1Z","../index.js":"drIoA","../wallet/WalletContract":"aWdv6"}],"8v2Xc":[function(require,module,exports) {
const { NftCollection  } = require("./NftCollection.js");
const { NftItem  } = require("./NftItem.js");
const { NftMarketplace  } = require("./NftMarketplace.js");
const { NftSale  } = require("./NftSale.js");
module.exports.default = {
    NftCollection,
    NftItem,
    NftMarketplace,
    NftSale
};

},{"./NftCollection.js":"fLNdb","./NftItem.js":"i0ZJr","./NftMarketplace.js":"gvLdT","./NftSale.js":"eihGj"}],"fLNdb":[function(require,module,exports) {
const { Contract  } = require("../../index.js");
const { Cell  } = require("../../../boc");
const { Address , bytesToBase64  } = require("../../../utils");
const { parseAddress  } = require("./NftUtils.js");
const { createOffchainUriCell , serializeUri , parseOffchainUriCell , getRoyaltyParams  } = require("./NftUtils");
class NftCollection extends Contract {
    /**
     * @param provider
     * @param options   {{ownerAddress: Address, collectionContentUri: string, nftItemContentBaseUri: string, nftItemCodeHex: string, royalty: number, royaltyAddress: Address, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        // https://github.com/ton-blockchain/token-contract/blob/1ad314a98d20b41241d5329e1786fc894ad811de/nft/nft-collection-editable.fc
        options.code = options.code || Cell.oneFromBoc("B5EE9C724102140100021F000114FF00F4A413F4BCF2C80B0102016202030202CD04050201200E0F04E7D10638048ADF000E8698180B8D848ADF07D201800E98FE99FF6A2687D20699FEA6A6A184108349E9CA829405D47141BAF8280E8410854658056B84008646582A802E78B127D010A65B509E58FE59F80E78B64C0207D80701B28B9E382F970C892E000F18112E001718112E001F181181981E0024060708090201200A0B00603502D33F5313BBF2E1925313BA01FA00D43028103459F0068E1201A44343C85005CF1613CB3FCCCCCCC9ED54925F05E200A6357003D4308E378040F4966FA5208E2906A4208100FABE93F2C18FDE81019321A05325BBF2F402FA00D43022544B30F00623BA9302A402DE04926C21E2B3E6303250444313C85005CF1613CB3FCCCCCCC9ED54002C323401FA40304144C85005CF1613CB3FCCCCCCC9ED54003C8E15D4D43010344130C85005CF1613CB3FCCCCCCC9ED54E05F04840FF2F00201200C0D003D45AF0047021F005778018C8CB0558CF165004FA0213CB6B12CCCCC971FB008002D007232CFFE0A33C5B25C083232C044FD003D0032C03260001B3E401D3232C084B281F2FFF2742002012010110025BC82DF6A2687D20699FEA6A6A182DE86A182C40043B8B5D31ED44D0FA40D33FD4D4D43010245F04D0D431D430D071C8CB0701CF16CCC980201201213002FB5DAFDA89A1F481A67FA9A9A860D883A1A61FA61FF480610002DB4F47DA89A1F481A67FA9A9A86028BE09E008E003E00B01A500C6E");
        if (options.royalty > 1) throw new Error("royalty > 1");
        options.royaltyBase = 1000;
        options.royaltyFactor = Math.floor(options.royalty * options.royaltyBase);
        super(provider, options);
        this.methods.getCollectionData = this.getCollectionData.bind(this);
        this.methods.getNftItemAddressByIndex = this.getNftItemAddressByIndex.bind(this);
        this.methods.getNftItemContent = this.getNftItemContent.bind(this);
        this.methods.getRoyaltyParams = this.getRoyaltyParams.bind(this);
    }
    /**
     * @private
     * @param params {{collectionContentUri: string, nftItemContentBaseUri: string}}
     * @return {Cell}
     */ createContentCell(params) {
        const collectionContentCell = createOffchainUriCell(params.collectionContentUri);
        const commonContentCell = new Cell();
        commonContentCell.bits.writeBytes(serializeUri(params.nftItemContentBaseUri));
        const contentCell = new Cell();
        contentCell.refs[0] = collectionContentCell;
        contentCell.refs[1] = commonContentCell;
        return contentCell;
    }
    /**
     * @private
     * @param params    {{royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}}
     * @return {Cell}
     */ createRoyaltyCell(params) {
        const royaltyCell = new Cell();
        royaltyCell.bits.writeUint(params.royaltyFactor, 16);
        royaltyCell.bits.writeUint(params.royaltyBase, 16);
        royaltyCell.bits.writeAddress(params.royaltyAddress);
        return royaltyCell;
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains nft collection data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeAddress(this.options.ownerAddress);
        cell.bits.writeUint(0, 64); // next_item_index
        cell.refs[0] = this.createContentCell(this.options);
        cell.refs[1] = Cell.oneFromBoc(this.options.nftItemCodeHex);
        cell.refs[2] = this.createRoyaltyCell(this.options);
        return cell;
    }
    /**
     * params   {{itemIndex: number, amount: BN, itemOwnerAddress: Address, itemContentUri: string, queryId?: number}}
     * @return {Cell}
     */ createMintBody(params) {
        const body = new Cell();
        body.bits.writeUint(1, 32); // OP deploy new nft
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.bits.writeUint(params.itemIndex, 64);
        body.bits.writeCoins(params.amount);
        const nftItemContent = new Cell();
        nftItemContent.bits.writeAddress(params.itemOwnerAddress);
        const uriContent = new Cell();
        uriContent.bits.writeBytes(serializeUri(params.itemContentUri));
        nftItemContent.refs[0] = uriContent;
        body.refs[0] = nftItemContent;
        return body;
    }
    /**
     * params   {{queryId?: number}}
     * @return {Cell}
     */ createGetRoyaltyParamsBody(params) {
        const body = new Cell();
        body.bits.writeUint(0x693d3950, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        return body;
    }
    /**
     * params   {{queryId?: number, newOwnerAddress: Address}}
     * @return {Cell}
     */ createChangeOwnerBody(params) {
        if (params.newOwnerAddress === undefined) throw new Error("Specify newOwnerAddress");
        const body = new Cell();
        body.bits.writeUint(3, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.bits.writeAddress(params.newOwnerAddress);
        return body;
    }
    /**
     * @param params    {{collectionContentUri: string, nftItemContentBaseUri: string, royalty: number, royaltyAddress: Address, queryId?: number}}
     * @return {Cell}
     */ createEditContentBody(params) {
        if (params.royalty > 1) throw new Error("royalty > 1");
        params.royaltyBase = 1000;
        params.royaltyFactor = Math.floor(params.royalty * params.royaltyBase);
        const body = new Cell();
        body.bits.writeUint(4, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.refs[0] = this.createContentCell(params);
        body.refs[1] = this.createRoyaltyCell(params);
        return body;
    }
    /**
     * @return {Promise<{nextItemIndex: number, ownerAddress: Address, collectionContentUri: string}>}
     */ async getCollectionData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_collection_data");
        const nextItemIndex = result[0].toNumber();
        const collectionContentUri = parseOffchainUriCell(result[1]);
        const ownerAddress = parseAddress(result[2]);
        return {
            nextItemIndex,
            ownerAddress,
            collectionContentUri
        };
    }
    /**
     * @param nftItem   {NFTItem}
     * @return {Promise<{isInitialized: boolean, index: number, collectionAddress: Address, ownerAddress: Address|null, contentUri: string}>}
     */ async getNftItemContent(nftItem) {
        const myAddress = await this.getAddress();
        const nftData = await nftItem.getData();
        if (nftData.isInitialized) {
            const result = await this.provider.call2(myAddress.toString(), "get_nft_content", [
                [
                    "num",
                    nftData.index
                ],
                [
                    "tvm.Cell",
                    bytesToBase64(await nftData.contentCell.toBoc(false))
                ]
            ]);
            nftData.contentUri = parseOffchainUriCell(result);
            delete nftData.contentCell;
        }
        return nftData;
    }
    /**
     * @param index {number}
     * @return {Promise<Address>}
     */ async getNftItemAddressByIndex(index) {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_nft_address_by_index", [
            [
                "num",
                index
            ]
        ]);
        return parseAddress(result);
    }
    /**
     * @return {Promise<{royalty: number, royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}>}
     */ async getRoyaltyParams() {
        const myAddress = await this.getAddress();
        return getRoyaltyParams(this.provider, myAddress.toString());
    }
}
module.exports = {
    NftCollection
};

},{"../../index.js":"drIoA","../../../boc":"4fqdK","../../../utils":"57M1Z","./NftUtils.js":"fLfHN","./NftUtils":"fLfHN"}],"fLfHN":[function(require,module,exports) {
const { base64ToBytes , Address  } = require("../../../utils");
const { Cell  } = require("../../../boc");
const SNAKE_DATA_PREFIX = 0x00;
const CHUNK_DATA_PREFIX = 0x01;
const ONCHAIN_CONTENT_PREFIX = 0x00;
const OFFCHAIN_CONTENT_PREFIX = 0x01;
/**
 * @param uri   {string}
 * @returns {Uint8Array}
 */ const serializeUri = (uri)=>{
    return new TextEncoder().encode(encodeURI(uri));
};
/**
 * @param bytes {Uint8Array}
 * @return {string}
 */ const parseUri = (bytes)=>{
    return new TextDecoder().decode(bytes);
};
/**
 * @param uri {string}
 * @return {Cell}
 */ const createOffchainUriCell = (uri)=>{
    const cell = new Cell();
    cell.bits.writeUint(OFFCHAIN_CONTENT_PREFIX, 8);
    cell.bits.writeBytes(serializeUri(uri));
    return cell;
};
/**
 * @param cell {Cell}
 * @returns {string}
 */ const parseOffchainUriCell = (cell)=>{
    let length = 0;
    let c = cell;
    while(c){
        length += c.bits.array.length;
        c = c.refs[0];
    }
    const bytes = new Uint8Array(length);
    length = 0;
    c = cell;
    while(c){
        bytes.set(c.bits.array, length);
        length += c.bits.array.length;
        c = c.refs[0];
    }
    return parseUri(bytes.slice(1)); // slice OFFCHAIN_CONTENT_PREFIX
};
/**
 * @param bs    {BitString}
 * @param cursor    {number}
 * @param bits  {number}
 * @return {BigInt}
 */ const readIntFromBitString = (bs, cursor, bits)=>{
    let n = BigInt(0);
    for(let i = 0; i < bits; i++){
        n *= BigInt(2);
        n += BigInt(bs.get(cursor + i));
    }
    return n;
};
/**
 * @param cell  {Cell}
 * @return {Address|null}
 */ const parseAddress = (cell)=>{
    let n = readIntFromBitString(cell.bits, 3, 8);
    if (n > BigInt(127)) n = n - BigInt(256);
    const hashPart = readIntFromBitString(cell.bits, 11, 256);
    if (n.toString(10) + ":" + hashPart.toString(16) === "0:0") return null;
    const s = n.toString(10) + ":" + hashPart.toString(16).padStart(64, "0");
    return new Address(s);
};
/**
 * @param provider {HttpProvider}
 * @param address {string}
 * @return {Promise<{royalty: number, royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}>}
 */ const getRoyaltyParams = async (provider, address)=>{
    const result = await provider.call2(address, "royalty_params");
    const royaltyFactor = result[0].toNumber();
    const royaltyBase = result[1].toNumber();
    const royalty = royaltyFactor / royaltyBase;
    const royaltyAddress = parseAddress(result[2]);
    return {
        royalty,
        royaltyBase,
        royaltyFactor,
        royaltyAddress
    };
};
module.exports = {
    SNAKE_DATA_PREFIX,
    CHUNK_DATA_PREFIX,
    ONCHAIN_CONTENT_PREFIX,
    OFFCHAIN_CONTENT_PREFIX,
    parseAddress,
    serializeUri,
    parseUri,
    createOffchainUriCell,
    parseOffchainUriCell,
    getRoyaltyParams
};

},{"../../../utils":"57M1Z","../../../boc":"4fqdK"}],"i0ZJr":[function(require,module,exports) {
const { Contract  } = require("../../index");
const { Cell  } = require("../../../boc");
const { Address , BN  } = require("../../../utils");
const { parseAddress , getRoyaltyParams  } = require("./NftUtils.js");
const { parseOffchainUriCell  } = require("./NftUtils");
// https://github.com/ton-blockchain/token-contract/blob/1ad314a98d20b41241d5329e1786fc894ad811de/nft/nft-item.fc
const NFT_ITEM_CODE_HEX = "B5EE9C7241020D010001D0000114FF00F4A413F4BCF2C80B0102016202030202CE04050009A11F9FE00502012006070201200B0C02D70C8871C02497C0F83434C0C05C6C2497C0F83E903E900C7E800C5C75C87E800C7E800C3C00812CE3850C1B088D148CB1C17CB865407E90350C0408FC00F801B4C7F4CFE08417F30F45148C2EA3A1CC840DD78C9004F80C0D0D0D4D60840BF2C9A884AEB8C097C12103FCBC20080900113E910C1C2EBCB8536001F65135C705F2E191FA4021F001FA40D20031FA00820AFAF0801BA121945315A0A1DE22D70B01C300209206A19136E220C2FFF2E192218E3E821005138D91C85009CF16500BCF16712449145446A0708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00104794102A375BE20A00727082108B77173505C8CBFF5004CF1610248040708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB000082028E3526F0018210D53276DB103744006D71708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB0093303234E25502F003003B3B513434CFFE900835D27080269FC07E90350C04090408F80C1C165B5B60001D00F232CFD633C58073C5B3327B5520BF75041B";
class NftItem extends Contract {
    /**
     * @param provider
     * @param options   {{index: number, collectionAddress: Address, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc(NFT_ITEM_CODE_HEX);
        super(provider, options);
        this.methods.getData = this.getData.bind(this);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains nft data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeUint(this.options.index, 64);
        cell.bits.writeAddress(this.options.collectionAddress);
        return cell;
    }
    /**
     * @return {Promise<{isInitialized: boolean, index: number, collectionAddress: Address|null, ownerAddress: Address|null, contentCell: Cell, contentUri: string|null}>}
     */ async getData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_nft_data");
        const isInitialized = result[0].toNumber() === -1;
        const index = result[1].toNumber();
        const collectionAddress = parseAddress(result[2]);
        const ownerAddress = isInitialized ? parseAddress(result[3]) : null;
        const contentCell = result[4];
        const contentUri = isInitialized && collectionAddress === null ? parseOffchainUriCell(contentCell) : null; // single NFT without collection
        return {
            isInitialized,
            index,
            collectionAddress,
            ownerAddress,
            contentCell,
            contentUri
        };
    }
    /**
     * @param params    {{queryId?: number, newOwnerAddress: Address, forwardAmount?: BN, forwardPayload?: Uint8Array, responseAddress: Address}}
     */ async createTransferBody(params) {
        const cell = new Cell();
        cell.bits.writeUint(0x5fcc3d14, 32); // transfer op
        cell.bits.writeUint(params.queryId || 0, 64);
        cell.bits.writeAddress(params.newOwnerAddress);
        cell.bits.writeAddress(params.responseAddress);
        cell.bits.writeBit(false); // null custom_payload
        cell.bits.writeCoins(params.forwardAmount || new BN(0));
        cell.bits.writeBit(false); // forward_payload in this slice, not separate cell
        if (params.forwardPayload) cell.bits.writeBytes(params.forwardPayload);
        return cell;
    }
    /**
     * params   {{queryId?: number}}
     * @return {Cell}
     */ createGetStaticDataBody(params) {
        const body = new Cell();
        body.bits.writeUint(0x2fcb26a2, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        return body;
    }
    /**
     * for single nft without collection
     * @return {Promise<{royalty: number, royaltyFactor: number, royaltyBase: number, royaltyAddress: Address}>}
     */ async getRoyaltyParams() {
        const myAddress = await this.getAddress();
        return getRoyaltyParams(this.provider, myAddress.toString());
    }
}
NftItem.codeHex = NFT_ITEM_CODE_HEX;
module.exports = {
    NftItem
};

},{"../../index":"drIoA","../../../boc":"4fqdK","../../../utils":"57M1Z","./NftUtils.js":"fLfHN","./NftUtils":"fLfHN"}],"gvLdT":[function(require,module,exports) {
const { Contract  } = require("../../index.js");
const { Cell  } = require("../../../boc");
const { Address  } = require("../../../utils");
const { parseAddress  } = require("./NftUtils.js");
/**
 * Not release - will change
 */ class NftMarketplace extends Contract {
    /**
     * @param provider
     * @param options   {{ownerAddress: Address, address?: Address | string, cell?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc("B5EE9C7241010401006D000114FF00F4A413F4BCF2C80B01020120020300AAD23221C700915BE0D0D3030171B0915BE0FA40ED44D0FA403012C705F2E19101D31F01C0018E2BFA003001D4D43021F90070C8CA07CBFFC9D077748018C8CB05CB0258CF165004FA0213CB6BCCCCC971FB00915BE20004F2308EF7CCE7");
        super(provider, options);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains nft marketplace data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeAddress(this.options.ownerAddress);
        return cell;
    }
}
module.exports = {
    NftMarketplace
};

},{"../../index.js":"drIoA","../../../boc":"4fqdK","../../../utils":"57M1Z","./NftUtils.js":"fLfHN"}],"eihGj":[function(require,module,exports) {
const { Contract  } = require("../../index");
const { Cell  } = require("../../../boc");
const { parseAddress  } = require("./NftUtils");
const { BN  } = require("../../../utils");
const NFT_SALE_HEX_CODE = "B5EE9C7241020A010001B4000114FF00F4A413F4BCF2C80B01020120020302014804050004F2300202CD0607002FA03859DA89A1F481F481F481F401A861A1F401F481F4006101F7D00E8698180B8D8492F82707D201876A2687D207D207D207D006A18116BA4E10159C71D991B1B2990E382C92F837028916382F970FA01698FC1080289C6C8895D7970FAE99F98FD2018201A642802E78B2801E78B00E78B00FD016664F6AA701363804C9B081B2299823878027003698FE99F9810E000C92F857010C0801F5D41081DCD650029285029185F7970E101E87D007D207D0018384008646582A804E78B28B9D090D0A85AD08A500AFD010AE5B564B8FD80384008646582AC678B2803FD010B65B564B8FD80384008646582A802E78B00FD0109E5B564B8FD80381041082FE61E8A10C00C646582A802E78B117D010A65B509E58F8A40900C8C0029A3110471036454012F004E032363704C0038E4782103B9ACA0015BEF2E1C95312C70559C705B1F2E1CA702082105FCC3D14218010C8CB055006CF1622FA0215CB6A14CB1F14CB3F21CF1601CF16CA0021FA02CA00C98100A0FB00E05F06840FF2F0002ACB3F22CF1658CF16CA0021FA02CA00C98100A0FB00AECABAD1";
/**
 * Not release - will change
 */ class NftSale extends Contract {
    /**
     * @param provider
     * @param options   {{marketplaceAddress: Address, nftAddress: Address, fullPrice: BN, marketplaceFee: BN, royaltyAddress: Address, royaltyAmount: BN, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc(NFT_SALE_HEX_CODE);
        super(provider, options);
        this.methods.getData = this.getData.bind(this);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains nft sale data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeAddress(this.options.marketplaceAddress);
        cell.bits.writeAddress(this.options.nftAddress);
        cell.bits.writeAddress(null); // nft_owner_address
        cell.bits.writeCoins(this.options.fullPrice);
        const feesCell = new Cell();
        feesCell.bits.writeCoins(this.options.marketplaceFee);
        feesCell.bits.writeAddress(this.options.royaltyAddress);
        feesCell.bits.writeCoins(this.options.royaltyAmount);
        cell.refs[0] = feesCell;
        return cell;
    }
    async getData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_sale_data");
        const marketplaceAddress = parseAddress(result[0]);
        const nftAddress = parseAddress(result[1]);
        const nftOwnerAddress = parseAddress(result[2]);
        const fullPrice = result[3];
        const marketplaceFee = result[4];
        const royaltyAddress = parseAddress(result[5]);
        const royaltyAmount = result[6];
        return {
            marketplaceAddress,
            nftAddress,
            nftOwnerAddress,
            fullPrice,
            marketplaceFee,
            royaltyAddress,
            royaltyAmount
        };
    }
    /**
     * @param params    {{queryId?: number}}
     */ async createCancelBody(params) {
        const cell = new Cell();
        cell.bits.writeUint(3, 32); // cancel op
        cell.bits.writeUint(params.queryId || 0, 64);
        return cell;
    }
}
NftSale.codeHex = NFT_SALE_HEX_CODE;
module.exports = {
    NftSale
};

},{"../../index":"drIoA","../../../boc":"4fqdK","./NftUtils":"fLfHN","../../../utils":"57M1Z"}],"7I7oy":[function(require,module,exports) {
const { JettonMinter  } = require("./JettonMinter.js");
const { JettonWallet  } = require("./JettonWallet.js");
module.exports.default = {
    JettonMinter,
    JettonWallet
};

},{"./JettonMinter.js":"7exLn","./JettonWallet.js":"hcmYq"}],"7exLn":[function(require,module,exports) {
const { Contract  } = require("../../index");
const { Cell  } = require("../../../boc");
const { createOffchainUriCell , parseOffchainUriCell , parseAddress  } = require("../nft/NftUtils");
const { Address , BN , bytesToBase64  } = require("../../../utils");
class JettonMinter extends Contract {
    /**
     * @param provider
     * @param options   {{adminAddress: Address, jettonContentUri: string, jettonWalletCodeHex: string, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc("B5EE9C7241020B010001ED000114FF00F4A413F4BCF2C80B0102016202030202CC040502037A60090A03EFD9910E38048ADF068698180B8D848ADF07D201800E98FE99FF6A2687D007D206A6A18400AA9385D47181A9AA8AAE382F9702480FD207D006A18106840306B90FD001812881A28217804502A906428027D012C678B666664F6AA7041083DEECBEF29385D71811A92E001F1811802600271812F82C207F97840607080093DFC142201B82A1009AA0A01E428027D012C678B00E78B666491646580897A007A00658064907C80383A6465816503E5FFE4E83BC00C646582AC678B28027D0109E5B589666664B8FD80400FE3603FA00FA40F82854120870542013541403C85004FA0258CF1601CF16CCC922C8CB0112F400F400CB00C9F9007074C8CB02CA07CBFFC9D05008C705F2E04A12A1035024C85004FA0258CF16CCCCC9ED5401FA403020D70B01C3008E1F8210D53276DB708010C8CB055003CF1622FA0212CB6ACB1FCB3FC98042FB00915BE200303515C705F2E049FA403059C85004FA0258CF16CCCCC9ED54002E5143C705F2E049D43001C85004FA0258CF16CCCCC9ED54007DADBCF6A2687D007D206A6A183618FC1400B82A1009AA0A01E428027D012C678B00E78B666491646580897A007A00658064FC80383A6465816503E5FFE4E840001FAF16F6A2687D007D206A6A183FAA904051007F09");
        super(provider, options);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains jetton minter data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeCoins(0); // total supply
        cell.bits.writeAddress(this.options.adminAddress);
        cell.refs[0] = createOffchainUriCell(this.options.jettonContentUri);
        cell.refs[1] = Cell.oneFromBoc(this.options.jettonWalletCodeHex);
        return cell;
    }
    /**
     * params   {{jettonAmount: BN, destination: Address, amount: BN, queryId?: number}}
     * @return {Cell}
     */ createMintBody(params) {
        const body = new Cell();
        body.bits.writeUint(21, 32); // OP mint
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.bits.writeAddress(params.destination);
        body.bits.writeCoins(params.amount); // in Toncoins
        const transferBody = new Cell(); // internal transfer
        transferBody.bits.writeUint(0x178d4519, 32); // internal_transfer op
        transferBody.bits.writeUint(params.queryId || 0, 64);
        transferBody.bits.writeCoins(params.jettonAmount);
        transferBody.bits.writeAddress(null); // from_address
        transferBody.bits.writeAddress(null); // response_address
        transferBody.bits.writeCoins(new BN(0)); // forward_amount
        transferBody.bits.writeBit(false); // forward_payload in this slice, not separate cell
        body.refs[0] = transferBody;
        return body;
    }
    /**
     * params   {{queryId?: number, newAdminAddress: Address}}
     * @return {Cell}
     */ createChangeAdminBody(params) {
        if (params.newAdminAddress === undefined) throw new Error("Specify newAdminAddress");
        const body = new Cell();
        body.bits.writeUint(3, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.bits.writeAddress(params.newAdminAddress);
        return body;
    }
    /**
     * params   {{jettonContentUri: string, queryId?: number}}
     * @return {Cell}
     */ createEditContentBody(params) {
        const body = new Cell();
        body.bits.writeUint(4, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        body.refs[0] = createOffchainUriCell(params.jettonContentUri);
        return body;
    }
    /**
     * @return {Promise<{ totalSupply: BN, isMutable: boolean, adminAddress: Address|null, jettonContentUri: string, jettonWalletCode: Cell }>}
     */ async getJettonData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_jetton_data");
        const totalSupply = result[0];
        const isMutable = result[1].toNumber() === -1;
        const adminAddress = parseAddress(result[2]);
        const jettonContentUri = parseOffchainUriCell(result[3]);
        const jettonWalletCode = result[4];
        return {
            totalSupply,
            isMutable,
            adminAddress,
            jettonContentUri,
            jettonWalletCode
        };
    }
    /**
     * params   {{ownerAddress: Address}}
     * @return {Promise<Address>}
     */ async getJettonWalletAddress(ownerAddress) {
        const myAddress = await this.getAddress();
        const cell = new Cell();
        cell.bits.writeAddress(ownerAddress);
        const result = await this.provider.call2(myAddress.toString(), "get_wallet_address", [
            [
                "tvm.Slice",
                bytesToBase64(await cell.toBoc(false))
            ]
        ]);
        return parseAddress(result);
    }
}
module.exports = {
    JettonMinter
};

},{"../../index":"drIoA","../../../boc":"4fqdK","../nft/NftUtils":"fLfHN","../../../utils":"57M1Z"}],"hcmYq":[function(require,module,exports) {
const { Contract  } = require("../../index");
const { Cell  } = require("../../../boc");
const { parseAddress  } = require("../nft/NftUtils");
const { BN  } = require("../../../utils");
const JETTON_WALLET_CODE_HEX = "B5EE9C7241021201000328000114FF00F4A413F4BCF2C80B0102016202030202CC0405001BA0F605DA89A1F401F481F481A8610201D40607020148080900BB0831C02497C138007434C0C05C6C2544D7C0FC02F83E903E900C7E800C5C75C87E800C7E800C00B4C7E08403E29FA954882EA54C4D167C0238208405E3514654882EA58C511100FC02780D60841657C1EF2EA4D67C02B817C12103FCBC2000113E910C1C2EBCB853600201200A0B020120101101F500F4CFFE803E90087C007B51343E803E903E90350C144DA8548AB1C17CB8B04A30BFFCB8B0950D109C150804D50500F214013E809633C58073C5B33248B232C044BD003D0032C032483E401C1D3232C0B281F2FFF274013E903D010C7E801DE0063232C1540233C59C3E8085F2DAC4F3208405E351467232C7C6600C03F73B51343E803E903E90350C0234CFFE80145468017E903E9014D6F1C1551CDB5C150804D50500F214013E809633C58073C5B33248B232C044BD003D0032C0327E401C1D3232C0B281F2FFF274140371C1472C7CB8B0C2BE80146A2860822625A020822625A004AD822860822625A028062849F8C3C975C2C070C008E00D0E0F009ACB3F5007FA0222CF165006CF1625FA025003CF16C95005CC2391729171E25008A813A08208989680AA008208989680A0A014BCF2E2C504C98040FB001023C85004FA0258CF1601CF16CCC9ED5400705279A018A182107362D09CC8CB1F5230CB3F58FA025007CF165007CF16C9718018C8CB0524CF165006FA0215CB6A14CCC971FB0010241023000E10491038375F040076C200B08E218210D53276DB708010C8CB055008CF165004FA0216CB6A12CB1F12CB3FC972FB0093356C21E203C85004FA0258CF1601CF16CCC9ED5400DB3B51343E803E903E90350C01F4CFFE803E900C145468549271C17CB8B049F0BFFCB8B0A0822625A02A8005A805AF3CB8B0E0841EF765F7B232C7C572CFD400FE8088B3C58073C5B25C60063232C14933C59C3E80B2DAB33260103EC01004F214013E809633C58073C5B3327B55200083200835C87B51343E803E903E90350C0134C7E08405E3514654882EA0841EF765F784EE84AC7CB8B174CFCC7E800C04E81408F214013E809633C58073C5B3327B55205ECCF23D";
class JettonWallet extends Contract {
    /**
     * @param provider
     * @param options   {{address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc(JETTON_WALLET_CODE_HEX);
        super(provider, options);
    }
    /**
     * @param params    {{queryId?: number, jettonAmount: BN, toAddress: Address, responseAddress: Address, forwardAmount: BN, forwardPayload: Uint8Array}}
     */ async createTransferBody(params) {
        const cell = new Cell();
        cell.bits.writeUint(0xf8a7ea5, 32); // request_transfer op
        cell.bits.writeUint(params.queryId || 0, 64);
        cell.bits.writeCoins(params.jettonAmount);
        cell.bits.writeAddress(params.toAddress);
        cell.bits.writeAddress(params.responseAddress);
        cell.bits.writeBit(false); // null custom_payload
        cell.bits.writeCoins(params.forwardAmount || new BN(0));
        cell.bits.writeBit(false); // forward_payload in this slice, not separate cell
        if (params.forwardPayload) cell.bits.writeBytes(params.forwardPayload);
        return cell;
    }
    /**
     * @param params    {{queryId?: number, jettonAmount: BN, responseAddress: Address}}
     */ async createBurnBody(params) {
        const cell = new Cell();
        cell.bits.writeUint(0x595f07bc, 32); // burn op
        cell.bits.writeUint(params.queryId || 0, 64);
        cell.bits.writeCoins(params.jettonAmount);
        cell.bits.writeAddress(params.responseAddress);
        return cell;
    }
    async getData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_wallet_data");
        const balance = result[0];
        const ownerAddress = parseAddress(result[1]);
        const jettonMinterAddress = parseAddress(result[2]);
        const jettonWalletCode = result[3];
        return {
            balance,
            ownerAddress,
            jettonMinterAddress,
            jettonWalletCode
        };
    }
}
JettonWallet.codeHex = JETTON_WALLET_CODE_HEX;
module.exports = {
    JettonWallet
};

},{"../../index":"drIoA","../../../boc":"4fqdK","../nft/NftUtils":"fLfHN","../../../utils":"57M1Z"}],"klRLG":[function(require,module,exports) {
const { BlockSubscription  } = require("./BlockSubscription");
const { InMemoryBlockStorage  } = require("./InMemoryBlockStorage");
module.exports = {
    BlockSubscription,
    InMemoryBlockStorage
};

},{"./BlockSubscription":"ebYbD","./InMemoryBlockStorage":"4dNH1"}],"ebYbD":[function(require,module,exports) {
// NOTE: "mc" means masterchain, "shards" means shardchains
const MC_INTERVAL = 10000;
const SHARDS_INTERVAL = 1000;
const parseShardBlockNumber = (x)=>{
    return {
        workchain: x.workchain,
        shardId: x.shard,
        shardBlockNumber: x.seqno
    };
};
class BlockSubscription {
    /**
     * @param provider  {TonWeb.HttpProvider}
     * @param storage   persistent storage for storing block numbers that we have already processed.
     * @param onBlock {(blockHeader: BlockHeader) => Promise<void>} callback which is called for of each block.
     *                                                       callback may throw an error, in this case the block processing will be interrupted and block will not be saved in the storage as processed.
     *                                                       shardchain blocks are processed OUT of chronological order.
     *                                                       masterchain blocks are processed in chronological order.
     *                                                       for masterchain workchain === -1 and shardId === '-9223372036854775808'
     * @param options? {startMcBlockNumber:? number, mcInterval?: number, shardsInterval?: number} start masterchain block number from which we start to process blocks.
     *                                     if not specified, the subscription starts from the last block of the network at the time of launch.
     */ constructor(provider, storage, onBlock, options){
        this.provider = provider;
        this.storage = storage;
        this.onBlock = onBlock;
        this.startMcBlockNumber = options ? options.startMcBlockNumber : undefined;
        this.mcInterval = (options ? options.mcInterval : undefined) || MC_INTERVAL;
        this.shardsInterval = (options ? options.shardsInterval : undefined) || SHARDS_INTERVAL;
    }
    async start() {
        this.stop();
        if (!this.startMcBlockNumber) {
            this.startMcBlockNumber = (await this.provider.getMasterchainInfo()).last.seqno;
            if (!this.startMcBlockNumber) throw new Error("Cannot get start mc block number from provider");
        }
        const startMcBlockHeader = await this.provider.getMasterchainBlockHeader(this.startMcBlockNumber);
        this.startLT = startMcBlockHeader.end_lt;
        if (!this.startLT) throw new Error("Cannot get startLT from provider");
        // MASTERCHAIN
        let isMcProcessing = false;
        const mcTick = async ()=>{
            if (isMcProcessing) return;
            isMcProcessing = true;
            try {
                const lastSavedMcBlock = await this.storage.getLastMasterchainBlockNumber() || this.startMcBlockNumber;
                if (!lastSavedMcBlock) throw new Error("no init masterchain block in storage");
                const lastMcBlock = (await this.provider.getMasterchainInfo()).last.seqno;
                if (!lastMcBlock) throw new Error("invalid last masterchain block from provider");
                for(let i = lastSavedMcBlock + 1; i < lastMcBlock; i++){
                    const blockShards = await this.provider.getBlockShards(i);
                    const blockHeader = await this.provider.getMasterchainBlockHeader(i);
                    await this.onBlock(blockHeader, blockShards);
                    await this.storage.insertBlocks(i, blockShards.shards.map(parseShardBlockNumber));
                }
            } catch (e) {
                console.error(e);
            }
            isMcProcessing = false;
        };
        this.mcIntervalId = setInterval(()=>mcTick(), this.mcInterval);
        mcTick();
        // SHARDCHAINS
        let isShardsProcessing = false;
        const shardsTick = async ()=>{
            if (isShardsProcessing) return;
            isShardsProcessing = true;
            try {
                const shardBlock = await this.storage.getUnprocessedShardBlock();
                if (shardBlock) {
                    const { workchain , shardId , shardBlockNumber  } = shardBlock;
                    const blockHeader = await this.provider.getBlockHeader(workchain, shardId, shardBlockNumber);
                    if (blockHeader.end_lt < this.startLT) await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, []);
                    else {
                        await this.onBlock(blockHeader);
                        const prevBlocks = blockHeader.prev_blocks.map(parseShardBlockNumber);
                        await this.storage.setBlockProcessed(workchain, shardId, shardBlockNumber, prevBlocks);
                    }
                }
            } catch (e) {
                console.log(e);
            }
            isShardsProcessing = false;
        };
        this.shardsIntervalId = setInterval(()=>shardsTick(), this.shardsInterval);
    }
    stop() {
        clearInterval(this.mcIntervalId);
        clearInterval(this.shardsIntervalId);
    }
}
module.exports = {
    BlockSubscription
};

},{}],"4dNH1":[function(require,module,exports) {
/**
 * Storage for storing block numbers that we have already processed.
 * Used by `BlockSubscription`.
 *
 * Dumb in-memory implementation.
 */ class InMemoryBlockStorage {
    /**
     * @param logFunction?   {(text: string) => void}
     */ constructor(logFunction){
        this.masterchainBlocks = {}; // mcBlockNumber {number} -> isProcessed {boolean}
        this.shardchainBlocks = {}; // workchain {number} + shardId {string} + shardBlockNumber {number} -> isProcessed {boolean}
        this.logFunction = logFunction;
    }
    /**
     * @private
     * Insert new UNprocessed shardchain block numbers
     * Block number (workchain + shardId + shardBlockNumber) should be IGNORED if it is already in the storage
     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}
     */ async insertShardBlocks(shardBlockNumbers) {
        for (const { workchain , shardId , shardBlockNumber  } of shardBlockNumbers){
            if (this.shardchainBlocks[workchain + "_" + shardId + "_" + shardBlockNumber] !== undefined) continue;
            if (this.logFunction) this.logFunction("insert shard " + workchain + " " + shardId + " " + shardBlockNumber);
            // INSERT INTO shardchainBlocks VALUES (workchain, shardId, shardBlockNumber, FALSE);
            this.shardchainBlocks[workchain + "_" + shardId + "_" + shardBlockNumber] = false;
        }
    }
    /**
     * Insert new processed masterchain block number & new UNprocessed shardchains blocks numbers
     * Must be in single DB transaction
     * @param   mcBlockNumber {number}
     * @param   shardBlockNumbers {[{workchain: number, shardId: string, shardBlockNumber: number}]}
     */ async insertBlocks(mcBlockNumber, shardBlockNumbers) {
        if (this.logFunction) this.logFunction("mc processed " + mcBlockNumber);
        // INSERT INTO masterchainBlocks VALUES (blockNumber, TRUE);
        if (this.masterchainBlocks[mcBlockNumber] !== undefined) throw new Error("mc already exists " + mcBlockNumber);
        this.masterchainBlocks[mcBlockNumber] = true;
        await this.insertShardBlocks(shardBlockNumbers);
    }
    /**
     * Get last processed masterchain block number
     * @return {Promise<number | undefined>}
     */ async getLastMasterchainBlockNumber() {
        // SELECT MAX(blockNumber) FROM masterchainBlocks
        const blockNumbers = Object.keys(this.masterchainBlocks).map((x)=>Number(x)).sort((a, b)=>b - a);
        return blockNumbers[0];
    }
    /**
     * Set that this shardchain block number processed & insert new UNprocessed shardchains blocks numbers
     * Must be in single DB transaction
     * @param   workchain {number}
     * @param   shardId {string}
     * @param   shardBlockNumber    {number}
     * @param   prevShardBlocks    {[{workchain: number, shardId: string, shardBlockNumber: number}]}
     */ async setBlockProcessed(workchain, shardId, shardBlockNumber, prevShardBlocks) {
        if (this.logFunction) this.logFunction("shard processed " + workchain + " " + shardId + " " + shardBlockNumber);
        // UPDATE shardchainBlocks SET processed = TRUE WHERE workchain = ? AND shardId = ? AND shardBlockNumber = ?
        if (this.shardchainBlocks[workchain + "_" + shardId + "_" + shardBlockNumber] === undefined) throw new Error("shard not exists " + workchain + "_" + shardId + "_" + shardBlockNumber);
        this.shardchainBlocks[workchain + "_" + shardId + "_" + shardBlockNumber] = true;
        await this.insertShardBlocks(prevShardBlocks);
    }
    /**
     * Get any unprocesed shard block number (order is not important)
     * @return {Promise<{workchain: number, shardId: string, shardBlockNumber: number}>}
     */ async getUnprocessedShardBlock() {
        // SELECT workchain, shardId, shardBlockNumber from sharchainBlocks WHERE processed = FALSE LIMIT 1
        for(let key in this.shardchainBlocks)if (this.shardchainBlocks[key] === false) {
            const arr = key.split("_");
            return {
                workchain: Number(arr[0]),
                shardId: arr[1],
                shardBlockNumber: Number(arr[2])
            };
        }
        return undefined;
    }
}
module.exports = {
    InMemoryBlockStorage
};

},{}],"726RW":[function(require,module,exports) {
const { Contract  } = require("../index.js");
const { Cell  } = require("../../boc");
const { hexToBytes , BN , nacl , bytesToBase64  } = require("../../utils");
class SubscriptionContract extends Contract {
    /**
     * @param provider
     * @param options   {{wc: number, wallet: Address, beneficiary: Address, amount: BN, period: number, timeout: number, startAt: number, subscriptionId: number, address?: Address | string}}
     */ constructor(provider, options){
        options.code = Cell.oneFromBoc("B5EE9C7241020F01000262000114FF00F4A413F4BCF2C80B0102012002030201480405036AF230DB3C5335A127A904F82327A128A90401BC5135A0F823B913B0F29EF800725210BE945387F0078E855386DB3CA4E2F82302DB3C0B0C0D0202CD06070121A0D0C9B67813F488DE0411F488DE0410130B048FD6D9E05E8698198FD201829846382C74E2F841999E98F9841083239BA395D497803F018B841083AB735BBED9E702984E382D9C74688462F863841083AB735BBED9E70156BA4E09040B0A0A080269F10FD22184093886D9E7C12C1083239BA39384008646582A803678B2801FD010A65B5658F89659FE4B9FD803FC1083239BA396D9E40E0A04F08E8D108C5F0C708210756E6B77DB3CE00AD31F308210706C7567831EB15210BA8F48305324A126A904F82326A127A904BEF27109FA4430A619F833D078D721D70B3F5260A11BBE8E923036F82370708210737562732759DB3C5077DE106910581047103645135042DB3CE0395F076C2232821064737472BA0A0A0D09011A8E897F821064737472DB3CE0300A006821B39982100400000072FB02DE70F8276F118010C8CB055005CF1621FA0214F40013CB6912CB1F830602948100A032DEC901FB000030ED44D0FA40FA40FA00D31FD31FD31FD31FD31FD307D31F30018021FA443020813A98DB3C01A619F833D078D721D70B3FA070F8258210706C7567228018C8CB055007CF165004FA0215CB6A12CB1F13CB3F01FA02CB00C973FB000E0040C8500ACF165008CF165006FA0214CB1F12CB1FCB1FCB1FCB1FCB07CB1FC9ED54005801A615F833D020D70B078100D1BA95810088D721DED307218100DDBA028100DEBA12B1F2E047D33F30A8AB0FE5855AB4");
        super(provider, options);
        this.methods.pay = ()=>Contract.createMethod(provider, this.createPayExternalMessage());
        this.methods.getSubscriptionData = this.getSubscriptionData.bind(this);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains wallet data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeAddress(this.options.wallet);
        cell.bits.writeAddress(this.options.beneficiary);
        cell.bits.writeGrams(this.options.amount);
        cell.bits.writeUint(this.options.period, 32);
        cell.bits.writeUint(this.options.startAt, 32); // start_time
        cell.bits.writeUint(this.options.timeout, 32);
        cell.bits.writeUint(0, 32); // last_payment_time
        cell.bits.writeUint(0, 32); // last_request_time
        cell.bits.writeUint(0, 8); // failed_attempts
        cell.bits.writeUint(this.options.subscriptionId, 32); // subscription_id
        return cell;
    }
    /**
     * Payment body (from wallet to subscription)
     * @return {Cell}
     */ createBody() {
        const body = new Cell();
        body.bits.writeUint(new BN(0x706c7567).add(new BN(0x80000000)), 32); // op
        return body;
    }
    /**
     * Destroy plugin body (from wallet to subscription OR from beneficiary to subscription)
     * @return {Cell}
     */ createSelfDestructBody() {
        const body = new Cell();
        body.bits.writeUint(0x64737472, 32); // op
        return body;
    }
    async getSubscriptionData() {
        const parseAddress = (tuple)=>tuple[0].toNumber() + ":" + tuple[1].toString(16);
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_subscription_data");
        const wallet = parseAddress(result[0]);
        const beneficiary = parseAddress(result[1]);
        const amount = result[2];
        const period = result[3].toNumber();
        const startAt = result[4].toNumber(); // start_time
        const timeout = result[5].toNumber();
        const lastPayment = result[6].toNumber(); // last_payment_time
        const lastRequest = result[7].toNumber(); // last_request_time
        const failedAttempts = result[8].toNumber();
        const subscriptionId = result[9].toNumber();
        return {
            wallet,
            beneficiary,
            amount,
            period,
            startAt,
            timeout,
            lastPayment,
            lastRequest,
            failedAttempts,
            subscriptionId
        };
    }
    /**
     * @protected
     * @return {Promise<{address: Address, signature: Uint8Array, message: Cell, cell: Cell, body: Cell, resultMessage: Cell}>}
     */ async createPayExternalMessage() {
        const selfAddress = await this.getAddress();
        const header = Contract.createExternalMessageHeader(selfAddress);
        const resultMessage = Contract.createCommonMsgInfo(header, null, null);
        const body = new Cell();
        body.bits.writeUint(Math.floor(Date.now() / 1000), 64); // this is not required by the contract; just to make it easier to distinguish messages
        return {
            address: selfAddress,
            message: resultMessage,
            body: body
        };
    }
}
module.exports = {
    SubscriptionContract
};

},{"../index.js":"drIoA","../../boc":"4fqdK","../../utils":"57M1Z"}],"gIMhG":[function(require,module,exports) {
const { PaymentChannel  } = require("./PaymentChannel");
class Payments {
    /**
     * @param provider    {HttpProvider}
     */ constructor(provider){
        this.provider = provider;
    }
    createChannel(options) {
        return new PaymentChannel(this.provider, options);
    }
}
module.exports = {
    Payments,
    PaymentChannel
};

},{"./PaymentChannel":"kziaY"}],"kziaY":[function(require,module,exports) {
const { Contract  } = require("../index");
const { Cell  } = require("../../boc");
const { nacl , hexToBytes , BN  } = require("../../utils");
const { parseAddress  } = require("../token/nft/NftUtils");
const { writePublicKey , writeSignature , createSignatureCell , tag_init , tag_cooperative_close , tag_cooperative_commit , tag_start_uncooperative_close , tag_challenge_state , tag_settle_conditionals , tag_state , op_top_up_balance , op_init_channel , op_cooperative_close , op_cooperative_commit , op_start_uncooperative_close , op_challenge_quarantined_state , op_settle_conditionals , op_finish_uncooperative_close , op_channel_closed , createTopUpBalance , createInitChannelBody , createCooperativeCloseChannelBody , createCooperativeCommitBody , createConditionalPayment , createSemiChannelBody , createSemiChannelState , createSignedSemiChannelState , createStartUncooperativeCloseBody , createChallengeQuarantinedStateBody , createSettleConditionalsBody , createFinishUncooperativeClose , createOneSignature , createTwoSignature  } = require("./PaymentUtils");
const PAYMENT_CHANNEL_CODE_HEX = "B5EE9C72410230010007FB000114FF00F4A413F4BCF2C80B0102012002030201480405000AF26C21F0190202CB06070201202E2F020120080902012016170201200A0B0201200C0D0009D3610F80CC001D6B5007434C7FE8034C7CC1BC0FE19E0201580E0F0201201011002D3E11DBC4BE11DBC43232C7FE11DBC47E80B2C7F2407320008B083E1B7B51343480007E187E80007E18BE80007E18F4FFC07E1934FFC07E1974DFC07E19BC01887080A7F4C7C07E1A34C7C07E1A7D01007E1AB7807080E535007E1AF7BE1B2002012012130201201415008D3E13723E11BE117E113E10540132803E10BE80BE10FE8084F2FFC4B2FFF2DFFC02887080A7FE12BE127E121400F2C7C4B2C7FD0037807080E53E12C073253E1333C5B8B27B5520004D1C3C02FE106CFCB8193E803E800C3E1096283E18BE10C0683E18FE10BE10E8006EFCB819BC032000CF1D3C02FE106CFCB819348020C235C6083E4040E4BE1124BE117890CC3E443CB81974C7C060841A5B9A5D2EBCB81A3E118074DFD66EBCB81CBE803E800C3E1094882FBE10D4882FAC3CB819807E18BE18FE12F43E800C3E10BE10E80068006E7CB8199FFE187C0320004120843777222E9C20043232C15401B3C594013E808532DA84B2C7F2DFF2407EC02002012018190201D42B2C0201201A1B0201201E1F0201201C1D00E5473F00BD401D001D401D021F90102D31F01821043436D74BAF2E068F84601D37F59BAF2E072F844544355F910F8454330F910B0F2E065D33FD33F30F84822B9F84922B9B0F2E06C21F86820F869F84A6E915B8E19F84AD0D33FFA003171D721D33F305033BC02BCB1936DF86ADEE2F800F00C8006F3E12F43E800C7E903E900C3E09DBC41CBE10D62F24CC20C1B7BE10FE11963C03FE10BE11A04020BC03DC3E185C3E189C3E18DB7E1ABC032000B51D3C02F5007400750074087E4040B4C7C0608410DB1BDCEEBCB81A3E118074DFD66EBCB81CBE111510D57E443E1150CC3E442C3CB8197E80007E18BE80007E18F4CFF4CFCC3E1208AE7E1248AE6C3CB81B007E1A3E1A7E003C042001C1573F00BF84A6EF2E06AD2008308D71820F9012392F84492F845E24130F910F2E065D31F018210556E436CBAF2E068F84601D37F59BAF2E072D401D08308D71820F901F8444130F910F2E06501D430D08308D71820F901F8454130F910F2E06501820020120222301FED31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE2303205D31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE23032F8485280BEF8495250BEB0524BBE1AB0527ABE19210064B05215BE14B05248BE17B0F2E06970F82305C8CB3F5004FA0215F40015CB3F5004FA0212F400CB1F12CA00CA00C9F86AF00C01C31CFC02FE129BACFCB81AF48020C235C6083E4048E4BE1124BE1178904C3E443CB81974C7C0608410DA19D46EBCB81A3E118074DFD66EBCB81CB5007420C235C6083E407E11104C3E443CB81940750C3420C235C6083E407E11504C3E443CB81940602403F71CFC02FE129BACFCB81AF48020C235C6083E4048E4BE1124BE1178904C3E443CB81974C7C0608410DB10DBAEBCB81A3E118074DFD66EBCB81CBD010C3E12B434CFFE803D0134CFFE803D0134C7FE11DBC4148828083E08EE7CB81BBE11DBC4A83E08EF3CB81C34800C151D5A64D6D4C8F7A2B98E82A49B08B8C3816028292A01FCD31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE2303205D31F01821043685374BAF2E068F84601D37F59BAF2E072D33FFA00F404552003D200019AD401D0D33FFA00F40430937F206DE230325339BE5381BEB0F8495250BEB0F8485290BEB02502FE5237BE16B05262BEB0F2E06927C20097F84918BEF2E0699137E222C20097F84813BEF2E0699132E2F84AD0D33FFA00F404D33FFA00F404D31FF8476F105220A0F823BCF2E06FD200D20030B3F2E073209C3537373A5274BC5263BC12B18E11323939395250BC5299BC18B14650134440E25319BAB3F2E06D9130E30D7F05C82627002496F8476F1114A098F8476F1117A00603E203003ECB3F5004FA0215F40012CB3F5004FA0213F400CB1F12CA00CA00C9F86AF00C00620A8020F4966FA5208E213050038020F4666FA1208E1001FA00ED1E15DA119450C3A00B9133E2923430E202926C21E2B31B000C3535075063140038C8CB3F5004FA0212F400CB3F5003FA0213F400CB1FCA00C9F86AF00C00D51D3C02FE129BACFCB81AFE12B434CFFE803D010C74CFFE803D010C74C7CC3E11DBC4283E11DBC4A83E08EE7CB81C7E003E10886808E87E18BE10D400E816287E18FE10F04026BE10BE10E83E189C3E18F7BE10B04026BE10FE10A83E18DC3E18F780693E1A293E1A7C042001F53B7EF4C7C8608419F1F4A06EA4CC7C037808608403818830AEA54C7C03B6CC780C882084155DD61FAEA54C3C0476CC780820841E6849BBEEA54C3C04B6CC7808208407C546B3EEA54C3C0576CC780820840223AA8CAEA54C3C05B6CC7808208419BDBC1A6EA54C3C05F6CC780C60840950CAA46EA53C0636CC78202D0008840FF2F00075BC7FE3A7805FC25E87D007D207D20184100D0CAF6A1EC7C217C21B7817C227C22B7817C237C23FC247C24B7817C2524C3B7818823881B22A021984008DBD0CABA7805FC20C8B870FC253748B8F07C256840206B90FD0018C020EB90FD0018B8EB90E98F987C23B7882908507C11DE491839707C23B788507C23B789507C11DE48B9F03A4331C4966";
class PaymentChannel extends Contract {
    /**
     * @param provider  {HttpProvider}
     * @param options   {{isA: boolean, channelId: BN, myKeyPair: nacl.SignKeyPair, hisPublicKey: Uint8Array, initBalanceA: BN, initBalanceB: BN, addressA: Address, addressB: Address, closingConfig?: {quarantineDuration: number, misbehaviorFine: BN, conditionalCloseDuration: number}, excessFee?: BN}}
     */ constructor(provider, options){
        options.publicKeyA = options.isA ? options.myKeyPair.publicKey : options.hisPublicKey;
        options.publicKeyB = !options.isA ? options.myKeyPair.publicKey : options.hisPublicKey;
        options.wc = options.wc || 0;
        options.code = options.code || Cell.oneFromBoc(PAYMENT_CHANNEL_CODE_HEX);
        super(provider, options);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains payment channel data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeBit(0); // inited
        cell.bits.writeCoins(0); // balance_A
        cell.bits.writeCoins(0); // balance_B
        writePublicKey(cell, this.options.publicKeyA); // key_A
        writePublicKey(cell, this.options.publicKeyB); // key_B
        cell.bits.writeUint(this.options.channelId, 128); // channel_id
        const closingConfig = new Cell();
        closingConfig.bits.writeUint(this.options.closingConfig?.quarantineDuration || 0, 32); // quarantin_duration
        closingConfig.bits.writeCoins(this.options.closingConfig?.misbehaviorFine || new BN(0)); // misbehavior_fine
        closingConfig.bits.writeUint(this.options.closingConfig?.conditionalCloseDuration || 0, 32); // conditional_close_duration
        cell.refs[0] = closingConfig;
        cell.bits.writeUint(0, 32); // commited_seqno_A
        cell.bits.writeUint(0, 32); // commited_seqno_B
        cell.bits.writeBit(false); // quarantin ref
        const paymentConfig = new Cell();
        paymentConfig.bits.writeCoins(this.options.excessFee || new BN(0)); // excess_fee
        paymentConfig.bits.writeAddress(this.options.addressA); // addr_A
        paymentConfig.bits.writeAddress(this.options.addressB); // addr_B
        cell.refs[1] = paymentConfig;
        return cell;
    }
    /**
     * @private
     * @param op    {number}
     * @param cellForSigning    {Cell}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createOneSignature(op, cellForSigning) {
        const signature = nacl.sign.detached(await cellForSigning.hash(), this.options.myKeyPair.secretKey);
        const cell = createOneSignature({
            op,
            isA: this.options.isA,
            signature,
            cell: cellForSigning
        });
        return {
            cell,
            signature
        };
    }
    /**
     * @private
     * @param op    {number}
     * @param hisSignature {Uint8Array}
     * @param cellForSigning    {Cell}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createTwoSignature(op, hisSignature, cellForSigning) {
        const signature = nacl.sign.detached(await cellForSigning.hash(), this.options.myKeyPair.secretKey);
        const signatureA = this.options.isA ? signature : hisSignature;
        const signatureB = !this.options.isA ? signature : hisSignature;
        const cell = createTwoSignature({
            op,
            signatureA,
            signatureB,
            cell: cellForSigning
        });
        return {
            cell,
            signature
        };
    }
    /**
     * @param params    {{coinsA: BN, coinsB: BN}}
     * @returns {Promise<Cell>}
     */ async createTopUpBalance(params) {
        return createTopUpBalance(params);
    }
    /**
     * @param params    {{balanceA: BN, balanceB: BN}}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createInitChannel(params) {
        return this.createOneSignature(op_init_channel, createInitChannelBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @param params    {{hisSignature?: Uint8Array, balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createCooperativeCloseChannel(params) {
        if (!params.hisSignature) params.hisSignature = new Uint8Array(64);
        return this.createTwoSignature(op_cooperative_close, params.hisSignature, createCooperativeCloseChannelBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @param params    {{hisSignature?: Uint8Array, seqnoA: BN, seqnoB: BN}}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createCooperativeCommit(params) {
        if (!params.hisSignature) params.hisSignature = new Uint8Array(64);
        return this.createTwoSignature(op_cooperative_commit, params.hisSignature, createCooperativeCommitBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @private
     * @param params    {{mySeqno: BN, mySentCoins: BN, hisSeqno?: BN, hisSentCoins?: BN}}
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createSignedSemiChannelState(params) {
        const state = createSemiChannelState({
            channelId: this.options.channelId,
            semiChannelBody: createSemiChannelBody({
                seqno: params.mySeqno,
                sentCoins: params.mySentCoins,
                conditionals: null
            }),
            counterpartySemiChannelBody: params.hisSeqno === undefined ? null : createSemiChannelBody({
                seqno: params.hisSeqno,
                sentCoins: params.hisSentCoins,
                conditionals: null
            })
        });
        const signature = nacl.sign.detached(await state.hash(), this.options.myKeyPair.secretKey);
        const cell = createSignedSemiChannelState({
            signature,
            state
        });
        return {
            cell,
            signature
        };
    }
    /**
     * @param params    {{balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
     * @returns {Promise<Uint8Array>} signature
     */ async signState(params) {
        const mySeqno = this.options.isA ? params.seqnoA : params.seqnoB;
        const hisSeqno = !this.options.isA ? params.seqnoA : params.seqnoB;
        const sentCoinsA = this.options.initBalanceA.gt(params.balanceA) ? this.options.initBalanceA.sub(params.balanceA) : new BN(0);
        const sentCoinsB = this.options.initBalanceB.gt(params.balanceB) ? this.options.initBalanceB.sub(params.balanceB) : new BN(0);
        const mySentCoins = this.options.isA ? sentCoinsA : sentCoinsB;
        const hisSentCoins = !this.options.isA ? sentCoinsA : sentCoinsB;
        const { cell , signature  } = await this.createSignedSemiChannelState({
            mySeqno,
            mySentCoins,
            hisSeqno,
            hisSentCoins
        });
        return signature;
    }
    /**
     * @param params    {{balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
     * @param hisSignature  {Uint8Array}
     * @returns {Promise<boolean>}
     */ async verifyState(params, hisSignature) {
        const mySeqno = !this.options.isA ? params.seqnoA : params.seqnoB;
        const hisSeqno = this.options.isA ? params.seqnoA : params.seqnoB;
        const sentCoinsA = this.options.initBalanceA.gt(params.balanceA) ? this.options.initBalanceA.sub(params.balanceA) : new BN(0);
        const sentCoinsB = this.options.initBalanceB.gt(params.balanceB) ? this.options.initBalanceB.sub(params.balanceB) : new BN(0);
        const mySentCoins = !this.options.isA ? sentCoinsA : sentCoinsB;
        const hisSentCoins = this.options.isA ? sentCoinsA : sentCoinsB;
        const state = createSemiChannelState({
            channelId: this.options.channelId,
            semiChannelBody: createSemiChannelBody({
                seqno: mySeqno,
                sentCoins: mySentCoins,
                conditionals: null
            }),
            counterpartySemiChannelBody: hisSeqno === undefined ? null : createSemiChannelBody({
                seqno: hisSeqno,
                sentCoins: hisSentCoins,
                conditionals: null
            })
        });
        const hash = await state.hash();
        return nacl.sign.detached.verify(hash, hisSignature, this.options.isA ? this.options.publicKeyB : this.options.publicKeyA);
    }
    /**
     * @param params    {{balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
     * @return {Uint8Array} signature
     */ async signClose(params) {
        const { cell , signature  } = await this.createCooperativeCloseChannel(params);
        return signature;
    }
    /**
     * @param params    {{balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
     * @param hisSignature {Uint8Array}
     * @return {boolean}
     */ async verifyClose(params, hisSignature) {
        const cell = await createCooperativeCloseChannelBody({
            ...params,
            channelId: this.options.channelId
        });
        const hash = await cell.hash();
        return nacl.sign.detached.verify(hash, hisSignature, this.options.isA ? this.options.publicKeyB : this.options.publicKeyA);
    }
    /**
     * @param params    {{signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}} `signedSemiChannelState` created by `createSignedSemiChannelState`
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createStartUncooperativeClose(params) {
        return this.createOneSignature(op_start_uncooperative_close, createStartUncooperativeCloseBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @param params   {{signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}} `signedSemiChannelState` created by `createSignedSemiChannelState`
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createChallengeQuarantinedState(params) {
        return this.createOneSignature(op_challenge_quarantined_state, createChallengeQuarantinedStateBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @param params    {{conditionalsToSettle: Cell | null}} dictionary with uint32 keys and values created by `createConditionalPayment`
     * @returns {Promise<{cell: Cell, signature: Uint8Array}>}
     */ async createSettleConditionals(params) {
        return this.createOneSignature(op_settle_conditionals, createSettleConditionalsBody({
            ...params,
            channelId: this.options.channelId
        }));
    }
    /**
     * @returns {Promise<Cell>}
     */ async createFinishUncooperativeClose() {
        return createFinishUncooperativeClose();
    }
    static STATE_UNINITED = 0;
    static STATE_OPEN = 1;
    static STATE_CLOSURE_STARTED = 2;
    static STATE_SETTLING_CONDITIONALS = 3;
    static STATE_AWAITING_FINALIZATION = 4;
    /**
     * @returns {Promise<number>}
     */ async getChannelState() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_channel_state", []);
        return result.toNumber();
    }
    /**
     * @returns {Promise<{state: number, balanceA: BN, balanceB: BN, publicKeyA: Uint8Array, publicKeyB: Uint8Array, channelId: BN, quarantineDuration: number, misbehaviorFine: BN, conditionalCloseDuration: number, seqnoA: BN, seqnoB: BN, quarantine: Cell, excessFee: BN, addressA: Address, addressB: Address}>}
     */ async getData() {
        /**
         * @param bn    {BN}
         * @return  {Uint8Array}
         */ const bnToBytes = (bn)=>{
            let hex = bn.toString(16);
            if (hex.length % 2 !== 0) hex = "0" + hex;
            return hexToBytes(hex);
        };
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_channel_data", []);
        const state = result[0].toNumber();
        const balanceA = result[1][0];
        const balanceB = result[1][1];
        const publicKeyA = bnToBytes(result[2][0]);
        const publicKeyB = bnToBytes(result[2][1]);
        const channelId = result[3];
        const quarantineDuration = result[4][0].toNumber();
        const misbehaviorFine = result[4][1];
        const conditionalCloseDuration = result[4][2].toNumber();
        const seqnoA = result[5][0];
        const seqnoB = result[5][1];
        const quarantine = result[6]; // Cell
        const excessFee = result[7][0];
        const addressA = parseAddress(result[7][1]);
        const addressB = parseAddress(result[7][2]);
        return {
            state,
            balanceA,
            balanceB,
            publicKeyA,
            publicKeyB,
            channelId,
            quarantineDuration,
            misbehaviorFine,
            conditionalCloseDuration,
            seqnoA,
            seqnoB,
            quarantine,
            excessFee,
            addressA,
            addressB
        };
    }
    /**
     * @param params {{wallet: WalletContract, secretKey: Uint8Array}}
     * @return {{deploy: Function, init: Function, topUp: Function, close: Function, commit: Function, startUncooperativeClose: Function, challengeQuarantinedState: Function, settleConditionals: Function, finishUncooperativeClose: Function}}
     */ fromWallet(params1) {
        const { wallet , secretKey  } = params1;
        const transfer = (payloadPromise, needStateInit)=>{
            const createPromise = async (amount)=>{
                const stateInit = needStateInit ? (await this.createStateInit()).stateInit : null;
                const myAddress = await this.getAddress();
                const seqno = await wallet.methods.seqno().call() || 0;
                const payload = await payloadPromise;
                return wallet.methods.transfer({
                    secretKey: secretKey,
                    toAddress: myAddress.toString(true, true, true),
                    amount: amount,
                    seqno: seqno,
                    payload,
                    stateInit,
                    sendMode: 3
                });
            };
            return {
                /**
                 * @param amount    {BN}    in Toncoins
                 */ send: (amount)=>{
                    return createPromise(amount).then((x)=>x.send());
                },
                /**
                 * @param amount    {BN}    in Toncoins
                 */ estimateFee: (amount)=>{
                    return createPromise(amount).then((x)=>x.estimateFee());
                }
            };
        };
        return {
            deploy: ()=>{
                return transfer(null, true);
            },
            /**
             * @param params    {{balanceA: BN, balanceB: BN}}
             */ init: (params)=>{
                return transfer(this.createInitChannel(params).then((x)=>x.cell));
            },
            /**
             * @param params    {{coinsA: BN, coinsB: BN}}
             */ topUp: (params)=>{
                return transfer(this.createTopUpBalance(params));
            },
            /**
             * @param params    {{hisSignature: Uint8Array, balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
             */ close: (params)=>{
                return transfer(this.createCooperativeCloseChannel(params).then((x)=>x.cell));
            },
            /**
             * @param params    {{hisSignature: Uint8Array, seqnoA: BN, seqnoB: BN}}
             */ commit: (params)=>{
                return transfer(this.createCooperativeCommit(params).then((x)=>x.cell));
            },
            /**
             * @param params    {{signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}}
             */ startUncooperativeClose: (params)=>{
                return transfer(this.createStartUncooperativeClose(params).then((x)=>x.cell));
            },
            /**
             * @param params    {{signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}}
             */ challengeQuarantinedState: (params)=>{
                return transfer(this.createChallengeQuarantinedState(params).then((x)=>x.cell));
            },
            /**
             * @param params    {{conditionalsToSettle: Cell | null}}
             */ settleConditionals: (params)=>{
                return transfer(this.createSettleConditionals(params).then((x)=>x.cell));
            },
            /**
             */ finishUncooperativeClose: ()=>{
                return transfer(this.createFinishUncooperativeClose());
            }
        };
    }
}
PaymentChannel.codeHex = PAYMENT_CHANNEL_CODE_HEX;
module.exports = {
    PaymentChannel
};

},{"../index":"drIoA","../../boc":"4fqdK","../../utils":"57M1Z","../token/nft/NftUtils":"fLfHN","./PaymentUtils":"bWUUk"}],"bWUUk":[function(require,module,exports) {
const { Cell  } = require("../../boc");
/**
 * @param cell  {Cell}
 * @param publicKey {Uint8Array}
 */ const writePublicKey = (cell, publicKey)=>{
    if (publicKey.length !== 32) throw new Error("invalid publicKey length");
    cell.bits.writeBytes(publicKey);
};
/**
 * @param cell  {Cell}
 * @param signature {Uint8Array}
 */ const writeSignature = (cell, signature)=>{
    if (signature.length !== 64) throw new Error("invalid signature length");
    cell.bits.writeBytes(signature);
};
/**
 * @param signature {Uint8Array}
 * @returns {Cell}
 */ const createSignatureCell = (signature)=>{
    const cell = new Cell();
    writeSignature(cell, signature);
    return cell;
};
/**
 * @param cell  {Cell}
 * @param ref   {Cell}
 */ const writeMayBe = (cell, ref)=>{
    if (ref) {
        cell.bits.writeBit(1);
        if (cell.refs.length >= 4) throw new Error("refs overflow");
        cell.refs.push(ref);
    } else cell.bits.writeBit(0);
};
/**
 * @param cell  {Cell}
 * @param ref   {Cell}
 */ const writeDict = writeMayBe;
const tag_init = 0x696e6974;
const tag_cooperative_close = 0x436c6f73;
const tag_cooperative_commit = 0x43436d74;
const tag_start_uncooperative_close = 0x556e436c;
const tag_challenge_state = 0x43686751;
const tag_settle_conditionals = 0x436c436e;
const tag_state = 0x43685374;
const op_top_up_balance = 1741148801; // crc32("top_up_balance add_A:Coins add_B:Coins = InternalMsgBody");
const op_init_channel = 235282626; // crc32("init_channel is_A:Bool signature:bits512 tag:# = tag 1768843636 channel_id:uint128 balance_A:Coins balance_B:Coins = InternalMsgBody");
const op_cooperative_close = 1433884798; // crc32("cooperative_close sig_A:^bits512 sig_B:^bits512 tag:# = tag 1131179891 channel_id:uint128 balance_A:Coins balance_B:Coins seqno_A:uint64 seqno_B:uint64 = InternalMsgBody");
const op_cooperative_commit = 2040604399; // crc32("cooperative_commit sig_A:^bits512 sig_B:^bits512 tag:# = tag 1128492404 channel_id:uint128 seqno_A:uint64 seqno_B:uint64 = InternalMsgBody");
const op_start_uncooperative_close = 521476815; // crc32("start_uncooperative_close signed_by_A:Bool signature:bits512 tag:# = tag 1433289580 channel_id:uint128 sch_A:^SignedSemiChannel sch_B:^SignedSemiChannel = InternalMsgBody");
const op_challenge_quarantined_state = 143567410; // crc32("challenge_quarantined_state challenged_by_A:Bool signature:bits512 tag:# = tag 1130915665 channel_id:uint128 sch_A:^SignedSemiChannel sch_B:^SignedSemiChannel = InternalMsgBody");
const op_settle_conditionals = 1727459433; // crc32("settle_conditionals from_A:Bool signature:bits512 tag:# = tag 1131168622 channel_id:uint128 conditionals_to_settle:HashmapE 32 Cell = InternalMsgBody");
const op_finish_uncooperative_close = 625158801; // crc32("finish_uncooperative_close = InternalMsgBody");
const op_channel_closed = -572749638; // crc32("channel_closed channel_id:uint128 = InternalMsgBody");
/**
 * @param params    {{coinsA: BN, coinsB: BN}}
 * @returns {Cell}
 */ const createTopUpBalance = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(op_top_up_balance, 32); // OP
    cell.bits.writeCoins(params.coinsA);
    cell.bits.writeCoins(params.coinsB);
    return cell;
};
/**
 * @param params    {{channelId: BN, balanceA: BN, balanceB: BN}}
 * @returns {Cell}
 */ const createInitChannelBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_init, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.bits.writeCoins(params.balanceA);
    cell.bits.writeCoins(params.balanceB);
    return cell;
};
/**
 * @param params    {{channelId: BN, balanceA: BN, balanceB: BN, seqnoA: BN, seqnoB: BN}}
 * @returns {Cell}
 */ const createCooperativeCloseChannelBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_cooperative_close, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.bits.writeCoins(params.balanceA);
    cell.bits.writeCoins(params.balanceB);
    cell.bits.writeUint(params.seqnoA, 64);
    cell.bits.writeUint(params.seqnoB, 64);
    return cell;
};
/**
 * @param params    {{channelId: BN, seqnoA: BN, seqnoB: BN}}
 * @returns {Cell}
 */ const createCooperativeCommitBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_cooperative_commit, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.bits.writeUint(params.seqnoA, 64);
    cell.bits.writeUint(params.seqnoB, 64);
    return cell;
};
/**
 * @param params    {{amount: BN, condition: Cell}} condition is code
 * @returns {Cell}
 */ const createConditionalPayment = (params)=>{
    const cell = new Cell();
    cell.bits.writeCoins(params.amount);
    cell.writeCell(params.condition);
    return cell;
};
/**
 * @param params    {{seqno: BN, sentCoins: BN, conditionals: Cell | null}} conditionals - dictionary with uint32 keys and values created by `createConditionalPayment`
 * @returns {Cell}
 */ const createSemiChannelBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(params.seqno, 64); // body start
    cell.bits.writeCoins(params.sentCoins);
    writeDict(cell, params.conditionals); // HashmapE 32 ConditionalPayment
    return cell;
};
/**
 * @param params    {{channelId: BN, semiChannelBody: Cell, counterpartySemiChannelBody?: Cell}} created by `createSemiChannelBody`
 * @returns {Cell}
 */ const createSemiChannelState = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_state, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.writeCell(params.semiChannelBody);
    writeMayBe(cell, params.counterpartySemiChannelBody);
    return cell;
};
/**
 * @param params    {{signature: Uint8Array, state: Cell}}  `state` created by `createSemiChannelState`
 */ const createSignedSemiChannelState = (params)=>{
    const cell = new Cell();
    writeSignature(cell, params.signature);
    cell.writeCell(params.state);
    return cell;
};
/**
 * @param params    {{channelId: BN, signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}} `signedSemiChannelState` created by `createSignedSemiChannelState`
 * @returns {Cell}
 */ const createStartUncooperativeCloseBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_start_uncooperative_close, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.refs[0] = params.signedSemiChannelStateA;
    cell.refs[1] = params.signedSemiChannelStateB;
    return cell;
};
/**
 * @param params    {{channelId: BN, signedSemiChannelStateA: Cell, signedSemiChannelStateB: Cell}} `signedSemiChannelState` created by `createSignedSemiChannelState`
 * @returns {Cell}
 */ const createChallengeQuarantinedStateBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_challenge_state, 32);
    cell.bits.writeUint(params.channelId, 128);
    cell.refs[0] = params.signedSemiChannelStateA;
    cell.refs[1] = params.signedSemiChannelStateB;
    return cell;
};
/**
 * @param params    {{channelId: BN, conditionalsToSettle: Cell | null}} conditionalsToSettle - dictionary with uint32 keys and values created by `createConditionalPayment`
 * @returns {Cell}
 */ const createSettleConditionalsBody = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(tag_settle_conditionals, 32);
    cell.bits.writeUint(params.channelId, 128);
    writeDict(cell, params.conditionalsToSettle); // HashmapE 32 Cell
    return cell;
};
/**
 * @returns {Cell}
 */ const createFinishUncooperativeClose = ()=>{
    const cell = new Cell();
    cell.bits.writeUint(op_finish_uncooperative_close, 32); // OP
    return cell;
};
/**
 * @param params    {{op: number, isA: boolean, signature: Uint8Array, cell: Cell}}
 * @return {Cell}
 */ const createOneSignature = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(params.op, 32); // OP
    cell.bits.writeBit(params.isA);
    writeSignature(cell, params.signature);
    cell.writeCell(params.cell);
    return cell;
};
/**
 * @param params    {{op: number, signatureA: Uint8Array, signatureB: Uint8Array, cell: Cell}}
 * @return {Cell}
 */ const createTwoSignature = (params)=>{
    const cell = new Cell();
    cell.bits.writeUint(params.op, 32); // OP
    cell.refs[0] = createSignatureCell(params.signatureA);
    cell.refs[1] = createSignatureCell(params.signatureB);
    cell.writeCell(params.cell);
    return cell;
};
module.exports = {
    writePublicKey,
    writeSignature,
    createSignatureCell,
    tag_init,
    tag_cooperative_close,
    tag_cooperative_commit,
    tag_start_uncooperative_close,
    tag_challenge_state,
    tag_settle_conditionals,
    tag_state,
    op_top_up_balance,
    op_init_channel,
    op_cooperative_close,
    op_cooperative_commit,
    op_start_uncooperative_close,
    op_challenge_quarantined_state,
    op_settle_conditionals,
    op_finish_uncooperative_close,
    op_channel_closed,
    createTopUpBalance,
    createInitChannelBody,
    createCooperativeCloseChannelBody,
    createCooperativeCommitBody,
    createConditionalPayment,
    createSemiChannelBody,
    createSemiChannelState,
    createSignedSemiChannelState,
    createStartUncooperativeCloseBody,
    createChallengeQuarantinedStateBody,
    createSettleConditionalsBody,
    createFinishUncooperativeClose,
    createOneSignature,
    createTwoSignature
};

},{"../../boc":"4fqdK"}],"9zmIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hwTransport = require("@ledgerhq/hw-transport");
var _hwTransportDefault = parcelHelpers.interopDefault(_hwTransport);
var _hidFraming = require("@ledgerhq/devices/lib/hid-framing");
var _hidFramingDefault = parcelHelpers.interopDefault(_hidFraming);
var _devices = require("@ledgerhq/devices");
var _logs = require("@ledgerhq/logs");
var _errors = require("@ledgerhq/errors");
var _webusb = require("./webusb");
var Buffer = require("buffer").Buffer;
const configurationValue = 1;
const endpointNumber = 3;
class TransportWebUSB extends (0, _hwTransportDefault.default) {
    constructor(device, interfaceNumber){
        super();
        this.device = void 0;
        this.deviceModel = void 0;
        this.channel = Math.floor(Math.random() * 0xffff);
        this.packetSize = 64;
        this.interfaceNumber = void 0;
        this._disconnectEmitted = false;
        this._emitDisconnect = (e)=>{
            if (this._disconnectEmitted) return;
            this._disconnectEmitted = true;
            this.emit("disconnect", e);
        };
        this.exchange = (apdu)=>this.exchangeAtomicImpl(async ()=>{
                const { channel , packetSize  } = this;
                (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));
                const framing = (0, _hidFramingDefault.default)(channel, packetSize); // Write...
                const blocks = framing.makeBlocks(apdu);
                for(let i = 0; i < blocks.length; i++)await this.device.transferOut(endpointNumber, blocks[i]);
                 // Read...
                let result;
                let acc;
                while(!(result = framing.getReducedResult(acc))){
                    const r = await this.device.transferIn(endpointNumber, packetSize);
                    const buffer = Buffer.from(r.data.buffer);
                    acc = framing.reduceResponse(acc, buffer);
                }
                (0, _logs.log)("apdu", "<= " + result.toString("hex"));
                return result;
            }).catch((e)=>{
                if (e && e.message && e.message.includes("disconnected")) {
                    this._emitDisconnect(e);
                    throw new (0, _errors.DisconnectedDeviceDuringOperation)(e.message);
                }
                throw e;
            });
        this.device = device;
        this.interfaceNumber = interfaceNumber;
        this.deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    }
    /**
   * Check if WebUSB transport is supported.
   */ /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */ static async request() {
        const device = await (0, _webusb.requestLedgerDevice)();
        return TransportWebUSB.open(device);
    }
    /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */ static async openConnected() {
        const devices = await (0, _webusb.getLedgerDevices)();
        if (devices.length === 0) return null;
        return TransportWebUSB.open(devices[0]);
    }
    /**
   * Create a Ledger transport with a USBDevice
   */ static async open(device) {
        await device.open();
        if (device.configuration === null) await device.selectConfiguration(configurationValue);
        await gracefullyResetDevice(device);
        const iface = device.configurations[0].interfaces.find(({ alternates  })=>alternates.some((a)=>a.interfaceClass === 255));
        if (!iface) throw new (0, _errors.TransportInterfaceNotAvailable)("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
        const interfaceNumber = iface.interfaceNumber;
        try {
            await device.claimInterface(interfaceNumber);
        } catch (e1) {
            await device.close();
            throw new (0, _errors.TransportInterfaceNotAvailable)(e1.message);
        }
        const transport = new TransportWebUSB(device, interfaceNumber);
        const onDisconnect = (e)=>{
            if (device === e.device) {
                // $FlowFixMe
                navigator.usb.removeEventListener("disconnect", onDisconnect);
                transport._emitDisconnect(new (0, _errors.DisconnectedDevice)());
            }
        }; // $FlowFixMe
        navigator.usb.addEventListener("disconnect", onDisconnect);
        return transport;
    }
    /**
   * Release the transport device
   */ async close() {
        await this.exchangeBusyPromise;
        await this.device.releaseInterface(this.interfaceNumber);
        await gracefullyResetDevice(this.device);
        await this.device.close();
    }
    /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */ setScrambleKey() {}
}
exports.default = TransportWebUSB;
TransportWebUSB.isSupported = (0, _webusb.isSupported);
TransportWebUSB.list = (0, _webusb.getLedgerDevices);
TransportWebUSB.listen = (observer)=>{
    let unsubscribed = false;
    (0, _webusb.getFirstLedgerDevice)().then((device)=>{
        if (!unsubscribed) {
            const deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
            observer.next({
                type: "add",
                descriptor: device,
                deviceModel
            });
            observer.complete();
        }
    }, (error)=>{
        if (window.DOMException && error instanceof window.DOMException && error.code === 18) observer.error(new (0, _errors.TransportWebUSBGestureRequired)(error.message));
        else observer.error(new (0, _errors.TransportOpenUserCancelled)(error.message));
    });
    function unsubscribe() {
        unsubscribed = true;
    }
    return {
        unsubscribe
    };
};
async function gracefullyResetDevice(device) {
    try {
        await device.reset();
    } catch (err) {
        console.warn(err);
    }
}

},{"@ledgerhq/hw-transport":"59Ey9","@ledgerhq/devices/lib/hid-framing":"fvgJh","@ledgerhq/devices":"fnHxP","@ledgerhq/logs":"i4OI0","@ledgerhq/errors":"e0rTV","./webusb":"7NNG8","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59Ey9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransportError", ()=>(0, _errors.TransportError));
parcelHelpers.export(exports, "TransportStatusError", ()=>(0, _errors.TransportStatusError));
parcelHelpers.export(exports, "StatusCodes", ()=>(0, _errors.StatusCodes));
parcelHelpers.export(exports, "getAltStatusMessage", ()=>(0, _errors.getAltStatusMessage));
var _events = require("events");
var _eventsDefault = parcelHelpers.interopDefault(_events);
var _errors = require("@ledgerhq/errors");
var Buffer = require("buffer").Buffer;
class Transport {
    constructor(){
        this.exchangeTimeout = 30000;
        this.unresponsiveTimeout = 15000;
        this.deviceModel = null;
        this._events = new (0, _eventsDefault.default)();
        this.send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [
            (0, _errors.StatusCodes).OK
        ])=>{
            if (data.length >= 256) throw new (0, _errors.TransportError)("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
            const response = await this.exchange(Buffer.concat([
                Buffer.from([
                    cla,
                    ins,
                    p1,
                    p2
                ]),
                Buffer.from([
                    data.length
                ]),
                data
            ]));
            const sw = response.readUInt16BE(response.length - 2);
            if (!statusList.some((s)=>s === sw)) throw new (0, _errors.TransportStatusError)(sw);
            return response;
        };
        this.exchangeBusyPromise = void 0;
        this.exchangeAtomicImpl = async (f)=>{
            if (this.exchangeBusyPromise) throw new (0, _errors.TransportRaceCondition)("An action was already pending on the Ledger device. Please deny or reconnect.");
            let resolveBusy;
            const busyPromise = new Promise((r)=>{
                resolveBusy = r;
            });
            this.exchangeBusyPromise = busyPromise;
            let unresponsiveReached = false;
            const timeout = setTimeout(()=>{
                unresponsiveReached = true;
                this.emit("unresponsive");
            }, this.unresponsiveTimeout);
            try {
                const res = await f();
                if (unresponsiveReached) this.emit("responsive");
                return res;
            } finally{
                clearTimeout(timeout);
                if (resolveBusy) resolveBusy();
                this.exchangeBusyPromise = null;
            }
        };
        this._appAPIlock = null;
    }
    /**
   * low level api to communicate with the device
   * This method is for implementations to implement but should not be directly called.
   * Instead, the recommanded way is to use send() method
   * @param apdu the data to send
   * @return a Promise of response data
   */ exchange(_apdu) {
        throw new Error("exchange not implemented");
    }
    /**
   * set the "scramble key" for the next exchanges with the device.
   * Each App can have a different scramble key and they internally will set it at instanciation.
   * @param key the scramble key
   */ setScrambleKey(_key) {}
    /**
   * close the exchange with the device.
   * @return a Promise that ends when the transport is closed.
   */ close() {
        return Promise.resolve();
    }
    /**
   * Listen to an event on an instance of transport.
   * Transport implementation can have specific events. Here is the common events:
   * * `"disconnect"` : triggered if Transport is disconnected
   */ on(eventName, cb) {
        this._events.on(eventName, cb);
    }
    /**
   * Stop listening to an event on an instance of transport.
   */ off(eventName, cb) {
        this._events.removeListener(eventName, cb);
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
    }
    /**
   * Enable or not logs of the binary exchange
   */ setDebugMode() {
        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    }
    /**
   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
   */ setExchangeTimeout(exchangeTimeout) {
        this.exchangeTimeout = exchangeTimeout;
    }
    /**
   * Define the delay before emitting "unresponsive" on an exchange that does not respond
   */ setExchangeUnresponsiveTimeout(unresponsiveTimeout) {
        this.unresponsiveTimeout = unresponsiveTimeout;
    }
    /**
   * wrapper on top of exchange to simplify work of the implementation.
   * @param cla
   * @param ins
   * @param p1
   * @param p2
   * @param data
   * @param statusList is a list of accepted status code (shorts). [0x9000] by default
   * @return a Promise of response buffer
   */ /**
   * create() allows to open the first descriptor available or
   * throw if there is none or if timeout is reached.
   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
   * @example
  TransportFoo.create().then(transport => ...)
   */ static create(openTimeout = 3000, listenTimeout) {
        return new Promise((resolve, reject)=>{
            let found = false;
            const sub = this.listen({
                next: (e)=>{
                    found = true;
                    if (sub) sub.unsubscribe();
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    this.open(e.descriptor, openTimeout).then(resolve, reject);
                },
                error: (e)=>{
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    reject(e);
                },
                complete: ()=>{
                    if (listenTimeoutId) clearTimeout(listenTimeoutId);
                    if (!found) reject(new (0, _errors.TransportError)(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                }
            });
            const listenTimeoutId = listenTimeout ? setTimeout(()=>{
                sub.unsubscribe();
                reject(new (0, _errors.TransportError)(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
            }, listenTimeout) : null;
        });
    }
    decorateAppAPIMethods(self, methods, scrambleKey) {
        for (let methodName of methods)self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
    }
    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
        return async (...args)=>{
            const { _appAPIlock  } = this;
            if (_appAPIlock) return Promise.reject(new (0, _errors.TransportError)("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"));
            try {
                this._appAPIlock = methodName;
                this.setScrambleKey(scrambleKey);
                return await f.apply(ctx, args);
            } finally{
                this._appAPIlock = null;
            }
        };
    }
}
exports.default = Transport;
Transport.isSupported = void 0;
Transport.list = void 0;
Transport.listen = void 0;
Transport.open = void 0;
Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";

},{"events":"1VQLm","@ledgerhq/errors":"e0rTV","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VQLm":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"e0rTV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountNameRequiredError", ()=>AccountNameRequiredError);
parcelHelpers.export(exports, "AccountNotSupported", ()=>AccountNotSupported);
parcelHelpers.export(exports, "AmountRequired", ()=>AmountRequired);
parcelHelpers.export(exports, "BluetoothRequired", ()=>BluetoothRequired);
parcelHelpers.export(exports, "BtcUnmatchedApp", ()=>BtcUnmatchedApp);
parcelHelpers.export(exports, "CantOpenDevice", ()=>CantOpenDevice);
parcelHelpers.export(exports, "CantScanQRCode", ()=>CantScanQRCode);
parcelHelpers.export(exports, "CashAddrNotSupported", ()=>CashAddrNotSupported);
parcelHelpers.export(exports, "CurrencyNotSupported", ()=>CurrencyNotSupported);
parcelHelpers.export(exports, "DBNotReset", ()=>DBNotReset);
parcelHelpers.export(exports, "DBWrongPassword", ()=>DBWrongPassword);
parcelHelpers.export(exports, "DeviceAppVerifyNotSupported", ()=>DeviceAppVerifyNotSupported);
parcelHelpers.export(exports, "DeviceGenuineSocketEarlyClose", ()=>DeviceGenuineSocketEarlyClose);
parcelHelpers.export(exports, "DeviceHalted", ()=>DeviceHalted);
parcelHelpers.export(exports, "DeviceInOSUExpected", ()=>DeviceInOSUExpected);
parcelHelpers.export(exports, "DeviceNameInvalid", ()=>DeviceNameInvalid);
parcelHelpers.export(exports, "DeviceNotGenuineError", ()=>DeviceNotGenuineError);
parcelHelpers.export(exports, "DeviceOnDashboardExpected", ()=>DeviceOnDashboardExpected);
parcelHelpers.export(exports, "DeviceOnDashboardUnexpected", ()=>DeviceOnDashboardUnexpected);
parcelHelpers.export(exports, "DeviceShouldStayInApp", ()=>DeviceShouldStayInApp);
parcelHelpers.export(exports, "DeviceSocketFail", ()=>DeviceSocketFail);
parcelHelpers.export(exports, "DeviceSocketNoBulkStatus", ()=>DeviceSocketNoBulkStatus);
parcelHelpers.export(exports, "DisconnectedDevice", ()=>DisconnectedDevice);
parcelHelpers.export(exports, "DisconnectedDeviceDuringOperation", ()=>DisconnectedDeviceDuringOperation);
parcelHelpers.export(exports, "ETHAddressNonEIP", ()=>ETHAddressNonEIP);
parcelHelpers.export(exports, "EnpointConfigError", ()=>EnpointConfigError);
parcelHelpers.export(exports, "EthAppPleaseEnableContractData", ()=>EthAppPleaseEnableContractData);
parcelHelpers.export(exports, "FeeEstimationFailed", ()=>FeeEstimationFailed);
parcelHelpers.export(exports, "FeeNotLoaded", ()=>FeeNotLoaded);
parcelHelpers.export(exports, "FeeRequired", ()=>FeeRequired);
parcelHelpers.export(exports, "FeeTooHigh", ()=>FeeTooHigh);
parcelHelpers.export(exports, "FirmwareNotRecognized", ()=>FirmwareNotRecognized);
parcelHelpers.export(exports, "FirmwareOrAppUpdateRequired", ()=>FirmwareOrAppUpdateRequired);
parcelHelpers.export(exports, "GasLessThanEstimate", ()=>GasLessThanEstimate);
parcelHelpers.export(exports, "GenuineCheckFailed", ()=>GenuineCheckFailed);
parcelHelpers.export(exports, "HardResetFail", ()=>HardResetFail);
parcelHelpers.export(exports, "InvalidAddress", ()=>InvalidAddress);
parcelHelpers.export(exports, "InvalidAddressBecauseDestinationIsAlsoSource", ()=>InvalidAddressBecauseDestinationIsAlsoSource);
parcelHelpers.export(exports, "InvalidXRPTag", ()=>InvalidXRPTag);
parcelHelpers.export(exports, "LatestMCUInstalledError", ()=>LatestMCUInstalledError);
parcelHelpers.export(exports, "LedgerAPI4xx", ()=>LedgerAPI4xx);
parcelHelpers.export(exports, "LedgerAPI5xx", ()=>LedgerAPI5xx);
parcelHelpers.export(exports, "LedgerAPIError", ()=>LedgerAPIError);
parcelHelpers.export(exports, "LedgerAPIErrorWithMessage", ()=>LedgerAPIErrorWithMessage);
parcelHelpers.export(exports, "LedgerAPINotAvailable", ()=>LedgerAPINotAvailable);
parcelHelpers.export(exports, "MCUNotGenuineToDashboard", ()=>MCUNotGenuineToDashboard);
parcelHelpers.export(exports, "ManagerAppAlreadyInstalledError", ()=>ManagerAppAlreadyInstalledError);
parcelHelpers.export(exports, "ManagerAppDepInstallRequired", ()=>ManagerAppDepInstallRequired);
parcelHelpers.export(exports, "ManagerAppDepUninstallRequired", ()=>ManagerAppDepUninstallRequired);
parcelHelpers.export(exports, "ManagerAppRelyOnBTCError", ()=>ManagerAppRelyOnBTCError);
parcelHelpers.export(exports, "ManagerDeviceLockedError", ()=>ManagerDeviceLockedError);
parcelHelpers.export(exports, "ManagerFirmwareNotEnoughSpaceError", ()=>ManagerFirmwareNotEnoughSpaceError);
parcelHelpers.export(exports, "ManagerNotEnoughSpaceError", ()=>ManagerNotEnoughSpaceError);
parcelHelpers.export(exports, "ManagerUninstallBTCDep", ()=>ManagerUninstallBTCDep);
parcelHelpers.export(exports, "NetworkDown", ()=>NetworkDown);
parcelHelpers.export(exports, "NoAccessToCamera", ()=>NoAccessToCamera);
parcelHelpers.export(exports, "NoAddressesFound", ()=>NoAddressesFound);
parcelHelpers.export(exports, "NoDBPathGiven", ()=>NoDBPathGiven);
parcelHelpers.export(exports, "NotEnoughBalance", ()=>NotEnoughBalance);
parcelHelpers.export(exports, "NotEnoughBalanceBecauseDestinationNotCreated", ()=>NotEnoughBalanceBecauseDestinationNotCreated);
parcelHelpers.export(exports, "NotEnoughBalanceInParentAccount", ()=>NotEnoughBalanceInParentAccount);
parcelHelpers.export(exports, "NotEnoughBalanceToDelegate", ()=>NotEnoughBalanceToDelegate);
parcelHelpers.export(exports, "NotEnoughGas", ()=>NotEnoughGas);
parcelHelpers.export(exports, "NotEnoughSpendableBalance", ()=>NotEnoughSpendableBalance);
parcelHelpers.export(exports, "NotSupportedLegacyAddress", ()=>NotSupportedLegacyAddress);
parcelHelpers.export(exports, "PairingFailed", ()=>PairingFailed);
parcelHelpers.export(exports, "PasswordIncorrectError", ()=>PasswordIncorrectError);
parcelHelpers.export(exports, "PasswordsDontMatchError", ()=>PasswordsDontMatchError);
parcelHelpers.export(exports, "RecipientRequired", ()=>RecipientRequired);
parcelHelpers.export(exports, "RecommendSubAccountsToEmpty", ()=>RecommendSubAccountsToEmpty);
parcelHelpers.export(exports, "RecommendUndelegation", ()=>RecommendUndelegation);
parcelHelpers.export(exports, "StatusCodes", ()=>StatusCodes);
parcelHelpers.export(exports, "SyncError", ()=>SyncError);
parcelHelpers.export(exports, "TimeoutTagged", ()=>TimeoutTagged);
parcelHelpers.export(exports, "TransportError", ()=>TransportError);
parcelHelpers.export(exports, "TransportInterfaceNotAvailable", ()=>TransportInterfaceNotAvailable);
parcelHelpers.export(exports, "TransportOpenUserCancelled", ()=>TransportOpenUserCancelled);
parcelHelpers.export(exports, "TransportRaceCondition", ()=>TransportRaceCondition);
parcelHelpers.export(exports, "TransportStatusError", ()=>TransportStatusError);
parcelHelpers.export(exports, "TransportWebUSBGestureRequired", ()=>TransportWebUSBGestureRequired);
parcelHelpers.export(exports, "UnavailableTezosOriginatedAccountReceive", ()=>UnavailableTezosOriginatedAccountReceive);
parcelHelpers.export(exports, "UnavailableTezosOriginatedAccountSend", ()=>UnavailableTezosOriginatedAccountSend);
parcelHelpers.export(exports, "UnexpectedBootloader", ()=>UnexpectedBootloader);
parcelHelpers.export(exports, "UnknownMCU", ()=>UnknownMCU);
parcelHelpers.export(exports, "UpdateFetchFileFail", ()=>UpdateFetchFileFail);
parcelHelpers.export(exports, "UpdateIncorrectHash", ()=>UpdateIncorrectHash);
parcelHelpers.export(exports, "UpdateIncorrectSig", ()=>UpdateIncorrectSig);
parcelHelpers.export(exports, "UpdateYourApp", ()=>UpdateYourApp);
parcelHelpers.export(exports, "UserRefusedAddress", ()=>UserRefusedAddress);
parcelHelpers.export(exports, "UserRefusedAllowManager", ()=>UserRefusedAllowManager);
parcelHelpers.export(exports, "UserRefusedDeviceNameChange", ()=>UserRefusedDeviceNameChange);
parcelHelpers.export(exports, "UserRefusedFirmwareUpdate", ()=>UserRefusedFirmwareUpdate);
parcelHelpers.export(exports, "UserRefusedOnDevice", ()=>UserRefusedOnDevice);
parcelHelpers.export(exports, "WebsocketConnectionError", ()=>WebsocketConnectionError);
parcelHelpers.export(exports, "WebsocketConnectionFailed", ()=>WebsocketConnectionFailed);
parcelHelpers.export(exports, "WrongAppForCurrency", ()=>WrongAppForCurrency);
parcelHelpers.export(exports, "WrongDeviceForAccount", ()=>WrongDeviceForAccount);
parcelHelpers.export(exports, "addCustomErrorDeserializer", ()=>addCustomErrorDeserializer);
parcelHelpers.export(exports, "createCustomErrorClass", ()=>createCustomErrorClass);
parcelHelpers.export(exports, "deserializeError", ()=>deserializeError);
parcelHelpers.export(exports, "getAltStatusMessage", ()=>getAltStatusMessage);
parcelHelpers.export(exports, "serializeError", ()=>serializeError);
/* eslint-disable no-continue */ /* eslint-disable no-unused-vars */ /* eslint-disable no-param-reassign */ /* eslint-disable no-prototype-builtins */ var errorClasses = {};
var deserializers = {};
var addCustomErrorDeserializer = function(name, deserializer) {
    deserializers[name] = deserializer;
};
var createCustomErrorClass = function(name) {
    var C = function CustomError(message, fields) {
        Object.assign(this, fields);
        this.name = name;
        this.message = message || name;
        this.stack = new Error().stack;
    };
    C.prototype = new Error();
    errorClasses[name] = C;
    return C;
};
// inspired from https://github.com/programble/errio/blob/master/index.js
var deserializeError = function(object) {
    if (typeof object === "object" && object) {
        try {
            // $FlowFixMe FIXME HACK
            var msg = JSON.parse(object.message);
            if (msg.message && msg.name) object = msg;
        } catch (e) {
        // nothing
        }
        var error = void 0;
        if (typeof object.name === "string") {
            var name_1 = object.name;
            var des = deserializers[name_1];
            if (des) error = des(object);
            else {
                var constructor = name_1 === "Error" ? Error : errorClasses[name_1];
                if (!constructor) {
                    console.warn("deserializing an unknown class '" + name_1 + "'");
                    constructor = createCustomErrorClass(name_1);
                }
                error = Object.create(constructor.prototype);
                try {
                    for(var prop in object)if (object.hasOwnProperty(prop)) error[prop] = object[prop];
                } catch (e) {
                // sometimes setting a property can fail (e.g. .name)
                }
            }
        } else error = new Error(object.message);
        if (!error.stack && Error.captureStackTrace) Error.captureStackTrace(error, deserializeError);
        return error;
    }
    return new Error(String(object));
};
// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js
var serializeError = function(value) {
    if (!value) return value;
    if (typeof value === "object") return destroyCircular(value, []);
    if (typeof value === "function") return "[Function: " + (value.name || "anonymous") + "]";
    return value;
};
// https://www.npmjs.com/package/destroy-circular
function destroyCircular(from, seen) {
    var to = {};
    seen.push(from);
    for(var _i = 0, _a = Object.keys(from); _i < _a.length; _i++){
        var key = _a[_i];
        var value = from[key];
        if (typeof value === "function") continue;
        if (!value || typeof value !== "object") {
            to[key] = value;
            continue;
        }
        if (seen.indexOf(from[key]) === -1) {
            to[key] = destroyCircular(from[key], seen.slice(0));
            continue;
        }
        to[key] = "[Circular]";
    }
    if (typeof from.name === "string") to.name = from.name;
    if (typeof from.message === "string") to.message = from.message;
    if (typeof from.stack === "string") to.stack = from.stack;
    return to;
}
var AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");
var AccountNotSupported = createCustomErrorClass("AccountNotSupported");
var AmountRequired = createCustomErrorClass("AmountRequired");
var BluetoothRequired = createCustomErrorClass("BluetoothRequired");
var BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");
var CantOpenDevice = createCustomErrorClass("CantOpenDevice");
var CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");
var CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");
var DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");
var DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");
var DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");
var DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");
var DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");
var DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");
var DeviceHalted = createCustomErrorClass("DeviceHalted");
var DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");
var DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");
var DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");
var DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");
var DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");
var EnpointConfigError = createCustomErrorClass("EnpointConfig");
var EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");
var FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");
var FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");
var HardResetFail = createCustomErrorClass("HardResetFail");
var InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");
var InvalidAddress = createCustomErrorClass("InvalidAddress");
var InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");
var LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");
var UnknownMCU = createCustomErrorClass("UnknownMCU");
var LedgerAPIError = createCustomErrorClass("LedgerAPIError");
var LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");
var LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");
var ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");
var ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");
var ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");
var ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");
var ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");
var ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");
var ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");
var ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");
var NetworkDown = createCustomErrorClass("NetworkDown");
var NoAddressesFound = createCustomErrorClass("NoAddressesFound");
var NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");
var NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");
var NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");
var NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");
var NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");
var NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");
var NotEnoughGas = createCustomErrorClass("NotEnoughGas");
var NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");
var GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");
var PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");
var PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");
var RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");
var RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");
var TimeoutTagged = createCustomErrorClass("TimeoutTagged");
var UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");
var MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");
var RecipientRequired = createCustomErrorClass("RecipientRequired");
var UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");
var UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");
var UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");
var UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");
var UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");
var UpdateYourApp = createCustomErrorClass("UpdateYourApp");
var UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");
var UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");
var UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");
var UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");
var UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice"); // TODO rename because it's just for transaction refusal
var TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");
var TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");
var TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");
var TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");
var DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");
var WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");
var WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");
var WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");
var WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");
var ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");
var CantScanQRCode = createCustomErrorClass("CantScanQRCode");
var FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");
var FeeRequired = createCustomErrorClass("FeeRequired");
var FeeTooHigh = createCustomErrorClass("FeeTooHigh");
var SyncError = createCustomErrorClass("SyncError");
var PairingFailed = createCustomErrorClass("PairingFailed");
var GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");
var LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");
var LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");
var FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");
// db stuff, no need to translate
var NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");
var DBWrongPassword = createCustomErrorClass("DBWrongPassword");
var DBNotReset = createCustomErrorClass("DBNotReset");
/**
 * TransportError is used for any generic transport errors.
 * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
 */ function TransportError(message, id) {
    this.name = "TransportError";
    this.message = message;
    this.stack = new Error().stack;
    this.id = id;
}
TransportError.prototype = new Error();
addCustomErrorDeserializer("TransportError", function(e) {
    return new TransportError(e.message, e.id);
});
var StatusCodes = {
    PIN_REMAINING_ATTEMPTS: 0x63c0,
    INCORRECT_LENGTH: 0x6700,
    MISSING_CRITICAL_PARAMETER: 0x6800,
    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,
    SECURITY_STATUS_NOT_SATISFIED: 0x6982,
    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,
    INCORRECT_DATA: 0x6a80,
    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,
    REFERENCED_DATA_NOT_FOUND: 0x6a88,
    FILE_ALREADY_EXISTS: 0x6a89,
    INCORRECT_P1_P2: 0x6b00,
    INS_NOT_SUPPORTED: 0x6d00,
    CLA_NOT_SUPPORTED: 0x6e00,
    TECHNICAL_PROBLEM: 0x6f00,
    OK: 0x9000,
    MEMORY_PROBLEM: 0x9240,
    NO_EF_SELECTED: 0x9400,
    INVALID_OFFSET: 0x9402,
    FILE_NOT_FOUND: 0x9404,
    INCONSISTENT_FILE: 0x9408,
    ALGORITHM_NOT_SUPPORTED: 0x9484,
    INVALID_KCV: 0x9485,
    CODE_NOT_INITIALIZED: 0x9802,
    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,
    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,
    CONTRADICTION_INVALIDATION: 0x9810,
    CODE_BLOCKED: 0x9840,
    MAX_VALUE_REACHED: 0x9850,
    GP_AUTH_FAILED: 0x6300,
    LICENSING: 0x6f42,
    HALTED: 0x6faa
};
function getAltStatusMessage(code) {
    switch(code){
        // improve text of most common errors
        case 0x6700:
            return "Incorrect length";
        case 0x6800:
            return "Missing critical parameter";
        case 0x6982:
            return "Security not satisfied (dongle locked or have invalid access rights)";
        case 0x6985:
            return "Condition of use not satisfied (denied by the user?)";
        case 0x6a80:
            return "Invalid data received";
        case 0x6b00:
            return "Invalid parameter received";
    }
    if (0x6f00 <= code && code <= 0x6fff) return "Internal error, please report";
}
/**
 * Error thrown when a device returned a non success status.
 * the error.statusCode is one of the `StatusCodes` exported by this library.
 */ function TransportStatusError(statusCode) {
    this.name = "TransportStatusError";
    var statusText = Object.keys(StatusCodes).find(function(k) {
        return StatusCodes[k] === statusCode;
    }) || "UNKNOWN_ERROR";
    var smsg = getAltStatusMessage(statusCode) || statusText;
    var statusCodeStr = statusCode.toString(16);
    this.message = "Ledger device: " + smsg + " (0x" + statusCodeStr + ")";
    this.stack = new Error().stack;
    this.statusCode = statusCode;
    this.statusText = statusText;
}
TransportStatusError.prototype = new Error();
addCustomErrorDeserializer("TransportStatusError", function(e) {
    return new TransportStatusError(e.statusCode);
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fvgJh":[function(require,module,exports) {
"use strict";
var Buffer = require("buffer").Buffer;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _errors = require("@ledgerhq/errors");
const Tag = 0x05;
function asUInt16BE(value) {
    const b = Buffer.alloc(2);
    b.writeUInt16BE(value, 0);
    return b;
}
const initialAcc = {
    data: Buffer.alloc(0),
    dataLength: 0,
    sequence: 0
};
/**
 *
 */ const createHIDframing = (channel, packetSize)=>{
    return {
        makeBlocks (apdu) {
            let data = Buffer.concat([
                asUInt16BE(apdu.length),
                apdu
            ]);
            const blockSize = packetSize - 5;
            const nbBlocks = Math.ceil(data.length / blockSize);
            data = Buffer.concat([
                data,
                Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)
            ]);
            const blocks = [];
            for(let i = 0; i < nbBlocks; i++){
                const head = Buffer.alloc(5);
                head.writeUInt16BE(channel, 0);
                head.writeUInt8(Tag, 2);
                head.writeUInt16BE(i, 3);
                const chunk = data.slice(i * blockSize, (i + 1) * blockSize);
                blocks.push(Buffer.concat([
                    head,
                    chunk
                ]));
            }
            return blocks;
        },
        reduceResponse (acc, chunk) {
            let { data , dataLength , sequence  } = acc || initialAcc;
            if (chunk.readUInt16BE(0) !== channel) throw new _errors.TransportError("Invalid channel", "InvalidChannel");
            if (chunk.readUInt8(2) !== Tag) throw new _errors.TransportError("Invalid tag", "InvalidTag");
            if (chunk.readUInt16BE(3) !== sequence) throw new _errors.TransportError("Invalid sequence", "InvalidSequence");
            if (!acc) dataLength = chunk.readUInt16BE(5);
            sequence++;
            const chunkData = chunk.slice(acc ? 5 : 7);
            data = Buffer.concat([
                data,
                chunkData
            ]);
            if (data.length > dataLength) data = data.slice(0, dataLength);
            return {
                data,
                dataLength,
                sequence
            };
        },
        getReducedResult (acc) {
            if (acc && acc.dataLength === acc.data.length) return acc.data;
        }
    };
};
var _default = createHIDframing;
exports.default = _default;

},{"buffer":"fCgem","@ledgerhq/errors":"e0rTV"}],"fnHxP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IIGenericHID", ()=>IIGenericHID);
parcelHelpers.export(exports, "IIKeyboardHID", ()=>IIKeyboardHID);
parcelHelpers.export(exports, "IIU2F", ()=>IIU2F);
parcelHelpers.export(exports, "IICCID", ()=>IICCID);
parcelHelpers.export(exports, "IIWebUSB", ()=>IIWebUSB);
parcelHelpers.export(exports, "ledgerUSBVendorId", ()=>ledgerUSBVendorId);
parcelHelpers.export(exports, "getDeviceModel", ()=>getDeviceModel);
parcelHelpers.export(exports, "identifyUSBProductId", ()=>identifyUSBProductId);
parcelHelpers.export(exports, "identifyProductName", ()=>identifyProductName);
parcelHelpers.export(exports, "getBluetoothServiceUuids", ()=>getBluetoothServiceUuids);
parcelHelpers.export(exports, "getInfosForServiceUuid", ()=>getInfosForServiceUuid);
var _semver = require("semver");
var _semverDefault = parcelHelpers.interopDefault(_semver);
const IIGenericHID = 0x01;
const IIKeyboardHID = 0x02;
const IIU2F = 0x04;
const IICCID = 0x08;
const IIWebUSB = 0x10;
const devices = {
    blue: {
        id: "blue",
        productName: "Ledger\xa0Blue",
        productIdMM: 0x00,
        legacyUsbProductId: 0x0000,
        usbOnly: true,
        memorySize: 491520,
        blockSize: 4096,
        getBlockSize: (_firwareVersion)=>4096
    },
    nanoS: {
        id: "nanoS",
        productName: "Ledger\xa0Nano\xa0S",
        productIdMM: 0x10,
        legacyUsbProductId: 0x0001,
        usbOnly: true,
        memorySize: 327680,
        blockSize: 4096,
        getBlockSize: (firmwareVersion)=>(0, _semverDefault.default).lt((0, _semverDefault.default).coerce(firmwareVersion), "2.0.0") ? 4096 : 2048
    },
    nanoX: {
        id: "nanoX",
        productName: "Ledger\xa0Nano\xa0X",
        productIdMM: 0x40,
        legacyUsbProductId: 0x0004,
        usbOnly: false,
        memorySize: 2097152,
        blockSize: 4096,
        getBlockSize: (_firwareVersion)=>4096,
        bluetoothSpec: [
            {
                // this is the legacy one (prototype version). we will eventually drop it.
                serviceUuid: "d973f2e0-b19e-11e2-9e96-0800200c9a66",
                notifyUuid: "d973f2e1-b19e-11e2-9e96-0800200c9a66",
                writeUuid: "d973f2e2-b19e-11e2-9e96-0800200c9a66"
            },
            {
                serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
                notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
                writeUuid: "13d63400-2c97-0004-0002-4c6564676572"
            }
        ]
    }
};
const productMap = {
    Blue: "blue",
    "Nano S": "nanoS",
    "Nano X": "nanoX"
}; // $FlowFixMe
const devicesList = Object.values(devices);
const ledgerUSBVendorId = 0x2c97;
const getDeviceModel = (id1)=>{
    const info = devices[id1];
    if (!info) throw new Error("device '" + id1 + "' does not exist");
    return info;
};
const identifyUSBProductId = (usbProductId)=>{
    const legacy = devicesList.find((d)=>d.legacyUsbProductId === usbProductId);
    if (legacy) return legacy;
    const mm = usbProductId >> 8;
    const deviceModel = devicesList.find((d)=>d.productIdMM === mm);
    return deviceModel;
};
const identifyProductName = (productName)=>{
    const productId = productMap[productName];
    const deviceModel = devicesList.find((d)=>d.id === productId);
    return deviceModel;
};
const bluetoothServices = [];
const serviceUuidToInfos = {};
for(let id in devices){
    const deviceModel = devices[id];
    const { bluetoothSpec  } = deviceModel;
    if (bluetoothSpec) for(let i = 0; i < bluetoothSpec.length; i++){
        const spec = bluetoothSpec[i];
        bluetoothServices.push(spec.serviceUuid);
        serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = {
            deviceModel,
            ...spec
        };
    }
}
const getBluetoothServiceUuids = ()=>bluetoothServices;
const getInfosForServiceUuid = (uuid)=>serviceUuidToInfos[uuid.toLowerCase()]; /**
 *
 */ 

},{"semver":"1bOrY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bOrY":[function(require,module,exports) {
// just pre-load all the stuff that index.js lazily exports
const internalRe = require("./internal/re");
module.exports = {
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: require("./internal/constants").SEMVER_SPEC_VERSION,
    SemVer: require("./classes/semver"),
    compareIdentifiers: require("./internal/identifiers").compareIdentifiers,
    rcompareIdentifiers: require("./internal/identifiers").rcompareIdentifiers,
    parse: require("./functions/parse"),
    valid: require("./functions/valid"),
    clean: require("./functions/clean"),
    inc: require("./functions/inc"),
    diff: require("./functions/diff"),
    major: require("./functions/major"),
    minor: require("./functions/minor"),
    patch: require("./functions/patch"),
    prerelease: require("./functions/prerelease"),
    compare: require("./functions/compare"),
    rcompare: require("./functions/rcompare"),
    compareLoose: require("./functions/compare-loose"),
    compareBuild: require("./functions/compare-build"),
    sort: require("./functions/sort"),
    rsort: require("./functions/rsort"),
    gt: require("./functions/gt"),
    lt: require("./functions/lt"),
    eq: require("./functions/eq"),
    neq: require("./functions/neq"),
    gte: require("./functions/gte"),
    lte: require("./functions/lte"),
    cmp: require("./functions/cmp"),
    coerce: require("./functions/coerce"),
    Comparator: require("./classes/comparator"),
    Range: require("./classes/range"),
    satisfies: require("./functions/satisfies"),
    toComparators: require("./ranges/to-comparators"),
    maxSatisfying: require("./ranges/max-satisfying"),
    minSatisfying: require("./ranges/min-satisfying"),
    minVersion: require("./ranges/min-version"),
    validRange: require("./ranges/valid"),
    outside: require("./ranges/outside"),
    gtr: require("./ranges/gtr"),
    ltr: require("./ranges/ltr"),
    intersects: require("./ranges/intersects"),
    simplifyRange: require("./ranges/simplify"),
    subset: require("./ranges/subset")
};

},{"./internal/re":"fM3gb","./internal/constants":"36kox","./classes/semver":"kgTdE","./internal/identifiers":"gfu2O","./functions/parse":"gcpPf","./functions/valid":"gWiRZ","./functions/clean":"aiTKa","./functions/inc":"aJfKw","./functions/diff":"4hrxk","./functions/major":"8P6hj","./functions/minor":"jpEiD","./functions/patch":"9pRhW","./functions/prerelease":"luzbM","./functions/compare":"1VfgV","./functions/rcompare":"cgrtc","./functions/compare-loose":"Q3pnc","./functions/compare-build":"eYE5A","./functions/sort":"8TvEb","./functions/rsort":"4isEq","./functions/gt":"h68v7","./functions/lt":"6ucE6","./functions/eq":"k1aRj","./functions/neq":"7Y3tc","./functions/gte":"ehmrd","./functions/lte":"2J3QH","./functions/cmp":"1k1O9","./functions/coerce":"iXNTl","./classes/comparator":"5Yodu","./classes/range":"f4j9g","./functions/satisfies":"7OcsV","./ranges/to-comparators":"iR5Mh","./ranges/max-satisfying":"jPYT1","./ranges/min-satisfying":"juckF","./ranges/min-version":"5VviM","./ranges/valid":"d8BN4","./ranges/outside":"jz7Jf","./ranges/gtr":"kboF2","./ranges/ltr":"4bUsl","./ranges/intersects":"hpFPQ","./ranges/simplify":"kb0TI","./ranges/subset":"lNExW"}],"fM3gb":[function(require,module,exports) {
const { MAX_SAFE_COMPONENT_LENGTH  } = require("./constants");
const debug = require("./debug");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;
const createToken = (name, value, isGlobal)=>{
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
// ## Main Version
// Three dot-separated numeric identifiers.
createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken("FULL", `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
createToken("GTLT", "((?:<|>)?=?)");
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
createToken("COERCERTL", src[t.COERCE], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken("LONETILDE", "(?:~>?)");
createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = "$1~";
createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken("LONECARET", "(?:\\^)");
createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = "$1^";
createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = "$1$2$3";
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken("STAR", "(<|>)?=?\\s*\\*");
// >=0.0.0 is like a star
createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");

},{"./constants":"36kox","./debug":"5sQBx"}],"36kox":[function(require,module,exports) {
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
module.exports = {
    SEMVER_SPEC_VERSION,
    MAX_LENGTH,
    MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH
};

},{}],"5sQBx":[function(require,module,exports) {
var process = require("process");
const debug = (typeof process === "object" && process.env && undefined, ()=>{});
module.exports = debug;

},{"process":"d5jf4"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"kgTdE":[function(require,module,exports) {
const debug = require("../internal/debug");
const { MAX_LENGTH , MAX_SAFE_INTEGER  } = require("../internal/constants");
const { re , t  } = require("../internal/re");
const parseOptions = require("../internal/parse-options");
const { compareIdentifiers  } = require("../internal/identifiers");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
            else version = version.version;
        } else if (typeof version !== "string") throw new TypeError(`Invalid Version: ${version}`);
        if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) throw new TypeError(`Invalid Version: ${version}`);
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        // numberify any prerelease numeric ids
        if (!m[4]) this.prerelease = [];
        else this.prerelease = m[4].split(".").map((id)=>{
            if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
            }
            return id;
        });
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) this.version += `-${this.prerelease.join(".")}`;
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) return 0;
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) return 0;
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) return -1;
        else if (!this.prerelease.length && other.prerelease.length) return 1;
        else if (!this.prerelease.length && !other.prerelease.length) return 0;
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return compareIdentifiers(a, b);
        }while (++i);
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) other = new SemVer(other, this.options);
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) return 0;
            else if (b === undefined) return 1;
            else if (a === undefined) return -1;
            else if (a === b) continue;
            else return compareIdentifiers(a, b);
        }while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier) {
        switch(release){
            case "premajor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc("pre", identifier);
                break;
            case "preminor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc("pre", identifier);
                break;
            case "prepatch":
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc("patch", identifier);
                this.inc("pre", identifier);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case "prerelease":
                if (this.prerelease.length === 0) this.inc("patch", identifier);
                this.inc("pre", identifier);
                break;
            case "major":
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) this.major++;
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "minor":
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "patch":
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) this.patch++;
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case "pre":
                if (this.prerelease.length === 0) this.prerelease = [
                    0
                ];
                else {
                    let i = this.prerelease.length;
                    while(--i >= 0)if (typeof this.prerelease[i] === "number") {
                        this.prerelease[i]++;
                        i = -2;
                    }
                    if (i === -1) // didn't increment anything
                    this.prerelease.push(0);
                }
                if (identifier) {
                    // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                    // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                    if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                        if (isNaN(this.prerelease[1])) this.prerelease = [
                            identifier,
                            0
                        ];
                    } else this.prerelease = [
                        identifier,
                        0
                    ];
                }
                break;
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
    }
}
module.exports = SemVer;

},{"../internal/debug":"5sQBx","../internal/constants":"36kox","../internal/re":"fM3gb","../internal/parse-options":"aIQkG","../internal/identifiers":"gfu2O"}],"aIQkG":[function(require,module,exports) {
// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = [
    "includePrerelease",
    "loose",
    "rtl"
];
const parseOptions = (options)=>!options ? {} : typeof options !== "object" ? {
        loose: true
    } : opts.filter((k)=>options[k]).reduce((o, k)=>{
        o[k] = true;
        return o;
    }, {});
module.exports = parseOptions;

},{}],"gfu2O":[function(require,module,exports) {
const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};

},{}],"gcpPf":[function(require,module,exports) {
const { MAX_LENGTH  } = require("../internal/constants");
const { re , t  } = require("../internal/re");
const SemVer = require("../classes/semver");
const parseOptions = require("../internal/parse-options");
const parse = (version, options)=>{
    options = parseOptions(options);
    if (version instanceof SemVer) return version;
    if (typeof version !== "string") return null;
    if (version.length > MAX_LENGTH) return null;
    const r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) return null;
    try {
        return new SemVer(version, options);
    } catch (er) {
        return null;
    }
};
module.exports = parse;

},{"../internal/constants":"36kox","../internal/re":"fM3gb","../classes/semver":"kgTdE","../internal/parse-options":"aIQkG"}],"gWiRZ":[function(require,module,exports) {
const parse = require("./parse");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;

},{"./parse":"gcpPf"}],"aiTKa":[function(require,module,exports) {
const parse = require("./parse");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
};
module.exports = clean;

},{"./parse":"gcpPf"}],"aJfKw":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const inc = (version, release, options, identifier)=>{
    if (typeof options === "string") {
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;

},{"../classes/semver":"kgTdE"}],"4hrxk":[function(require,module,exports) {
const parse = require("./parse");
const eq = require("./eq");
const diff = (version1, version2)=>{
    if (eq(version1, version2)) return null;
    else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for(const key in v1)if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) return prefix + key;
        }
        return defaultResult // may be undefined
        ;
    }
};
module.exports = diff;

},{"./parse":"gcpPf","./eq":"k1aRj"}],"k1aRj":[function(require,module,exports) {
const compare = require("./compare");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;

},{"./compare":"1VfgV"}],"1VfgV":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;

},{"../classes/semver":"kgTdE"}],"8P6hj":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;

},{"../classes/semver":"kgTdE"}],"jpEiD":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;

},{"../classes/semver":"kgTdE"}],"9pRhW":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;

},{"../classes/semver":"kgTdE"}],"luzbM":[function(require,module,exports) {
const parse = require("./parse");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;

},{"./parse":"gcpPf"}],"cgrtc":[function(require,module,exports) {
const compare = require("./compare");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;

},{"./compare":"1VfgV"}],"Q3pnc":[function(require,module,exports) {
const compare = require("./compare");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;

},{"./compare":"1VfgV"}],"eYE5A":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;

},{"../classes/semver":"kgTdE"}],"8TvEb":[function(require,module,exports) {
const compareBuild = require("./compare-build");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;

},{"./compare-build":"eYE5A"}],"4isEq":[function(require,module,exports) {
const compareBuild = require("./compare-build");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;

},{"./compare-build":"eYE5A"}],"h68v7":[function(require,module,exports) {
const compare = require("./compare");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;

},{"./compare":"1VfgV"}],"6ucE6":[function(require,module,exports) {
const compare = require("./compare");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;

},{"./compare":"1VfgV"}],"7Y3tc":[function(require,module,exports) {
const compare = require("./compare");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;

},{"./compare":"1VfgV"}],"ehmrd":[function(require,module,exports) {
const compare = require("./compare");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;

},{"./compare":"1VfgV"}],"2J3QH":[function(require,module,exports) {
const compare = require("./compare");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;

},{"./compare":"1VfgV"}],"1k1O9":[function(require,module,exports) {
const eq = require("./eq");
const neq = require("./neq");
const gt = require("./gt");
const gte = require("./gte");
const lt = require("./lt");
const lte = require("./lte");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case "===":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a === b;
        case "!==":
            if (typeof a === "object") a = a.version;
            if (typeof b === "object") b = b.version;
            return a !== b;
        case "":
        case "=":
        case "==":
            return eq(a, b, loose);
        case "!=":
            return neq(a, b, loose);
        case ">":
            return gt(a, b, loose);
        case ">=":
            return gte(a, b, loose);
        case "<":
            return lt(a, b, loose);
        case "<=":
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;

},{"./eq":"k1aRj","./neq":"7Y3tc","./gt":"h68v7","./gte":"ehmrd","./lt":"6ucE6","./lte":"2J3QH"}],"iXNTl":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const parse = require("./parse");
const { re , t  } = require("../internal/re");
const coerce = (version, options)=>{
    if (version instanceof SemVer) return version;
    if (typeof version === "number") version = String(version);
    if (typeof version !== "string") return null;
    options = options || {};
    let match = null;
    if (!options.rtl) match = version.match(re[t.COERCE]);
    else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        let next;
        while((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) match = next;
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) return null;
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
module.exports = coerce;

},{"../classes/semver":"kgTdE","./parse":"gcpPf","../internal/re":"fM3gb"}],"5Yodu":[function(require,module,exports) {
const ANY = Symbol("SemVer ANY");
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) return comp;
            else comp = comp.value;
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) this.value = "";
        else this.value = this.operator + this.semver.version;
        debug("comp", this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
        this.operator = m[1] !== undefined ? m[1] : "";
        if (this.operator === "=") this.operator = "";
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) this.semver = ANY;
        else this.semver = new SemVer(m[2], this.options.loose);
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) return true;
        if (typeof version === "string") try {
            version = new SemVer(version, this.options);
        } catch (er) {
            return false;
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
        if (!options || typeof options !== "object") options = {
            loose: !!options,
            includePrerelease: false
        };
        if (this.operator === "") {
            if (this.value === "") return true;
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
            if (comp.value === "") return true;
            return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    }
}
module.exports = Comparator;
const parseOptions = require("../internal/parse-options");
const { re , t  } = require("../internal/re");
const cmp = require("../functions/cmp");
const debug = require("../internal/debug");
const SemVer = require("./semver");
const Range = require("./range");

},{"../internal/parse-options":"aIQkG","../internal/re":"fM3gb","../functions/cmp":"1k1O9","../internal/debug":"5sQBx","./semver":"kgTdE","./range":"f4j9g"}],"f4j9g":[function(require,module,exports) {
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) return range;
            else return new Range(range.raw, options);
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.format();
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First, split based on boolean or ||
        this.raw = range;
        this.set = range.split("||")// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) throw new TypeError(`Invalid SemVer Range: ${range}`);
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) this.set = [
                first
            ];
            else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set)if (c.length === 1 && isAny(c[0])) {
                    this.set = [
                        c
                    ];
                    break;
                }
            }
        }
        this.format();
    }
    format() {
        this.range = this.set.map((comps)=>{
            return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        range = range.trim();
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached) return cached;
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        // normalize spaces
        range = range.split(/\s+/).join(" ");
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(" ").map((comp)=>parseComparator(comp, this.options)).join(" ").split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) // in loose mode, throw out any that are not valid comparators
        rangeList = rangeList.filter((comp)=>{
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
        });
        debug("range list", rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp1 of comparators){
            if (isNullSet(comp1)) return [
                comp1
            ];
            rangeMap.set(comp1.value, comp1);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) rangeMap.delete("");
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) throw new TypeError("a Range is required");
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) return false;
        if (typeof version === "string") try {
            version = new SemVer(version, this.options);
        } catch (er) {
            return false;
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) return true;
        }
        return false;
    }
}
module.exports = Range;
const LRU = require("lru-cache");
const cache = new LRU({
    max: 1000
});
const parseOptions = require("../internal/parse-options");
const Comparator = require("./comparator");
const debug = require("../internal/debug");
const SemVer = require("./semver");
const { re , t , comparatorTrimReplace , tildeTrimReplace , caretTrimReplace ,  } = require("../internal/re");
const isNullSet = (c)=>c.value === "<0.0.0-0";
const isAny = (c)=>c.value === "";
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === "x" || id === "*";
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options)=>comp.trim().split(/\s+/).map((c)=>{
        return replaceTilde(c, options);
    }).join(" ");
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) ret = "";
        else if (isX(m)) ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        else if (isX(p)) // ~1.2 == >=1.2.0 <1.3.0-0
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        else if (pr) {
            debug("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else // ~1.2.3 == >=1.2.3 <1.3.0-0
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        debug("tilde return", ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options)=>comp.trim().split(/\s+/).map((c)=>{
        return replaceCaret(c, options);
    }).join(" ");
const replaceCaret = (comp, options)=>{
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) ret = "";
        else if (isX(m)) ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        else if (isX(p)) {
            if (M === "0") ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            else ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        } else {
            debug("no pr");
            if (M === "0") {
                if (m === "0") ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                else ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            } else ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
        debug("caret return", ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c)=>{
        return replaceXRange(c, options);
    }).join(" ");
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) gtlt = "";
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
            if (gtlt === ">" || gtlt === "<") // nothing is allowed
            ret = "<0.0.0-0";
            else // nothing is forbidden
            ret = "*";
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) m = 0;
            p = 0;
            if (gtlt === ">") {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = ">=";
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === "<=") {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = "<";
                if (xm) M = +M + 1;
                else m = +m + 1;
            }
            if (gtlt === "<") pr = "-0";
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        else if (xp) ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        debug("xRange return", ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug("replaceStars", comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], "");
};
const replaceGTE0 = (comp, options)=>{
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb)=>{
        if (isX(fM)) from = "";
        else if (isX(fm)) from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        else if (isX(fp)) from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        else if (fpr) from = `>=${from}`;
        else from = `>=${from}${incPr ? "-0" : ""}`;
        if (isX(tM)) to = "";
        else if (isX(tm)) to = `<${+tM + 1}.0.0-0`;
        else if (isX(tp)) to = `<${tM}.${+tm + 1}.0-0`;
        else if (tpr) to = `<=${tM}.${tm}.${tp}-${tpr}`;
        else if (incPr) to = `<${tM}.${tm}.${+tp + 1}-0`;
        else to = `<=${to}`;
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) return false;
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) continue;
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return true;
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};

},{"lru-cache":"26bTZ","../internal/parse-options":"aIQkG","./comparator":"5Yodu","../internal/debug":"5sQBx","./semver":"kgTdE","../internal/re":"fM3gb"}],"26bTZ":[function(require,module,exports) {
"use strict";
// A linked list to keep track of recently-used-ness
const Yallist = require("yallist");
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value));
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) this.set(hit.k, hit.v, maxAge);
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false));
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else if (doUse) {
            if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
        // We know that we're about to delete this one, and also
        // what the next least recently used key will be, so just
        // go ahead and set it now.
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;

},{"yallist":"7m1YN"}],"7m1YN":[function(require,module,exports) {
"use strict";
module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) self = new Yallist();
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") list.forEach(function(item) {
        self.push(item);
    });
    else if (arguments.length > 0) for(var i = 0, l = arguments.length; i < l; i++)self.push(arguments[i]);
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) throw new Error("removing node which does not belong to this list");
    var next = node.next;
    var prev = node.prev;
    if (next) next.prev = prev;
    if (prev) prev.next = next;
    if (node === this.head) this.head = next;
    if (node === this.tail) this.tail = prev;
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) return;
    if (node.list) node.list.removeNode(node);
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) head.prev = node;
    this.head = node;
    if (!this.tail) this.tail = node;
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) return;
    if (node.list) node.list.removeNode(node);
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) tail.next = node;
    this.tail = node;
    if (!this.head) this.head = node;
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++)push(this, arguments[i]);
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++)unshift(this, arguments[i]);
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) return undefined;
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) this.tail.next = null;
    else this.head = null;
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) return undefined;
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) this.head.prev = null;
    else this.tail = null;
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.next;
    if (i === n && walker !== null) return walker.value;
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.prev;
    if (i === n && walker !== null) return walker.value;
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) acc = initial;
    else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else throw new TypeError("Reduce of empty list with no initial value");
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) acc = initial;
    else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else throw new TypeError("Reduce of empty list with no initial value");
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = 0, walker = this.head; walker !== null && i < from; i++)walker = walker.next;
    for(; walker !== null && i < to; i++, walker = walker.next)ret.push(walker.value);
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--)walker = walker.prev;
    for(; walker !== null && i > from; i--, walker = walker.prev)ret.push(walker.value);
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) start = this.length - 1;
    if (start < 0) start = this.length + start;
    for(var i = 0, walker = this.head; walker !== null && i < start; i++)walker = walker.next;
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) walker = this.tail;
    if (walker !== this.head && walker !== this.tail) walker = walker.prev;
    for(var i = 0; i < nodes.length; i++)walker = insert(this, walker, nodes[i]);
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) self.tail = inserted;
    if (inserted.prev === null) self.head = inserted;
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) self.head = self.tail;
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) self.tail = self.head;
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) return new Node(value, prev, next, list);
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else this.prev = null;
    if (next) {
        next.prev = this;
        this.next = next;
    } else this.next = null;
}
try {
    // add if support for Symbol.iterator is present
    require("./iterator.js")(Yallist);
} catch (er) {}

},{"./iterator.js":"8T9JN"}],"8T9JN":[function(require,module,exports) {
"use strict";
module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next)yield walker.value;
    };
};

},{}],"7OcsV":[function(require,module,exports) {
const Range = require("../classes/range");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;

},{"../classes/range":"f4j9g"}],"iR5Mh":[function(require,module,exports) {
const Range = require("../classes/range");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(" ").trim().split(" "));
module.exports = toComparators;

},{"../classes/range":"f4j9g"}],"jPYT1":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const Range = require("../classes/range");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;

},{"../classes/semver":"kgTdE","../classes/range":"f4j9g"}],"juckF":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const Range = require("../classes/range");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) // satisfies(v, range, options)
        {
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;

},{"../classes/semver":"kgTdE","../classes/range":"f4j9g"}],"5VviM":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const Range = require("../classes/range");
const gt = require("../functions/gt");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) return minver;
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case ">":
                    if (compver.prerelease.length === 0) compver.patch++;
                    else compver.prerelease.push(0);
                    compver.raw = compver.format();
                /* fallthrough */ case "":
                case ">=":
                    if (!setMin || gt(compver, setMin)) setMin = compver;
                    break;
                case "<":
                case "<=":
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) minver = setMin;
    }
    if (minver && range.test(minver)) return minver;
    return null;
};
module.exports = minVersion;

},{"../classes/semver":"kgTdE","../classes/range":"f4j9g","../functions/gt":"h68v7"}],"d8BN4":[function(require,module,exports) {
const Range = require("../classes/range");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || "*";
    } catch (er) {
        return null;
    }
};
module.exports = validRange;

},{"../classes/range":"f4j9g"}],"jz7Jf":[function(require,module,exports) {
const SemVer = require("../classes/semver");
const Comparator = require("../classes/comparator");
const { ANY  } = Comparator;
const Range = require("../classes/range");
const satisfies = require("../functions/satisfies");
const gt = require("../functions/gt");
const lt = require("../functions/lt");
const lte = require("../functions/lte");
const gte = require("../functions/gte");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
        case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) return false;
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) comparator = new Comparator(">=0.0.0");
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) high = comparator;
            else if (ltfn(comparator.semver, low.semver, options)) low = comparator;
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) return false;
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return false;
        else if (low.operator === ecomp && ltfn(version, low.semver)) return false;
    }
    return true;
};
module.exports = outside;

},{"../classes/semver":"kgTdE","../classes/comparator":"5Yodu","../classes/range":"f4j9g","../functions/satisfies":"7OcsV","../functions/gt":"h68v7","../functions/lt":"6ucE6","../functions/lte":"2J3QH","../functions/gte":"ehmrd"}],"kboF2":[function(require,module,exports) {
// Determine if version is greater than all the versions possible in the range.
const outside = require("./outside");
const gtr = (version, range, options)=>outside(version, range, ">", options);
module.exports = gtr;

},{"./outside":"jz7Jf"}],"4bUsl":[function(require,module,exports) {
const outside = require("./outside");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, "<", options);
module.exports = ltr;

},{"./outside":"jz7Jf"}],"hpFPQ":[function(require,module,exports) {
const Range = require("../classes/range");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
};
module.exports = intersects;

},{"../classes/range":"f4j9g"}],"kb0TI":[function(require,module,exports) {
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = require("../functions/satisfies.js");
const compare = require("../functions/compare.js");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) first = version;
        } else {
            if (prev) set.push([
                first,
                prev
            ]);
            prev = null;
            first = null;
        }
    }
    if (first) set.push([
        first,
        null
    ]);
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) ranges.push(min);
        else if (!max && min === v[0]) ranges.push("*");
        else if (!max) ranges.push(`>=${min}`);
        else if (min === v[0]) ranges.push(`<=${max}`);
        else ranges.push(`${min} - ${max}`);
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};

},{"../functions/satisfies.js":"7OcsV","../functions/compare.js":"1VfgV"}],"lNExW":[function(require,module,exports) {
const Range = require("../classes/range.js");
const Comparator = require("../classes/comparator.js");
const { ANY  } = Comparator;
const satisfies = require("../functions/satisfies.js");
const compare = require("../functions/compare.js");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) return true;
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) continue OUTER;
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) return false;
    }
    return true;
};
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) return true;
        else if (options.includePrerelease) sub = [
            new Comparator(">=0.0.0-0")
        ];
        else sub = [
            new Comparator(">=0.0.0")
        ];
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) return true;
        else dom = [
            new Comparator(">=0.0.0")
        ];
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === ">" || c.operator === ">=") gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=") lt = lowerLT(lt, c, options);
        else eqSet.add(c.semver);
    }
    if (eqSet.size > 1) return null;
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) return null;
        if (lt && !satisfies(eq, String(lt), options)) return null;
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) return false;
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) needDomLTPre = false;
    for (const c1 of dom){
        hasDomGT = hasDomGT || c1.operator === ">" || c1.operator === ">=";
        hasDomLT = hasDomLT || c1.operator === "<" || c1.operator === "<=";
        if (gt) {
            if (needDomGTPre) {
                if (c1.semver.prerelease && c1.semver.prerelease.length && c1.semver.major === needDomGTPre.major && c1.semver.minor === needDomGTPre.minor && c1.semver.patch === needDomGTPre.patch) needDomGTPre = false;
            }
            if (c1.operator === ">" || c1.operator === ">=") {
                higher = higherGT(gt, c1, options);
                if (higher === c1 && higher !== gt) return false;
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c1), options)) return false;
        }
        if (lt) {
            if (needDomLTPre) {
                if (c1.semver.prerelease && c1.semver.prerelease.length && c1.semver.major === needDomLTPre.major && c1.semver.minor === needDomLTPre.minor && c1.semver.patch === needDomLTPre.patch) needDomLTPre = false;
            }
            if (c1.operator === "<" || c1.operator === "<=") {
                lower = lowerLT(lt, c1, options);
                if (lower === c1 && lower !== lt) return false;
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c1), options)) return false;
        }
        if (!c1.operator && (lt || gt) && gtltComp !== 0) return false;
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) return false;
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) return b;
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
module.exports = subset;

},{"../classes/range.js":"f4j9g","../classes/comparator.js":"5Yodu","../functions/satisfies.js":"7OcsV","../functions/compare.js":"1VfgV"}],"i4OI0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "listen", ()=>listen);
/**
 * A Log object
 */ let id = 0;
const subscribers = [];
const log = (type, message, data)=>{
    const obj = {
        type,
        id: String(++id),
        date: new Date()
    };
    if (message) obj.message = message;
    if (data) obj.data = data;
    dispatch(obj);
};
const listen = (cb)=>{
    subscribers.push(cb);
    return ()=>{
        const i = subscribers.indexOf(cb);
        if (i !== -1) {
            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952
            subscribers[i] = subscribers[subscribers.length - 1];
            subscribers.pop();
        }
    };
};
function dispatch(log1) {
    for(let i = 0; i < subscribers.length; i++)try {
        subscribers[i](log1);
    } catch (e) {
        console.error(e);
    }
} // for debug purpose
if (typeof window !== "undefined") window.__ledgerLogsListen = listen;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NNG8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestLedgerDevice", ()=>requestLedgerDevice);
parcelHelpers.export(exports, "getLedgerDevices", ()=>getLedgerDevices);
parcelHelpers.export(exports, "getFirstLedgerDevice", ()=>getFirstLedgerDevice);
parcelHelpers.export(exports, "isSupported", ()=>isSupported);
var _devices = require("@ledgerhq/devices");
const ledgerDevices = [
    {
        vendorId: (0, _devices.ledgerUSBVendorId)
    }
];
async function requestLedgerDevice() {
    // $FlowFixMe
    const device = await navigator.usb.requestDevice({
        filters: ledgerDevices
    });
    return device;
}
async function getLedgerDevices() {
    // $FlowFixMe
    const devices = await navigator.usb.getDevices();
    return devices.filter((d)=>d.vendorId === (0, _devices.ledgerUSBVendorId));
}
async function getFirstLedgerDevice() {
    const existingDevices = await getLedgerDevices();
    if (existingDevices.length > 0) return existingDevices[0];
    return requestLedgerDevice();
}
const isSupported = ()=>Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === "function");

},{"@ledgerhq/devices":"fnHxP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8O295":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hwTransport = require("@ledgerhq/hw-transport");
var _hwTransportDefault = parcelHelpers.interopDefault(_hwTransport);
var _hidFraming = require("@ledgerhq/devices/lib/hid-framing");
var _hidFramingDefault = parcelHelpers.interopDefault(_hidFraming);
var _devices = require("@ledgerhq/devices");
var _logs = require("@ledgerhq/logs");
var _errors = require("@ledgerhq/errors");
var global = arguments[3];
var Buffer = require("buffer").Buffer;
const ledgerDevices = [
    {
        vendorId: (0, _devices.ledgerUSBVendorId)
    }
];
const isSupported = ()=>Promise.resolve(!!(global.navigator && global.navigator.hid));
const getHID = ()=>{
    // $FlowFixMe
    const { hid  } = navigator;
    if (!hid) throw new (0, _errors.TransportError)("navigator.hid is not supported", "HIDNotSupported");
    return hid;
};
async function requestLedgerDevices() {
    const device = await getHID().requestDevice({
        filters: ledgerDevices
    });
    if (Array.isArray(device)) return device;
    return [
        device
    ];
}
async function getLedgerDevices() {
    const devices = await getHID().getDevices();
    return devices.filter((d)=>d.vendorId === (0, _devices.ledgerUSBVendorId));
}
async function getFirstLedgerDevice() {
    const existingDevices = await getLedgerDevices();
    if (existingDevices.length > 0) return existingDevices[0];
    const devices = await requestLedgerDevices();
    return devices[0];
}
class TransportWebHID extends (0, _hwTransportDefault.default) {
    constructor(device){
        super();
        this.device = void 0;
        this.deviceModel = void 0;
        this.channel = Math.floor(Math.random() * 0xffff);
        this.packetSize = 64;
        this.inputs = [];
        this.inputCallback = void 0;
        this.read = ()=>{
            if (this.inputs.length) return Promise.resolve(this.inputs.shift());
            return new Promise((success)=>{
                this.inputCallback = success;
            });
        };
        this.onInputReport = (e)=>{
            const buffer = Buffer.from(e.data.buffer);
            if (this.inputCallback) {
                this.inputCallback(buffer);
                this.inputCallback = null;
            } else this.inputs.push(buffer);
        };
        this._disconnectEmitted = false;
        this._emitDisconnect = (e)=>{
            if (this._disconnectEmitted) return;
            this._disconnectEmitted = true;
            this.emit("disconnect", e);
        };
        this.exchange = (apdu)=>this.exchangeAtomicImpl(async ()=>{
                const { channel , packetSize  } = this;
                (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));
                const framing = (0, _hidFramingDefault.default)(channel, packetSize); // Write...
                const blocks = framing.makeBlocks(apdu);
                for(let i = 0; i < blocks.length; i++)await this.device.sendReport(0, blocks[i]);
                 // Read...
                let result;
                let acc;
                while(!(result = framing.getReducedResult(acc))){
                    const buffer = await this.read();
                    acc = framing.reduceResponse(acc, buffer);
                }
                (0, _logs.log)("apdu", "<= " + result.toString("hex"));
                return result;
            }).catch((e)=>{
                if (e && e.message && e.message.includes("write")) {
                    this._emitDisconnect(e);
                    throw new (0, _errors.DisconnectedDeviceDuringOperation)(e.message);
                }
                throw e;
            });
        this.device = device;
        this.deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
        device.addEventListener("inputreport", this.onInputReport);
    }
    /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */ static async request() {
        const [device] = await requestLedgerDevices();
        return TransportWebHID.open(device);
    }
    /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */ static async openConnected() {
        const devices = await getLedgerDevices();
        if (devices.length === 0) return null;
        return TransportWebHID.open(devices[0]);
    }
    /**
   * Create a Ledger transport with a HIDDevice
   */ static async open(device) {
        await device.open();
        const transport = new TransportWebHID(device);
        const onDisconnect = (e)=>{
            if (device === e.device) {
                getHID().removeEventListener("disconnect", onDisconnect);
                transport._emitDisconnect(new (0, _errors.DisconnectedDevice)());
            }
        };
        getHID().addEventListener("disconnect", onDisconnect);
        return transport;
    }
    /**
   * Release the transport device
   */ async close() {
        await this.exchangeBusyPromise;
        this.device.removeEventListener("inputreport", this.onInputReport);
        await this.device.close();
    }
    /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */ setScrambleKey() {}
}
exports.default = TransportWebHID;
TransportWebHID.isSupported = isSupported;
TransportWebHID.list = getLedgerDevices;
TransportWebHID.listen = (observer)=>{
    let unsubscribed = false;
    getFirstLedgerDevice().then((device)=>{
        if (!device) observer.error(new (0, _errors.TransportOpenUserCancelled)("Access denied to use Ledger device"));
        else if (!unsubscribed) {
            const deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
            observer.next({
                type: "add",
                descriptor: device,
                deviceModel
            });
            observer.complete();
        }
    }, (error)=>{
        observer.error(new (0, _errors.TransportOpenUserCancelled)(error.message));
    });
    function unsubscribe() {
        unsubscribed = true;
    }
    return {
        unsubscribe
    };
};

},{"@ledgerhq/hw-transport":"59Ey9","@ledgerhq/devices/lib/hid-framing":"fvgJh","@ledgerhq/devices":"fnHxP","@ledgerhq/logs":"i4OI0","@ledgerhq/errors":"e0rTV","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gICot":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable prefer-template */ var _hwTransport = require("@ledgerhq/hw-transport");
var _hwTransportDefault = parcelHelpers.interopDefault(_hwTransport);
var _errors = require("@ledgerhq/errors");
var _devices = require("@ledgerhq/devices");
var _sendAPDU = require("@ledgerhq/devices/lib/ble/sendAPDU");
var _receiveAPDU = require("@ledgerhq/devices/lib/ble/receiveAPDU");
var _logs = require("@ledgerhq/logs");
var _rxjs = require("rxjs");
var _operators = require("rxjs/operators");
var _monitorCharacteristic = require("./monitorCharacteristic");
var Buffer = require("buffer").Buffer;
const requiresBluetooth = ()=>{
    // $FlowFixMe
    const { bluetooth  } = navigator;
    if (typeof bluetooth === "undefined") throw new Error("web bluetooth not supported");
    return bluetooth;
};
const availability = ()=>(0, _rxjs.Observable).create((observer)=>{
        const bluetooth = requiresBluetooth();
        const onAvailabilityChanged = (e)=>{
            observer.next(e.value);
        };
        bluetooth.addEventListener("availabilitychanged", onAvailabilityChanged);
        let unsubscribed = false;
        bluetooth.getAvailability().then((available)=>{
            if (!unsubscribed) observer.next(available);
        });
        return ()=>{
            unsubscribed = true;
            bluetooth.removeEventListener("availabilitychanged", onAvailabilityChanged);
        };
    });
const transportsCache = {};
const requestDeviceParam = ()=>({
        filters: (0, _devices.getBluetoothServiceUuids)().map((uuid)=>({
                services: [
                    uuid
                ]
            }))
    });
const retrieveService = async (device)=>{
    if (!device.gatt) throw new Error("bluetooth gatt not found");
    const [service] = await device.gatt.getPrimaryServices();
    if (!service) throw new Error("bluetooth service not found");
    const infos = (0, _devices.getInfosForServiceUuid)(service.uuid);
    if (!infos) throw new Error("bluetooth service infos not found");
    return [
        service,
        infos
    ];
};
async function open(deviceOrId, needsReconnect) {
    let device;
    if (typeof deviceOrId === "string") {
        if (transportsCache[deviceOrId]) {
            (0, _logs.log)("ble-verbose", "Transport in cache, using that.");
            return transportsCache[deviceOrId];
        }
        const bluetooth = requiresBluetooth(); // TODO instead we should "query" the device by its ID
        device = await bluetooth.requestDevice(requestDeviceParam());
    } else device = deviceOrId;
    if (!device.gatt.connected) {
        (0, _logs.log)("ble-verbose", "not connected. connecting...");
        await device.gatt.connect();
    }
    const [service, infos] = await retrieveService(device);
    const { deviceModel , writeUuid , notifyUuid  } = infos;
    const [writeC, notifyC] = await Promise.all([
        service.getCharacteristic(writeUuid),
        service.getCharacteristic(notifyUuid)
    ]);
    const notifyObservable = (0, _monitorCharacteristic.monitorCharacteristic)(notifyC).pipe((0, _operators.tap)((value)=>{
        (0, _logs.log)("ble-frame", "<= " + value.toString("hex"));
    }), (0, _operators.share)());
    const notif = notifyObservable.subscribe();
    const transport = new BluetoothTransport(device, writeC, notifyObservable, deviceModel);
    if (!device.gatt.connected) throw new (0, _errors.DisconnectedDevice)();
     // eslint-disable-next-line require-atomic-updates
    transportsCache[transport.id] = transport;
    const onDisconnect = (e)=>{
        console.log("onDisconnect!", e);
        delete transportsCache[transport.id];
        transport.notYetDisconnected = false;
        notif.unsubscribe();
        device.removeEventListener("gattserverdisconnected", onDisconnect);
        (0, _logs.log)("ble-verbose", `BleTransport(${transport.id}) disconnected`);
        transport.emit("disconnect", e);
    };
    device.addEventListener("gattserverdisconnected", onDisconnect);
    let beforeMTUTime = Date.now();
    try {
        await transport.inferMTU();
    } finally{
        let afterMTUTime = Date.now(); // workaround for #279: we need to open() again if we come the first time here,
        // to make sure we do a disconnect() after the first pairing time
        // because of a firmware bug
        if (afterMTUTime - beforeMTUTime < 1000) needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.
        if (needsReconnect) {
            await device.gatt.disconnect(); // necessary time for the bonding workaround
            await new Promise((s)=>setTimeout(s, 4000));
        }
    }
    if (needsReconnect) return open(device, false);
    return transport;
}
class BluetoothTransport extends (0, _hwTransportDefault.default) {
    /**
   * observe event with { available: bool, type: string }
   * (available is generic, type is specific)
   * an event is emit once and then each time it changes
   */ /**
   * Scan for Ledger Bluetooth devices.
   * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).
   */ static listen(observer) {
        (0, _logs.log)("ble-verbose", "listen...");
        let unsubscribed;
        const bluetooth = requiresBluetooth();
        bluetooth.requestDevice(requestDeviceParam()).then(async (device)=>{
            if (!unsubscribed) {
                observer.next({
                    type: "add",
                    descriptor: device
                });
                observer.complete();
            }
        }, (error)=>{
            observer.error(new (0, _errors.TransportOpenUserCancelled)(error.message));
        });
        function unsubscribe() {
            unsubscribed = true;
        }
        return {
            unsubscribe
        };
    }
    /**
   * open a bluetooth device.
   */ static async open(deviceOrId) {
        return open(deviceOrId, true);
    }
    /**
   * globally disconnect a bluetooth device by its id.
   */ constructor(device, writeCharacteristic, notifyObservable, deviceModel){
        super();
        this.id = void 0;
        this.device = void 0;
        this.mtuSize = 20;
        this.writeCharacteristic = void 0;
        this.notifyObservable = void 0;
        this.notYetDisconnected = true;
        this.deviceModel = void 0;
        this.exchange = (apdu)=>this.exchangeAtomicImpl(async ()=>{
                try {
                    const msgIn = apdu.toString("hex");
                    (0, _logs.log)("apdu", `=> ${msgIn}`);
                    const data = await (0, _rxjs.merge)(this.notifyObservable.pipe((0, _receiveAPDU.receiveAPDU)), (0, _sendAPDU.sendAPDU)(this.write, apdu, this.mtuSize)).toPromise();
                    const msgOut = data.toString("hex");
                    (0, _logs.log)("apdu", `<= ${msgOut}`);
                    return data;
                } catch (e) {
                    (0, _logs.log)("ble-error", "exchange got " + String(e));
                    if (this.notYetDisconnected) // in such case we will always disconnect because something is bad.
                    this.device.gatt.disconnect();
                    throw e;
                }
            });
        this.write = async (buffer)=>{
            (0, _logs.log)("ble-frame", "=> " + buffer.toString("hex"));
            await this.writeCharacteristic.writeValue(buffer);
        };
        this.id = device.id;
        this.device = device;
        this.writeCharacteristic = writeCharacteristic;
        this.notifyObservable = notifyObservable;
        this.deviceModel = deviceModel;
        (0, _logs.log)("ble-verbose", `BleTransport(${String(this.id)}) new instance`);
    }
    async inferMTU() {
        let mtu = 23;
        await this.exchangeAtomicImpl(async ()=>{
            try {
                mtu = await (0, _rxjs.merge)(this.notifyObservable.pipe((0, _operators.first)((buffer)=>buffer.readUInt8(0) === 0x08), (0, _operators.map)((buffer)=>buffer.readUInt8(5))), (0, _rxjs.defer)(()=>(0, _rxjs.from)(this.write(Buffer.from([
                        0x08,
                        0,
                        0,
                        0,
                        0
                    ])))).pipe((0, _operators.ignoreElements)())).toPromise() + 3;
            } catch (e) {
                (0, _logs.log)("ble-error", "inferMTU got " + String(e));
                this.device.gatt.disconnect();
                throw e;
            }
        });
        if (mtu > 23) {
            const mtuSize = mtu - 3;
            (0, _logs.log)("ble-verbose", `BleTransport(${String(this.id)}) mtu set to ${String(mtuSize)}`);
            this.mtuSize = mtuSize;
        }
        return this.mtuSize;
    }
    /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */ setScrambleKey() {}
    async close() {
        if (this.exchangeBusyPromise) await this.exchangeBusyPromise;
    }
}
exports.default = BluetoothTransport;
BluetoothTransport.isSupported = ()=>Promise.resolve().then(requiresBluetooth).then(()=>true, ()=>false);
BluetoothTransport.observeAvailability = (observer)=>availability.subscribe(observer);
BluetoothTransport.list = ()=>Promise.resolve([]);
BluetoothTransport.disconnect = async (id)=>{
    (0, _logs.log)("ble-verbose", `user disconnect(${id})`);
    const transport = transportsCache[id];
    if (transport) transport.device.gatt.disconnect();
};

},{"@ledgerhq/hw-transport":"59Ey9","@ledgerhq/errors":"e0rTV","@ledgerhq/devices":"fnHxP","@ledgerhq/devices/lib/ble/sendAPDU":"fUw1B","@ledgerhq/devices/lib/ble/receiveAPDU":"4idmO","@ledgerhq/logs":"i4OI0","rxjs":"eNCF7","rxjs/operators":"hZ5Xz","./monitorCharacteristic":"cIuop","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fUw1B":[function(require,module,exports) {
"use strict";
var Buffer = require("buffer").Buffer;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sendAPDU = void 0;
var _rxjs = require("rxjs");
var _logs = require("@ledgerhq/logs");
const TagId = 0x05;
function chunkBuffer(buffer, sizeForIndex) {
    const chunks = [];
    for(let i = 0, size = sizeForIndex(0); i < buffer.length; i += size, size = sizeForIndex(i))chunks.push(buffer.slice(i, i + size));
    return chunks;
}
const sendAPDU = (write, apdu, mtuSize)=>{
    const chunks = chunkBuffer(apdu, (i)=>mtuSize - (i === 0 ? 5 : 3)).map((buffer, i)=>{
        const head = Buffer.alloc(i === 0 ? 5 : 3);
        head.writeUInt8(TagId, 0);
        head.writeUInt16BE(i, 1);
        if (i === 0) head.writeUInt16BE(apdu.length, 3);
        return Buffer.concat([
            head,
            buffer
        ]);
    });
    return _rxjs.Observable.create((o)=>{
        let terminated = false;
        async function main() {
            for (const chunk of chunks){
                if (terminated) return;
                await write(chunk);
            }
        }
        main().then(()=>{
            terminated = true;
            o.complete();
        }, (e)=>{
            terminated = true;
            (0, _logs.log)("ble-error", "sendAPDU failure " + String(e));
            o.error(e);
        });
        const unsubscribe = ()=>{
            if (!terminated) {
                (0, _logs.log)("ble-verbose", "sendAPDU interruption");
                terminated = true;
            }
        };
        return unsubscribe;
    });
};
exports.sendAPDU = sendAPDU;

},{"buffer":"fCgem","rxjs":"eNCF7","@ledgerhq/logs":"i4OI0"}],"eNCF7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "Observable", ()=>(0, _observable.Observable));
parcelHelpers.export(exports, "ConnectableObservable", ()=>(0, _connectableObservable.ConnectableObservable));
parcelHelpers.export(exports, "GroupedObservable", ()=>(0, _groupBy.GroupedObservable));
parcelHelpers.export(exports, "observable", ()=>(0, _observable1.observable));
parcelHelpers.export(exports, "Subject", ()=>(0, _subject.Subject));
parcelHelpers.export(exports, "BehaviorSubject", ()=>(0, _behaviorSubject.BehaviorSubject));
parcelHelpers.export(exports, "ReplaySubject", ()=>(0, _replaySubject.ReplaySubject));
parcelHelpers.export(exports, "AsyncSubject", ()=>(0, _asyncSubject.AsyncSubject));
parcelHelpers.export(exports, "asap", ()=>(0, _asap.asap));
parcelHelpers.export(exports, "asapScheduler", ()=>(0, _asap.asapScheduler));
parcelHelpers.export(exports, "async", ()=>(0, _async.async));
parcelHelpers.export(exports, "asyncScheduler", ()=>(0, _async.asyncScheduler));
parcelHelpers.export(exports, "queue", ()=>(0, _queue.queue));
parcelHelpers.export(exports, "queueScheduler", ()=>(0, _queue.queueScheduler));
parcelHelpers.export(exports, "animationFrame", ()=>(0, _animationFrame.animationFrame));
parcelHelpers.export(exports, "animationFrameScheduler", ()=>(0, _animationFrame.animationFrameScheduler));
parcelHelpers.export(exports, "VirtualTimeScheduler", ()=>(0, _virtualTimeScheduler.VirtualTimeScheduler));
parcelHelpers.export(exports, "VirtualAction", ()=>(0, _virtualTimeScheduler.VirtualAction));
parcelHelpers.export(exports, "Scheduler", ()=>(0, _scheduler.Scheduler));
parcelHelpers.export(exports, "Subscription", ()=>(0, _subscription.Subscription));
parcelHelpers.export(exports, "Subscriber", ()=>(0, _subscriber.Subscriber));
parcelHelpers.export(exports, "Notification", ()=>(0, _notification.Notification));
parcelHelpers.export(exports, "NotificationKind", ()=>(0, _notification.NotificationKind));
parcelHelpers.export(exports, "pipe", ()=>(0, _pipe.pipe));
parcelHelpers.export(exports, "noop", ()=>(0, _noop.noop));
parcelHelpers.export(exports, "identity", ()=>(0, _identity.identity));
parcelHelpers.export(exports, "isObservable", ()=>(0, _isObservable.isObservable));
parcelHelpers.export(exports, "ArgumentOutOfRangeError", ()=>(0, _argumentOutOfRangeError.ArgumentOutOfRangeError));
parcelHelpers.export(exports, "EmptyError", ()=>(0, _emptyError.EmptyError));
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>(0, _objectUnsubscribedError.ObjectUnsubscribedError));
parcelHelpers.export(exports, "UnsubscriptionError", ()=>(0, _unsubscriptionError.UnsubscriptionError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _timeoutError.TimeoutError));
parcelHelpers.export(exports, "bindCallback", ()=>(0, _bindCallback.bindCallback));
parcelHelpers.export(exports, "bindNodeCallback", ()=>(0, _bindNodeCallback.bindNodeCallback));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "defer", ()=>(0, _defer.defer));
parcelHelpers.export(exports, "empty", ()=>(0, _empty.empty));
parcelHelpers.export(exports, "forkJoin", ()=>(0, _forkJoin.forkJoin));
parcelHelpers.export(exports, "from", ()=>(0, _from.from));
parcelHelpers.export(exports, "fromEvent", ()=>(0, _fromEvent.fromEvent));
parcelHelpers.export(exports, "fromEventPattern", ()=>(0, _fromEventPattern.fromEventPattern));
parcelHelpers.export(exports, "generate", ()=>(0, _generate.generate));
parcelHelpers.export(exports, "iif", ()=>(0, _iif.iif));
parcelHelpers.export(exports, "interval", ()=>(0, _interval.interval));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "never", ()=>(0, _never.never));
parcelHelpers.export(exports, "of", ()=>(0, _of.of));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNext.onErrorResumeNext));
parcelHelpers.export(exports, "pairs", ()=>(0, _pairs.pairs));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "range", ()=>(0, _range.range));
parcelHelpers.export(exports, "throwError", ()=>(0, _throwError.throwError));
parcelHelpers.export(exports, "timer", ()=>(0, _timer.timer));
parcelHelpers.export(exports, "using", ()=>(0, _using.using));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "scheduled", ()=>(0, _scheduled.scheduled));
parcelHelpers.export(exports, "EMPTY", ()=>(0, _empty.EMPTY));
parcelHelpers.export(exports, "NEVER", ()=>(0, _never.NEVER));
parcelHelpers.export(exports, "config", ()=>(0, _config.config));
var _observable = require("./internal/Observable");
var _connectableObservable = require("./internal/observable/ConnectableObservable");
var _groupBy = require("./internal/operators/groupBy");
var _observable1 = require("./internal/symbol/observable");
var _subject = require("./internal/Subject");
var _behaviorSubject = require("./internal/BehaviorSubject");
var _replaySubject = require("./internal/ReplaySubject");
var _asyncSubject = require("./internal/AsyncSubject");
var _asap = require("./internal/scheduler/asap");
var _async = require("./internal/scheduler/async");
var _queue = require("./internal/scheduler/queue");
var _animationFrame = require("./internal/scheduler/animationFrame");
var _virtualTimeScheduler = require("./internal/scheduler/VirtualTimeScheduler");
var _scheduler = require("./internal/Scheduler");
var _subscription = require("./internal/Subscription");
var _subscriber = require("./internal/Subscriber");
var _notification = require("./internal/Notification");
var _pipe = require("./internal/util/pipe");
var _noop = require("./internal/util/noop");
var _identity = require("./internal/util/identity");
var _isObservable = require("./internal/util/isObservable");
var _argumentOutOfRangeError = require("./internal/util/ArgumentOutOfRangeError");
var _emptyError = require("./internal/util/EmptyError");
var _objectUnsubscribedError = require("./internal/util/ObjectUnsubscribedError");
var _unsubscriptionError = require("./internal/util/UnsubscriptionError");
var _timeoutError = require("./internal/util/TimeoutError");
var _bindCallback = require("./internal/observable/bindCallback");
var _bindNodeCallback = require("./internal/observable/bindNodeCallback");
var _combineLatest = require("./internal/observable/combineLatest");
var _concat = require("./internal/observable/concat");
var _defer = require("./internal/observable/defer");
var _empty = require("./internal/observable/empty");
var _forkJoin = require("./internal/observable/forkJoin");
var _from = require("./internal/observable/from");
var _fromEvent = require("./internal/observable/fromEvent");
var _fromEventPattern = require("./internal/observable/fromEventPattern");
var _generate = require("./internal/observable/generate");
var _iif = require("./internal/observable/iif");
var _interval = require("./internal/observable/interval");
var _merge = require("./internal/observable/merge");
var _never = require("./internal/observable/never");
var _of = require("./internal/observable/of");
var _onErrorResumeNext = require("./internal/observable/onErrorResumeNext");
var _pairs = require("./internal/observable/pairs");
var _partition = require("./internal/observable/partition");
var _race = require("./internal/observable/race");
var _range = require("./internal/observable/range");
var _throwError = require("./internal/observable/throwError");
var _timer = require("./internal/observable/timer");
var _using = require("./internal/observable/using");
var _zip = require("./internal/observable/zip");
var _scheduled = require("./internal/scheduled/scheduled");
var _config = require("./internal/config");

},{"./internal/Observable":"1asgn","./internal/observable/ConnectableObservable":"hntQC","./internal/operators/groupBy":"bCSbE","./internal/symbol/observable":"8PNwn","./internal/Subject":"l0BZI","./internal/BehaviorSubject":"jcpl4","./internal/ReplaySubject":"bSMcd","./internal/AsyncSubject":"bxydg","./internal/scheduler/asap":"7sZZh","./internal/scheduler/async":"04lHJ","./internal/scheduler/queue":"TSoO9","./internal/scheduler/animationFrame":"bfCCp","./internal/scheduler/VirtualTimeScheduler":"b7Iyp","./internal/Scheduler":"bPLJk","./internal/Subscription":"7CEw9","./internal/Subscriber":"bwPOT","./internal/Notification":"6LPyO","./internal/util/pipe":"8dpHw","./internal/util/noop":"cB2ox","./internal/util/identity":"2wO6M","./internal/util/isObservable":"8iLIa","./internal/util/ArgumentOutOfRangeError":"eVyky","./internal/util/EmptyError":"8nE0j","./internal/util/ObjectUnsubscribedError":"atyud","./internal/util/UnsubscriptionError":"43t7f","./internal/util/TimeoutError":"f9mmi","./internal/observable/bindCallback":"jFIOz","./internal/observable/bindNodeCallback":"178VF","./internal/observable/combineLatest":"hrt6M","./internal/observable/concat":"4CcsK","./internal/observable/defer":"iYBVz","./internal/observable/empty":"d0sAg","./internal/observable/forkJoin":"bT0Lu","./internal/observable/from":"iYTWI","./internal/observable/fromEvent":"5kZoa","./internal/observable/fromEventPattern":"d5bLz","./internal/observable/generate":"cZiPw","./internal/observable/iif":"ciOCA","./internal/observable/interval":"8kp6s","./internal/observable/merge":"3kGhP","./internal/observable/never":"fpMWE","./internal/observable/of":"knjPI","./internal/observable/onErrorResumeNext":"3XoV6","./internal/observable/pairs":"3GL3V","./internal/observable/partition":"3ya8q","./internal/observable/race":"7v9a2","./internal/observable/range":"50mSF","./internal/observable/throwError":"figu7","./internal/observable/timer":"yD2Dx","./internal/observable/using":"7bCt7","./internal/observable/zip":"cw7ce","./internal/scheduled/scheduled":"jHmGq","./internal/config":"799TV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1asgn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Observable", ()=>Observable);
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */ var _canReportError = require("./util/canReportError");
var _toSubscriber = require("./util/toSubscriber");
var _observable = require("./symbol/observable");
var _pipe = require("./util/pipe");
var _config = require("./config");
var Observable = /*@__PURE__*/ function() {
    function Observable1(subscribe) {
        this._isScalar = false;
        if (subscribe) this._subscribe = subscribe;
    }
    Observable1.prototype.lift = function(operator) {
        var observable = new Observable1();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable1.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = (0, _toSubscriber.toSubscriber)(observerOrNext, error, complete);
        if (operator) sink.add(operator.call(sink, this.source));
        else sink.add(this.source || (0, _config.config).useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable1.prototype._trySubscribe = function(sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if ((0, _canReportError.canReportError)(sink)) sink.error(err);
            else console.warn(err);
        }
    };
    Observable1.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function(value) {
                try {
                    next(value);
                } catch (err) {
                    reject(err);
                    if (subscription) subscription.unsubscribe();
                }
            }, reject, resolve);
        });
    };
    Observable1.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable1.prototype[0, _observable.observable] = function() {
        return this;
    };
    Observable1.prototype.pipe = function() {
        var operations = [];
        for(var _i = 0; _i < arguments.length; _i++)operations[_i] = arguments[_i];
        if (operations.length === 0) return this;
        return (0, _pipe.pipeFromArray)(operations)(this);
    };
    Observable1.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x) {
                return value = x;
            }, function(err) {
                return reject(err);
            }, function() {
                return resolve(value);
            });
        });
    };
    Observable1.create = function(subscribe) {
        return new Observable1(subscribe);
    };
    return Observable1;
}();
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) promiseCtor = (0, _config.config).Promise || Promise;
    if (!promiseCtor) throw new Error("no Promise impl found");
    return promiseCtor;
}

},{"./util/canReportError":"b6CwD","./util/toSubscriber":"l8Mkt","./symbol/observable":"8PNwn","./util/pipe":"8dpHw","./config":"799TV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6CwD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canReportError", ()=>canReportError);
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */ var _subscriber = require("../Subscriber");
function canReportError(observer) {
    while(observer){
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) return false;
        else if (destination && destination instanceof (0, _subscriber.Subscriber)) observer = destination;
        else observer = null;
    }
    return true;
}

},{"../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bwPOT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscriber", ()=>Subscriber);
parcelHelpers.export(exports, "SafeSubscriber", ()=>SafeSubscriber);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */ var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _observer = require("./Observer");
var _subscription = require("./Subscription");
var _rxSubscriber = require("../internal/symbol/rxSubscriber");
var _config = require("./config");
var _hostReportError = require("./util/hostReportError");
var Subscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(Subscriber1, _super);
    function Subscriber1(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch(arguments.length){
            case 0:
                _this.destination = (0, _observer.empty);
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = (0, _observer.empty);
                    break;
                }
                if (typeof destinationOrNext === "object") {
                    if (destinationOrNext instanceof Subscriber1) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    } else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber1.prototype[0, _rxSubscriber.rxSubscriber] = function() {
        return this;
    };
    Subscriber1.create = function(next, error, complete) {
        var subscriber = new Subscriber1(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber1.prototype.next = function(value) {
        if (!this.isStopped) this._next(value);
    };
    Subscriber1.prototype.error = function(err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber1.prototype.complete = function() {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber1.prototype.unsubscribe = function() {
        if (this.closed) return;
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber1.prototype._next = function(value) {
        this.destination.next(value);
    };
    Subscriber1.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber1.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber1.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber1;
}((0, _subscription.Subscription));
var SafeSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(SafeSubscriber1, _super);
    function SafeSubscriber1(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if ((0, _isFunction.isFunction)(observerOrNext)) next = observerOrNext;
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== (0, _observer.empty)) {
                context = Object.create(observerOrNext);
                if ((0, _isFunction.isFunction)(context.unsubscribe)) _this.add(context.unsubscribe.bind(context));
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber1.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!(0, _config.config).useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) this.__tryOrUnsub(this._next, value);
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) this.unsubscribe();
        }
    };
    SafeSubscriber1.prototype.error = function(err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = (0, _config.config).useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) throw err;
                (0, _hostReportError.hostReportError)(err);
            } else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                } else (0, _hostReportError.hostReportError)(err);
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber1.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function() {
                    return _this._complete.call(_this._context);
                };
                if (!(0, _config.config).useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            } else this.unsubscribe();
        }
    };
    SafeSubscriber1.prototype.__tryOrUnsub = function(fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            if ((0, _config.config).useDeprecatedSynchronousErrorHandling) throw err;
            else (0, _hostReportError.hostReportError)(err);
        }
    };
    SafeSubscriber1.prototype.__tryOrSetError = function(parent, fn, value) {
        if (!(0, _config.config).useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
        try {
            fn.call(this._context, value);
        } catch (err) {
            if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            } else {
                (0, _hostReportError.hostReportError)(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber1.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber1;
}(Subscriber);

},{"tslib":"99ylF","./util/isFunction":"jxvPW","./Observer":"hbZY4","./Subscription":"7CEw9","../internal/symbol/rxSubscriber":"d26AH","./config":"799TV","./util/hostReportError":"bmSNp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"99ylF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends);
parcelHelpers.export(exports, "__assign", ()=>__assign);
parcelHelpers.export(exports, "__rest", ()=>__rest);
parcelHelpers.export(exports, "__decorate", ()=>__decorate);
parcelHelpers.export(exports, "__param", ()=>__param);
parcelHelpers.export(exports, "__metadata", ()=>__metadata);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter);
parcelHelpers.export(exports, "__generator", ()=>__generator);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar);
parcelHelpers.export(exports, "__values", ()=>__values);
parcelHelpers.export(exports, "__read", ()=>__read);
parcelHelpers.export(exports, "__spread", ()=>__spread);
parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays);
parcelHelpers.export(exports, "__await", ()=>__await);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject);
parcelHelpers.export(exports, "__importStar", ()=>__importStar);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d1, b1) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
    };
    return extendStatics(d1, b1);
};
function __extends(d, b) {
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}
function __exportStar(m, exports) {
    for(var p in m)if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: n === "return"
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v1) {
        Promise.resolve(v1).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result.default = mod;
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
    return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) throw new TypeError("attempted to set private field on non-instance");
    privateMap.set(receiver, value);
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jxvPW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "isFunction", ()=>isFunction);
function isFunction(x) {
    return typeof x === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hbZY4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "empty", ()=>empty);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */ var _config = require("./config");
var _hostReportError = require("./util/hostReportError");
var empty = {
    closed: true,
    next: function(value) {},
    error: function(err) {
        if ((0, _config.config).useDeprecatedSynchronousErrorHandling) throw err;
        else (0, _hostReportError.hostReportError)(err);
    },
    complete: function() {}
};

},{"./config":"799TV","./util/hostReportError":"bmSNp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"799TV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling (value){
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) /*@__PURE__*/ console.log("RxJS: Back to a better error behavior. Thank you. <3");
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling () {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bmSNp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "hostReportError", ()=>hostReportError);
function hostReportError(err) {
    setTimeout(function() {
        throw err;
    }, 0);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CEw9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription);
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */ var _isArray = require("./util/isArray");
var _isObject = require("./util/isObject");
var _isFunction = require("./util/isFunction");
var _unsubscriptionError = require("./util/UnsubscriptionError");
var Subscription = /*@__PURE__*/ function() {
    function Subscription1(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription1.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) return;
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription1) _parentOrParents.remove(this);
        else if (_parentOrParents !== null) for(var index = 0; index < _parentOrParents.length; ++index){
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
        }
        if ((0, _isFunction.isFunction)(_unsubscribe)) {
            if (_ctorUnsubscribe) this._unsubscribe = undefined;
            try {
                _unsubscribe.call(this);
            } catch (e) {
                errors = e instanceof (0, _unsubscriptionError.UnsubscriptionError) ? flattenUnsubscriptionErrors(e.errors) : [
                    e
                ];
            }
        }
        if ((0, _isArray.isArray)(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while(++index < len){
                var sub = _subscriptions[index];
                if ((0, _isObject.isObject)(sub)) try {
                    sub.unsubscribe();
                } catch (e) {
                    errors = errors || [];
                    if (e instanceof (0, _unsubscriptionError.UnsubscriptionError)) errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                    else errors.push(e);
                }
            }
        }
        if (errors) throw new (0, _unsubscriptionError.UnsubscriptionError)(errors);
    };
    Subscription1.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) return Subscription1.EMPTY;
        switch(typeof teardown){
            case "function":
                subscription = new Subscription1(teardown);
            case "object":
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") return subscription;
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (!(subscription instanceof Subscription1)) {
                    var tmp = subscription;
                    subscription = new Subscription1();
                    subscription._subscriptions = [
                        tmp
                    ];
                }
                break;
            default:
                throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) subscription._parentOrParents = this;
        else if (_parentOrParents instanceof Subscription1) {
            if (_parentOrParents === this) return subscription;
            subscription._parentOrParents = [
                _parentOrParents,
                this
            ];
        } else if (_parentOrParents.indexOf(this) === -1) _parentOrParents.push(this);
        else return subscription;
        var subscriptions = this._subscriptions;
        if (subscriptions === null) this._subscriptions = [
            subscription
        ];
        else subscriptions.push(subscription);
        return subscription;
    };
    Subscription1.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) subscriptions.splice(subscriptionIndex, 1);
        }
    };
    Subscription1.EMPTY = function(empty) {
        empty.closed = true;
        return empty;
    }(new Subscription1());
    return Subscription1;
}();
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function(errs, err) {
        return errs.concat(err instanceof (0, _unsubscriptionError.UnsubscriptionError) ? err.errors : err);
    }, []);
}

},{"./util/isArray":"7twlV","./util/isObject":"dwhYy","./util/isFunction":"jxvPW","./util/UnsubscriptionError":"43t7f","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7twlV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArray", ()=>isArray);
var isArray = /*@__PURE__*/ function() {
    return Array.isArray || function(x) {
        return x && typeof x.length === "number";
    };
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwhYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "isObject", ()=>isObject);
function isObject(x) {
    return x !== null && typeof x === "object";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"43t7f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsubscriptionError", ()=>UnsubscriptionError);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var UnsubscriptionErrorImpl = /*@__PURE__*/ function() {
    function UnsubscriptionErrorImpl1(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
            return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl1.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl1;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d26AH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rxSubscriber", ()=>rxSubscriber);
parcelHelpers.export(exports, "$$rxSubscriber", ()=>$$rxSubscriber);
var rxSubscriber = /*@__PURE__*/ function() {
    return typeof Symbol === "function" ? /*@__PURE__*/ Symbol("rxSubscriber") : "@@rxSubscriber_" + /*@__PURE__*/ Math.random();
}();
var $$rxSubscriber = rxSubscriber;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8Mkt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toSubscriber", ()=>toSubscriber);
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */ var _subscriber = require("../Subscriber");
var _rxSubscriber = require("../symbol/rxSubscriber");
var _observer = require("../Observer");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof (0, _subscriber.Subscriber)) return nextOrObserver;
        if (nextOrObserver[0, _rxSubscriber.rxSubscriber]) return nextOrObserver[0, _rxSubscriber.rxSubscriber]();
    }
    if (!nextOrObserver && !error && !complete) return new (0, _subscriber.Subscriber)((0, _observer.empty));
    return new (0, _subscriber.Subscriber)(nextOrObserver, error, complete);
}

},{"../Subscriber":"bwPOT","../symbol/rxSubscriber":"d26AH","../Observer":"hbZY4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PNwn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observable", ()=>observable);
var observable = /*@__PURE__*/ function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8dpHw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pipe", ()=>pipe);
parcelHelpers.export(exports, "pipeFromArray", ()=>pipeFromArray);
/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */ var _identity = require("./identity");
function pipe() {
    var fns = [];
    for(var _i = 0; _i < arguments.length; _i++)fns[_i] = arguments[_i];
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) return 0, _identity.identity;
    if (fns.length === 1) return fns[0];
    return function piped(input) {
        return fns.reduce(function(prev, fn) {
            return fn(prev);
        }, input);
    };
}

},{"./identity":"2wO6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2wO6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "identity", ()=>identity);
function identity(x) {
    return x;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hntQC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConnectableObservable", ()=>ConnectableObservable);
parcelHelpers.export(exports, "connectableObservableDescriptor", ()=>connectableObservableDescriptor);
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subject = require("../Subject");
var _observable = require("../Observable");
var _subscriber = require("../Subscriber");
var _subscription = require("../Subscription");
var _refCount = require("../operators/refCount");
var ConnectableObservable = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ConnectableObservable1, _super);
    function ConnectableObservable1(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable1.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable1.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) this._subject = this.subjectFactory();
        return this._subject;
    };
    ConnectableObservable1.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new (0, _subscription.Subscription)();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = (0, _subscription.Subscription).EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable1.prototype.refCount = function() {
        return (0, _refCount.refCount)()(this);
    };
    return ConnectableObservable1;
}((0, _observable.Observable));
var connectableObservableDescriptor = /*@__PURE__*/ function() {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: {
            value: null
        },
        _refCount: {
            value: 0,
            writable: true
        },
        _subject: {
            value: null,
            writable: true
        },
        _connection: {
            value: null,
            writable: true
        },
        _subscribe: {
            value: connectableProto._subscribe
        },
        _isComplete: {
            value: connectableProto._isComplete,
            writable: true
        },
        getSubject: {
            value: connectableProto.getSubject
        },
        connect: {
            value: connectableProto.connect
        },
        refCount: {
            value: connectableProto.refCount
        }
    };
}();
var ConnectableSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ConnectableSubscriber1, _super);
    function ConnectableSubscriber1(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber1.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber1.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber1.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) connection.unsubscribe();
        }
    };
    return ConnectableSubscriber1;
}((0, _subject.SubjectSubscriber));
var RefCountOperator = /*@__PURE__*/ function() {
    function RefCountOperator1(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator1.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) refCounter.connection = connectable.connect();
        return subscription;
    };
    return RefCountOperator1;
}();
var RefCountSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(RefCountSubscriber1, _super);
    function RefCountSubscriber1(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber1.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) sharedConnection.unsubscribe();
    };
    return RefCountSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subject":"l0BZI","../Observable":"1asgn","../Subscriber":"bwPOT","../Subscription":"7CEw9","../operators/refCount":"1xbxl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l0BZI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubjectSubscriber", ()=>SubjectSubscriber);
parcelHelpers.export(exports, "Subject", ()=>Subject);
parcelHelpers.export(exports, "AnonymousSubject", ()=>AnonymousSubject);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _observable = require("./Observable");
var _subscriber = require("./Subscriber");
var _subscription = require("./Subscription");
var _objectUnsubscribedError = require("./util/ObjectUnsubscribedError");
var _subjectSubscription = require("./SubjectSubscription");
var _rxSubscriber = require("../internal/symbol/rxSubscriber");
var SubjectSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(SubjectSubscriber1, _super);
    function SubjectSubscriber1(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber1;
}((0, _subscriber.Subscriber));
var Subject = /*@__PURE__*/ function(_super) {
    _tslib.__extends(Subject1, _super);
    function Subject1() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject1.prototype[0, _rxSubscriber.rxSubscriber] = function() {
        return new SubjectSubscriber(this);
    };
    Subject1.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject1.prototype.next = function(value) {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for(var i = 0; i < len; i++)copy[i].next(value);
        }
    };
    Subject1.prototype.error = function(err) {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for(var i = 0; i < len; i++)copy[i].error(err);
        this.observers.length = 0;
    };
    Subject1.prototype.complete = function() {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for(var i = 0; i < len; i++)copy[i].complete();
        this.observers.length = 0;
    };
    Subject1.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject1.prototype._trySubscribe = function(subscriber) {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        else return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject1.prototype._subscribe = function(subscriber) {
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return (0, _subscription.Subscription).EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return (0, _subscription.Subscription).EMPTY;
        } else {
            this.observers.push(subscriber);
            return new (0, _subjectSubscription.SubjectSubscription)(this, subscriber);
        }
    };
    Subject1.prototype.asObservable = function() {
        var observable = new (0, _observable.Observable)();
        observable.source = this;
        return observable;
    };
    Subject1.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject1;
}((0, _observable.Observable));
var AnonymousSubject = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AnonymousSubject1, _super);
    function AnonymousSubject1(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject1.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) destination.next(value);
    };
    AnonymousSubject1.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) this.destination.error(err);
    };
    AnonymousSubject1.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) this.destination.complete();
    };
    AnonymousSubject1.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) return this.source.subscribe(subscriber);
        else return (0, _subscription.Subscription).EMPTY;
    };
    return AnonymousSubject1;
}(Subject);

},{"tslib":"99ylF","./Observable":"1asgn","./Subscriber":"bwPOT","./Subscription":"7CEw9","./util/ObjectUnsubscribedError":"atyud","./SubjectSubscription":"dPfj1","../internal/symbol/rxSubscriber":"d26AH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"atyud":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObjectUnsubscribedError", ()=>ObjectUnsubscribedError);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ function() {
    function ObjectUnsubscribedErrorImpl1() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
    }
    ObjectUnsubscribedErrorImpl1.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl1;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dPfj1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SubjectSubscription", ()=>SubjectSubscription);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscription = require("./Subscription");
var SubjectSubscription = /*@__PURE__*/ function(_super) {
    _tslib.__extends(SubjectSubscription1, _super);
    function SubjectSubscription1(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription1.prototype.unsubscribe = function() {
        if (this.closed) return;
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) return;
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) observers.splice(subscriberIndex, 1);
    };
    return SubjectSubscription1;
}((0, _subscription.Subscription));

},{"tslib":"99ylF","./Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1xbxl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refCount", ()=>refCount);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ function() {
    function RefCountOperator1(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator1.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) refCounter.connection = connectable.connect();
        return subscription;
    };
    return RefCountOperator1;
}();
var RefCountSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(RefCountSubscriber1, _super);
    function RefCountSubscriber1(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber1.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount1 = connectable._refCount;
        if (refCount1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount1 - 1;
        if (refCount1 > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) sharedConnection.unsubscribe();
    };
    return RefCountSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bCSbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "groupBy", ()=>groupBy);
parcelHelpers.export(exports, "GroupedObservable", ()=>GroupedObservable);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
var _subscription = require("../Subscription");
var _observable = require("../Observable");
var _subject = require("../Subject");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function(source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
var GroupByOperator = /*@__PURE__*/ function() {
    function GroupByOperator1(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator1;
}();
var GroupBySubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(GroupBySubscriber1, _super);
    function GroupBySubscriber1(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber1.prototype._next = function(value) {
        var key;
        try {
            key = this.keySelector(value);
        } catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber1.prototype._group = function(value, key) {
        var groups = this.groups;
        if (!groups) groups = this.groups = new Map();
        var group = groups.get(key);
        var element;
        if (this.elementSelector) try {
            element = this.elementSelector(value);
        } catch (err) {
            this.error(err);
        }
        else element = value;
        if (!group) {
            group = this.subjectSelector ? this.subjectSelector() : new (0, _subject.Subject)();
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                } catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) group.next(element);
    };
    GroupBySubscriber1.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function(group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber1.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function(group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber1.prototype.removeGroup = function(key) {
        this.groups.delete(key);
    };
    GroupBySubscriber1.prototype.unsubscribe = function() {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) _super.prototype.unsubscribe.call(this);
        }
    };
    return GroupBySubscriber1;
}((0, _subscriber.Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(GroupDurationSubscriber1, _super);
    function GroupDurationSubscriber1(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber1.prototype._next = function(value) {
        this.complete();
    };
    GroupDurationSubscriber1.prototype._unsubscribe = function() {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) parent.removeGroup(key);
    };
    return GroupDurationSubscriber1;
}((0, _subscriber.Subscriber));
var GroupedObservable = /*@__PURE__*/ function(_super) {
    _tslib.__extends(GroupedObservable1, _super);
    function GroupedObservable1(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable1.prototype._subscribe = function(subscriber) {
        var subscription = new (0, _subscription.Subscription)();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) subscription.add(new InnerRefCountSubscription(refCountSubscription));
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable1;
}((0, _observable.Observable));
var InnerRefCountSubscription = /*@__PURE__*/ function(_super) {
    _tslib.__extends(InnerRefCountSubscription1, _super);
    function InnerRefCountSubscription1(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription1.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) parent.unsubscribe();
        }
    };
    return InnerRefCountSubscription1;
}((0, _subscription.Subscription));

},{"tslib":"99ylF","../Subscriber":"bwPOT","../Subscription":"7CEw9","../Observable":"1asgn","../Subject":"l0BZI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jcpl4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BehaviorSubject", ()=>BehaviorSubject);
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subject = require("./Subject");
var _objectUnsubscribedError = require("./util/ObjectUnsubscribedError");
var BehaviorSubject = /*@__PURE__*/ function(_super) {
    _tslib.__extends(BehaviorSubject1, _super);
    function BehaviorSubject1(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject1.prototype, "value", {
        get: function() {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject1.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) subscriber.next(this._value);
        return subscription;
    };
    BehaviorSubject1.prototype.getValue = function() {
        if (this.hasError) throw this.thrownError;
        else if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        else return this._value;
    };
    BehaviorSubject1.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject1;
}((0, _subject.Subject));

},{"tslib":"99ylF","./Subject":"l0BZI","./util/ObjectUnsubscribedError":"atyud","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bSMcd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ReplaySubject", ()=>ReplaySubject);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subject = require("./Subject");
var _queue = require("./scheduler/queue");
var _subscription = require("./Subscription");
var _observeOn = require("./operators/observeOn");
var _objectUnsubscribedError = require("./util/ObjectUnsubscribedError");
var _subjectSubscription = require("./SubjectSubscription");
var ReplaySubject = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ReplaySubject1, _super);
    function ReplaySubject1(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) bufferSize = Number.POSITIVE_INFINITY;
        if (windowTime === void 0) windowTime = Number.POSITIVE_INFINITY;
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        } else _this.next = _this.nextTimeWindow;
        return _this;
    }
    ReplaySubject1.prototype.nextInfiniteTimeWindow = function(value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject1.prototype.nextTimeWindow = function(value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject1.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) throw new (0, _objectUnsubscribedError.ObjectUnsubscribedError)();
        else if (this.isStopped || this.hasError) subscription = (0, _subscription.Subscription).EMPTY;
        else {
            this.observers.push(subscriber);
            subscription = new (0, _subjectSubscription.SubjectSubscription)(this, subscriber);
        }
        if (scheduler) subscriber.add(subscriber = new (0, _observeOn.ObserveOnSubscriber)(subscriber, scheduler));
        if (_infiniteTimeWindow) for(var i = 0; i < len && !subscriber.closed; i++)subscriber.next(_events[i]);
        else for(var i = 0; i < len && !subscriber.closed; i++)subscriber.next(_events[i].value);
        if (this.hasError) subscriber.error(this.thrownError);
        else if (this.isStopped) subscriber.complete();
        return subscription;
    };
    ReplaySubject1.prototype._getNow = function() {
        return (this.scheduler || (0, _queue.queue)).now();
    };
    ReplaySubject1.prototype._trimBufferThenGetEvents = function() {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while(spliceCount < eventsCount){
            if (now - _events[spliceCount].time < _windowTime) break;
            spliceCount++;
        }
        if (eventsCount > _bufferSize) spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        if (spliceCount > 0) _events.splice(0, spliceCount);
        return _events;
    };
    return ReplaySubject1;
}((0, _subject.Subject));
var ReplayEvent = /*@__PURE__*/ function() {
    function ReplayEvent1(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent1;
}();

},{"tslib":"99ylF","./Subject":"l0BZI","./scheduler/queue":"TSoO9","./Subscription":"7CEw9","./operators/observeOn":"eG2ED","./util/ObjectUnsubscribedError":"atyud","./SubjectSubscription":"dPfj1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"TSoO9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "queueScheduler", ()=>queueScheduler);
parcelHelpers.export(exports, "queue", ()=>queue);
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */ var _queueAction = require("./QueueAction");
var _queueScheduler = require("./QueueScheduler");
var queueScheduler = /*@__PURE__*/ new (0, _queueScheduler.QueueScheduler)((0, _queueAction.QueueAction));
var queue = queueScheduler;

},{"./QueueAction":"dispt","./QueueScheduler":"beDOW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dispt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueueAction", ()=>QueueAction);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var QueueAction = /*@__PURE__*/ function(_super) {
    _tslib.__extends(QueueAction1, _super);
    function QueueAction1(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction1.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (delay > 0) return _super.prototype.schedule.call(this, state, delay);
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction1.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction1.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        return scheduler.flush(this);
    };
    return QueueAction1;
}((0, _asyncAction.AsyncAction));

},{"tslib":"99ylF","./AsyncAction":"2T4TU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2T4TU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncAction", ()=>AsyncAction);
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */ var _tslib = require("tslib");
var _action = require("./Action");
var AsyncAction = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AsyncAction1, _super);
    function AsyncAction1(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction1.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (this.closed) return this;
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) this.id = this.recycleAsyncId(scheduler, id, delay);
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction1.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction1.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && this.delay === delay && this.pending === false) return id;
        clearInterval(id);
        return undefined;
    };
    AsyncAction1.prototype.execute = function(state, delay) {
        if (this.closed) return new Error("executing a cancelled action");
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) return error;
        else if (this.pending === false && this.id != null) this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    };
    AsyncAction1.prototype._execute = function(state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction1.prototype._unsubscribe = function() {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) actions.splice(index, 1);
        if (id != null) this.id = this.recycleAsyncId(scheduler, id, null);
        this.delay = null;
    };
    return AsyncAction1;
}((0, _action.Action));

},{"tslib":"99ylF","./Action":"iUHEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iUHEY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Action", ()=>Action);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscription = require("../Subscription");
var Action = /*@__PURE__*/ function(_super) {
    _tslib.__extends(Action1, _super);
    function Action1(scheduler, work) {
        return _super.call(this) || this;
    }
    Action1.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        return this;
    };
    return Action1;
}((0, _subscription.Subscription));

},{"tslib":"99ylF","../Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"beDOW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueueScheduler", ()=>QueueScheduler);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var QueueScheduler = /*@__PURE__*/ function(_super) {
    _tslib.__extends(QueueScheduler1, _super);
    function QueueScheduler1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler1;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"99ylF","./AsyncScheduler":"lGIsu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGIsu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncScheduler", ()=>AsyncScheduler);
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */ var _tslib = require("tslib");
var _scheduler = require("../Scheduler");
var AsyncScheduler = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AsyncScheduler1, _super);
    function AsyncScheduler1(SchedulerAction, now) {
        if (now === void 0) now = (0, _scheduler.Scheduler).now;
        var _this = _super.call(this, SchedulerAction, function() {
            if (AsyncScheduler1.delegate && AsyncScheduler1.delegate !== _this) return AsyncScheduler1.delegate.now();
            else return now();
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler1.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) delay = 0;
        if (AsyncScheduler1.delegate && AsyncScheduler1.delegate !== this) return AsyncScheduler1.delegate.schedule(work, delay, state);
        else return _super.prototype.schedule.call(this, work, delay, state);
    };
    AsyncScheduler1.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while (action = actions.shift());
        this.active = false;
        if (error) {
            while(action = actions.shift())action.unsubscribe();
            throw error;
        }
    };
    return AsyncScheduler1;
}((0, _scheduler.Scheduler));

},{"tslib":"99ylF","../Scheduler":"bPLJk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bPLJk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Scheduler", ()=>Scheduler);
var Scheduler = /*@__PURE__*/ function() {
    function Scheduler1(SchedulerAction, now) {
        if (now === void 0) now = Scheduler1.now;
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler1.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) delay = 0;
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler1.now = function() {
        return Date.now();
    };
    return Scheduler1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eG2ED":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "observeOn", ()=>observeOn);
parcelHelpers.export(exports, "ObserveOnOperator", ()=>ObserveOnOperator);
parcelHelpers.export(exports, "ObserveOnSubscriber", ()=>ObserveOnSubscriber);
parcelHelpers.export(exports, "ObserveOnMessage", ()=>ObserveOnMessage);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
var _notification = require("../Notification");
function observeOn(scheduler, delay) {
    if (delay === void 0) delay = 0;
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ function() {
    function ObserveOnOperator1(scheduler, delay) {
        if (delay === void 0) delay = 0;
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator1;
}();
var ObserveOnSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ObserveOnSubscriber1, _super);
    function ObserveOnSubscriber1(destination, scheduler, delay) {
        if (delay === void 0) delay = 0;
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber1.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber1.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber1.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber1.prototype._next = function(value) {
        this.scheduleMessage((0, _notification.Notification).createNext(value));
    };
    ObserveOnSubscriber1.prototype._error = function(err) {
        this.scheduleMessage((0, _notification.Notification).createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber1.prototype._complete = function() {
        this.scheduleMessage((0, _notification.Notification).createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber1;
}((0, _subscriber.Subscriber));
var ObserveOnMessage = /*@__PURE__*/ function() {
    function ObserveOnMessage1(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage1;
}();

},{"tslib":"99ylF","../Subscriber":"bwPOT","../Notification":"6LPyO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6LPyO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NotificationKind", ()=>NotificationKind);
parcelHelpers.export(exports, "Notification", ()=>Notification);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */ var _empty = require("./observable/empty");
var _of = require("./observable/of");
var _throwError = require("./observable/throwError");
var NotificationKind;
/*@__PURE__*/ (function(NotificationKind1) {
    NotificationKind1["NEXT"] = "N";
    NotificationKind1["ERROR"] = "E";
    NotificationKind1["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ function() {
    function Notification1(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
    }
    Notification1.prototype.observe = function(observer) {
        switch(this.kind){
            case "N":
                return observer.next && observer.next(this.value);
            case "E":
                return observer.error && observer.error(this.error);
            case "C":
                return observer.complete && observer.complete();
        }
    };
    Notification1.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch(kind){
            case "N":
                return next && next(this.value);
            case "E":
                return error && error(this.error);
            case "C":
                return complete && complete();
        }
    };
    Notification1.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") return this.observe(nextOrObserver);
        else return this.do(nextOrObserver, error, complete);
    };
    Notification1.prototype.toObservable = function() {
        var kind = this.kind;
        switch(kind){
            case "N":
                return (0, _of.of)(this.value);
            case "E":
                return (0, _throwError.throwError)(this.error);
            case "C":
                return (0, _empty.empty)();
        }
        throw new Error("unexpected notification kind value");
    };
    Notification1.createNext = function(value) {
        if (typeof value !== "undefined") return new Notification1("N", value);
        return Notification1.undefinedValueNotification;
    };
    Notification1.createError = function(err) {
        return new Notification1("E", undefined, err);
    };
    Notification1.createComplete = function() {
        return Notification1.completeNotification;
    };
    Notification1.completeNotification = new Notification1("C");
    Notification1.undefinedValueNotification = new Notification1("N", undefined);
    return Notification1;
}();

},{"./observable/empty":"d0sAg","./observable/of":"knjPI","./observable/throwError":"figu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d0sAg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMPTY", ()=>EMPTY);
parcelHelpers.export(exports, "empty", ()=>empty);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */ var _observable = require("../Observable");
var EMPTY = /*@__PURE__*/ new (0, _observable.Observable)(function(subscriber) {
    return subscriber.complete();
});
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        return scheduler.schedule(function() {
            return subscriber.complete();
        });
    });
}

},{"../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"knjPI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "of", ()=>of);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */ var _isScheduler = require("../util/isScheduler");
var _fromArray = require("./fromArray");
var _scheduleArray = require("../scheduled/scheduleArray");
function of() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    var scheduler = args[args.length - 1];
    if ((0, _isScheduler.isScheduler)(scheduler)) {
        args.pop();
        return (0, _scheduleArray.scheduleArray)(args, scheduler);
    } else return (0, _fromArray.fromArray)(args);
}

},{"../util/isScheduler":"8B5Pf","./fromArray":"fv7fx","../scheduled/scheduleArray":"bhg1a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8B5Pf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "isScheduler", ()=>isScheduler);
function isScheduler(value) {
    return value && typeof value.schedule === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fv7fx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromArray", ()=>fromArray);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscribeToArray = require("../util/subscribeToArray");
var _scheduleArray = require("../scheduled/scheduleArray");
function fromArray(input, scheduler) {
    if (!scheduler) return new (0, _observable.Observable)((0, _subscribeToArray.subscribeToArray)(input));
    else return (0, _scheduleArray.scheduleArray)(input, scheduler);
}

},{"../Observable":"1asgn","../util/subscribeToArray":"65pF8","../scheduled/scheduleArray":"bhg1a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"65pF8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeToArray", ()=>subscribeToArray);
var subscribeToArray = function(array) {
    return function(subscriber) {
        for(var i = 0, len = array.length; i < len && !subscriber.closed; i++)subscriber.next(array[i]);
        subscriber.complete();
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bhg1a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleArray", ()=>scheduleArray);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscription = require("../Subscription");
function scheduleArray(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var sub = new (0, _subscription.Subscription)();
        var i = 0;
        sub.add(scheduler.schedule(function() {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) sub.add(this.schedule());
        }));
        return sub;
    });
}

},{"../Observable":"1asgn","../Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"figu7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throwError", ()=>throwError);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */ var _observable = require("../Observable");
function throwError(error, scheduler) {
    if (!scheduler) return new (0, _observable.Observable)(function(subscriber) {
        return subscriber.error(error);
    });
    else return new (0, _observable.Observable)(function(subscriber) {
        return scheduler.schedule(dispatch, 0, {
            error: error,
            subscriber: subscriber
        });
    });
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

},{"../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxydg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncSubject", ()=>AsyncSubject);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subject = require("./Subject");
var _subscription = require("./Subscription");
var AsyncSubject = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AsyncSubject1, _super);
    function AsyncSubject1() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject1.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return (0, _subscription.Subscription).EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return (0, _subscription.Subscription).EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject1.prototype.next = function(value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject1.prototype.error = function(error) {
        if (!this.hasCompleted) _super.prototype.error.call(this, error);
    };
    AsyncSubject1.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) _super.prototype.next.call(this, this.value);
        _super.prototype.complete.call(this);
    };
    return AsyncSubject1;
}((0, _subject.Subject));

},{"tslib":"99ylF","./Subject":"l0BZI","./Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7sZZh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asapScheduler", ()=>asapScheduler);
parcelHelpers.export(exports, "asap", ()=>asap);
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */ var _asapAction = require("./AsapAction");
var _asapScheduler = require("./AsapScheduler");
var asapScheduler = /*@__PURE__*/ new (0, _asapScheduler.AsapScheduler)((0, _asapAction.AsapAction));
var asap = asapScheduler;

},{"./AsapAction":"Z0Wt5","./AsapScheduler":"dTW9t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Z0Wt5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapAction", ()=>AsapAction);
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */ var _tslib = require("tslib");
var _immediate = require("../util/Immediate");
var _asyncAction = require("./AsyncAction");
var AsapAction = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AsapAction1, _super);
    function AsapAction1(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction1.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = (0, _immediate.Immediate).setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction1.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        if (scheduler.actions.length === 0) {
            (0, _immediate.Immediate).clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction1;
}((0, _asyncAction.AsyncAction));

},{"tslib":"99ylF","../util/Immediate":"cxwVr","./AsyncAction":"2T4TU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cxwVr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Immediate", ()=>Immediate);
parcelHelpers.export(exports, "TestTools", ()=>TestTools);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var nextHandle = 1;
var RESOLVED = /*@__PURE__*/ function() {
    return /*@__PURE__*/ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
            return findAndClearHandle(handle) && cb();
        });
        return handle;
    },
    clearImmediate: function(handle) {
        findAndClearHandle(handle);
    }
};
var TestTools = {
    pending: function() {
        return Object.keys(activeHandles).length;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dTW9t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsapScheduler", ()=>AsapScheduler);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var AsapScheduler = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AsapScheduler1, _super);
    function AsapScheduler1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler1.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while(++index < count && (action = actions.shift()))action.unsubscribe();
            throw error;
        }
    };
    return AsapScheduler1;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"99ylF","./AsyncScheduler":"lGIsu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"04lHJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "asyncScheduler", ()=>asyncScheduler);
parcelHelpers.export(exports, "async", ()=>async);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */ var _asyncAction = require("./AsyncAction");
var _asyncScheduler = require("./AsyncScheduler");
var asyncScheduler = /*@__PURE__*/ new (0, _asyncScheduler.AsyncScheduler)((0, _asyncAction.AsyncAction));
var async = asyncScheduler;

},{"./AsyncAction":"2T4TU","./AsyncScheduler":"lGIsu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bfCCp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "animationFrameScheduler", ()=>animationFrameScheduler);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame);
/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */ var _animationFrameAction = require("./AnimationFrameAction");
var _animationFrameScheduler = require("./AnimationFrameScheduler");
var animationFrameScheduler = /*@__PURE__*/ new (0, _animationFrameScheduler.AnimationFrameScheduler)((0, _animationFrameAction.AnimationFrameAction));
var animationFrame = animationFrameScheduler;

},{"./AnimationFrameAction":"lMlee","./AnimationFrameScheduler":"8WPks","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lMlee":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnimationFrameAction", ()=>AnimationFrameAction);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var AnimationFrameAction = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AnimationFrameAction1, _super);
    function AnimationFrameAction1(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction1.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0) return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
            return scheduler.flush(null);
        }));
    };
    AnimationFrameAction1.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction1;
}((0, _asyncAction.AsyncAction));

},{"tslib":"99ylF","./AsyncAction":"2T4TU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8WPks":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnimationFrameScheduler", ()=>AnimationFrameScheduler);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncScheduler = require("./AsyncScheduler");
var AnimationFrameScheduler = /*@__PURE__*/ function(_super) {
    _tslib.__extends(AnimationFrameScheduler1, _super);
    function AnimationFrameScheduler1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler1.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) break;
        }while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while(++index < count && (action = actions.shift()))action.unsubscribe();
            throw error;
        }
    };
    return AnimationFrameScheduler1;
}((0, _asyncScheduler.AsyncScheduler));

},{"tslib":"99ylF","./AsyncScheduler":"lGIsu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b7Iyp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VirtualTimeScheduler", ()=>VirtualTimeScheduler);
parcelHelpers.export(exports, "VirtualAction", ()=>VirtualAction);
/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */ var _tslib = require("tslib");
var _asyncAction = require("./AsyncAction");
var _asyncScheduler = require("./AsyncScheduler");
var VirtualTimeScheduler = /*@__PURE__*/ function(_super) {
    _tslib.__extends(VirtualTimeScheduler1, _super);
    function VirtualTimeScheduler1(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) SchedulerAction = VirtualAction;
        if (maxFrames === void 0) maxFrames = Number.POSITIVE_INFINITY;
        var _this = _super.call(this, SchedulerAction, function() {
            return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler1.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while((action = actions[0]) && action.delay <= maxFrames){
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) break;
        }
        if (error) {
            while(action = actions.shift())action.unsubscribe();
            throw error;
        }
    };
    VirtualTimeScheduler1.frameTimeFactor = 10;
    return VirtualTimeScheduler1;
}((0, _asyncScheduler.AsyncScheduler));
var VirtualAction = /*@__PURE__*/ function(_super) {
    _tslib.__extends(VirtualAction1, _super);
    function VirtualAction1(scheduler, work, index) {
        if (index === void 0) index = scheduler.index += 1;
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction1.prototype.schedule = function(state, delay) {
        if (delay === void 0) delay = 0;
        if (!this.id) return _super.prototype.schedule.call(this, state, delay);
        this.active = false;
        var action = new VirtualAction1(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction1.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction1.sortActions);
        return true;
    };
    VirtualAction1.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) delay = 0;
        return undefined;
    };
    VirtualAction1.prototype._execute = function(state, delay) {
        if (this.active === true) return _super.prototype._execute.call(this, state, delay);
    };
    VirtualAction1.sortActions = function(a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) return 0;
            else if (a.index > b.index) return 1;
            else return -1;
        } else if (a.delay > b.delay) return 1;
        else return -1;
    };
    return VirtualAction1;
}((0, _asyncAction.AsyncAction));

},{"tslib":"99ylF","./AsyncAction":"2T4TU","./AsyncScheduler":"lGIsu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cB2ox":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "noop", ()=>noop);
function noop() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8iLIa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isObservable", ()=>isObservable);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */ var _observable = require("../Observable");
function isObservable(obj) {
    return !!obj && (obj instanceof (0, _observable.Observable) || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}

},{"../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eVyky":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ArgumentOutOfRangeError", ()=>ArgumentOutOfRangeError);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ function() {
    function ArgumentOutOfRangeErrorImpl1() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
    }
    ArgumentOutOfRangeErrorImpl1.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl1;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nE0j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmptyError", ()=>EmptyError);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var EmptyErrorImpl = /*@__PURE__*/ function() {
    function EmptyErrorImpl1() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
    }
    EmptyErrorImpl1.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return EmptyErrorImpl1;
}();
var EmptyError = EmptyErrorImpl;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f9mmi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ var TimeoutErrorImpl = /*@__PURE__*/ function() {
    function TimeoutErrorImpl1() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
    }
    TimeoutErrorImpl1.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl1;
}();
var TimeoutError = TimeoutErrorImpl;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFIOz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindCallback", ()=>bindCallback);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */ var _observable = require("../Observable");
var _asyncSubject = require("../AsyncSubject");
var _map = require("../operators/map");
var _canReportError = require("../util/canReportError");
var _isArray = require("../util/isArray");
var _isScheduler = require("../util/isScheduler");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if ((0, _isScheduler.isScheduler)(resultSelector)) scheduler = resultSelector;
        else return function() {
            var args1 = [];
            for(var _i = 0; _i < arguments.length; _i++)args1[_i] = arguments[_i];
            return bindCallback(callbackFunc, scheduler).apply(void 0, args1).pipe((0, _map.map)(function(args) {
                return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            }));
        };
    }
    return function() {
        var args = [];
        for(var _i1 = 0; _i1 < arguments.length; _i1++)args[_i1] = arguments[_i1];
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler
        };
        return new (0, _observable.Observable)(function(subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new (0, _asyncSubject.AsyncSubject)();
                    var handler = function() {
                        var innerArgs = [];
                        for(var _i = 0; _i < arguments.length; _i++)innerArgs[_i] = arguments[_i];
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([
                            handler
                        ]));
                    } catch (err) {
                        if ((0, _canReportError.canReportError)(subject)) subject.error(err);
                        else console.warn(err);
                    }
                }
                return subject.subscribe(subscriber);
            } else {
                var state = {
                    args: args,
                    subscriber: subscriber,
                    params: params
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new (0, _asyncSubject.AsyncSubject)();
        var handler = function() {
            var innerArgs = [];
            for(var _i = 0; _i < arguments.length; _i++)innerArgs[_i] = arguments[_i];
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, {
                value: value,
                subject: subject
            }));
        };
        try {
            callbackFunc.apply(context, args.concat([
                handler
            ]));
        } catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}

},{"../Observable":"1asgn","../AsyncSubject":"bxydg","../operators/map":"l6Oaa","../util/canReportError":"b6CwD","../util/isArray":"7twlV","../util/isScheduler":"8B5Pf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6Oaa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "MapOperator", ()=>MapOperator);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== "function") throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ function() {
    function MapOperator1(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator1;
}();
var MapSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(MapSubscriber1, _super);
    function MapSubscriber1(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber1.prototype._next = function(value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"178VF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bindNodeCallback", ()=>bindNodeCallback);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */ var _observable = require("../Observable");
var _asyncSubject = require("../AsyncSubject");
var _map = require("../operators/map");
var _canReportError = require("../util/canReportError");
var _isScheduler = require("../util/isScheduler");
var _isArray = require("../util/isArray");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if ((0, _isScheduler.isScheduler)(resultSelector)) scheduler = resultSelector;
        else return function() {
            var args1 = [];
            for(var _i = 0; _i < arguments.length; _i++)args1[_i] = arguments[_i];
            return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args1).pipe((0, _map.map)(function(args) {
                return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
            }));
        };
    }
    return function() {
        var args = [];
        for(var _i1 = 0; _i1 < arguments.length; _i1++)args[_i1] = arguments[_i1];
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this
        };
        return new (0, _observable.Observable)(function(subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new (0, _asyncSubject.AsyncSubject)();
                    var handler = function() {
                        var innerArgs = [];
                        for(var _i = 0; _i < arguments.length; _i++)innerArgs[_i] = arguments[_i];
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([
                            handler
                        ]));
                    } catch (err) {
                        if ((0, _canReportError.canReportError)(subject)) subject.error(err);
                        else console.warn(err);
                    }
                }
                return subject.subscribe(subscriber);
            } else return scheduler.schedule(dispatch, 0, {
                params: params,
                subscriber: subscriber,
                context: context
            });
        });
    };
}
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new (0, _asyncSubject.AsyncSubject)();
        var handler = function() {
            var innerArgs = [];
            for(var _i = 0; _i < arguments.length; _i++)innerArgs[_i] = arguments[_i];
            var err = innerArgs.shift();
            if (err) _this.add(scheduler.schedule(dispatchError, 0, {
                err: err,
                subject: subject
            }));
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, {
                    value: value,
                    subject: subject
                }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([
                handler
            ]));
        } catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, {
                err: err,
                subject: subject
            }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

},{"../Observable":"1asgn","../AsyncSubject":"bxydg","../operators/map":"l6Oaa","../util/canReportError":"b6CwD","../util/isScheduler":"8B5Pf","../util/isArray":"7twlV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrt6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "combineLatest", ()=>combineLatest);
parcelHelpers.export(exports, "CombineLatestOperator", ()=>CombineLatestOperator);
parcelHelpers.export(exports, "CombineLatestSubscriber", ()=>CombineLatestSubscriber);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */ var _tslib = require("tslib");
var _isScheduler = require("../util/isScheduler");
var _isArray = require("../util/isArray");
var _outerSubscriber = require("../OuterSubscriber");
var _subscribeToResult = require("../util/subscribeToResult");
var _fromArray = require("./fromArray");
var NONE = {};
function combineLatest() {
    var observables = [];
    for(var _i = 0; _i < arguments.length; _i++)observables[_i] = arguments[_i];
    var resultSelector = undefined;
    var scheduler = undefined;
    if ((0, _isScheduler.isScheduler)(observables[observables.length - 1])) scheduler = observables.pop();
    if (typeof observables[observables.length - 1] === "function") resultSelector = observables.pop();
    if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) observables = observables[0];
    return (0, _fromArray.fromArray)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ function() {
    function CombineLatestOperator1(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator1;
}();
var CombineLatestSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(CombineLatestSubscriber1, _super);
    function CombineLatestSubscriber1(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber1.prototype._next = function(observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber1.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) this.destination.complete();
        else {
            this.active = len;
            this.toRespond = len;
            for(var i = 0; i < len; i++){
                var observable = observables[i];
                this.add((0, _subscribeToResult.subscribeToResult)(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber1.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) this.destination.complete();
    };
    CombineLatestSubscriber1.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) this._tryResultSelector(values);
            else this.destination.next(values.slice());
        }
    };
    CombineLatestSubscriber1.prototype._tryResultSelector = function(values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber1;
}((0, _outerSubscriber.OuterSubscriber));

},{"tslib":"99ylF","../util/isScheduler":"8B5Pf","../util/isArray":"7twlV","../OuterSubscriber":"fBdeN","../util/subscribeToResult":"iK8gJ","./fromArray":"fv7fx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fBdeN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OuterSubscriber", ()=>OuterSubscriber);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("./Subscriber");
var OuterSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(OuterSubscriber1, _super);
    function OuterSubscriber1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber1.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber1.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber1.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","./Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iK8gJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeToResult", ()=>subscribeToResult);
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */ var _innerSubscriber = require("../InnerSubscriber");
var _subscribeTo = require("./subscribeTo");
var _observable = require("../Observable");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) innerSubscriber = new (0, _innerSubscriber.InnerSubscriber)(outerSubscriber, outerValue, outerIndex);
    if (innerSubscriber.closed) return undefined;
    if (result instanceof (0, _observable.Observable)) return result.subscribe(innerSubscriber);
    return (0, _subscribeTo.subscribeTo)(result)(innerSubscriber);
}

},{"../InnerSubscriber":"cW4HN","./subscribeTo":"jLuVQ","../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cW4HN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InnerSubscriber", ()=>InnerSubscriber);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("./Subscriber");
var InnerSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(InnerSubscriber1, _super);
    function InnerSubscriber1(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber1.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber1.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber1.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","./Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLuVQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeTo", ()=>subscribeTo);
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */ var _subscribeToArray = require("./subscribeToArray");
var _subscribeToPromise = require("./subscribeToPromise");
var _subscribeToIterable = require("./subscribeToIterable");
var _subscribeToObservable = require("./subscribeToObservable");
var _isArrayLike = require("./isArrayLike");
var _isPromise = require("./isPromise");
var _isObject = require("./isObject");
var _iterator = require("../symbol/iterator");
var _observable = require("../symbol/observable");
var subscribeTo = function(result) {
    if (!!result && typeof result[0, _observable.observable] === "function") return (0, _subscribeToObservable.subscribeToObservable)(result);
    else if ((0, _isArrayLike.isArrayLike)(result)) return (0, _subscribeToArray.subscribeToArray)(result);
    else if ((0, _isPromise.isPromise)(result)) return (0, _subscribeToPromise.subscribeToPromise)(result);
    else if (!!result && typeof result[0, _iterator.iterator] === "function") return (0, _subscribeToIterable.subscribeToIterable)(result);
    else {
        var value = (0, _isObject.isObject)(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + " You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
    }
};

},{"./subscribeToArray":"65pF8","./subscribeToPromise":"9pLhB","./subscribeToIterable":"8SOCK","./subscribeToObservable":"ankdT","./isArrayLike":"ewYhA","./isPromise":"4fe5c","./isObject":"dwhYy","../symbol/iterator":"24vi3","../symbol/observable":"8PNwn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9pLhB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeToPromise", ()=>subscribeToPromise);
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */ var _hostReportError = require("./hostReportError");
var subscribeToPromise = function(promise) {
    return function(subscriber) {
        promise.then(function(value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function(err) {
            return subscriber.error(err);
        }).then(null, (0, _hostReportError.hostReportError));
        return subscriber;
    };
};

},{"./hostReportError":"bmSNp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8SOCK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeToIterable", ()=>subscribeToIterable);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */ var _iterator = require("../symbol/iterator");
var subscribeToIterable = function(iterable) {
    return function(subscriber) {
        var iterator = iterable[0, _iterator.iterator]();
        do {
            var item = void 0;
            try {
                item = iterator.next();
            } catch (err) {
                subscriber.error(err);
                return subscriber;
            }
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) break;
        }while (true);
        if (typeof iterator.return === "function") subscriber.add(function() {
            if (iterator.return) iterator.return();
        });
        return subscriber;
    };
};

},{"../symbol/iterator":"24vi3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"24vi3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "getSymbolIterator", ()=>getSymbolIterator);
parcelHelpers.export(exports, "iterator", ()=>iterator);
parcelHelpers.export(exports, "$$iterator", ()=>$$iterator);
function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) return "@@iterator";
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ankdT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribeToObservable", ()=>subscribeToObservable);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */ var _observable = require("../symbol/observable");
var subscribeToObservable = function(obj) {
    return function(subscriber) {
        var obs = obj[0, _observable.observable]();
        if (typeof obs.subscribe !== "function") throw new TypeError("Provided object does not correctly implement Symbol.observable");
        else return obs.subscribe(subscriber);
    };
};

},{"../symbol/observable":"8PNwn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewYhA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayLike", ()=>isArrayLike);
var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fe5c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "isPromise", ()=>isPromise);
function isPromise(value) {
    return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4CcsK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */ var _of = require("./of");
var _concatAll = require("../operators/concatAll");
function concat() {
    var observables = [];
    for(var _i = 0; _i < arguments.length; _i++)observables[_i] = arguments[_i];
    return (0, _concatAll.concatAll)()((0, _of.of).apply(void 0, observables));
}

},{"./of":"knjPI","../operators/concatAll":"kc5bR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kc5bR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concatAll", ()=>concatAll);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */ var _mergeAll = require("./mergeAll");
function concatAll() {
    return (0, _mergeAll.mergeAll)(1);
}

},{"./mergeAll":"alg6S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alg6S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeAll", ()=>mergeAll);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */ var _mergeMap = require("./mergeMap");
var _identity = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
    return (0, _mergeMap.mergeMap)((0, _identity.identity), concurrent);
}

},{"./mergeMap":"7pq07","../util/identity":"2wO6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7pq07":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeMap", ()=>mergeMap);
parcelHelpers.export(exports, "MergeMapOperator", ()=>MergeMapOperator);
parcelHelpers.export(exports, "MergeMapSubscriber", ()=>MergeMapSubscriber);
parcelHelpers.export(exports, "flatMap", ()=>flatMap);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */ var _tslib = require("tslib");
var _map = require("./map");
var _from = require("../observable/from");
var _innerSubscribe = require("../innerSubscribe");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
    if (typeof resultSelector === "function") return function(source) {
        return source.pipe(mergeMap(function(a, i) {
            return (0, _from.from)(project(a, i)).pipe((0, _map.map)(function(b, ii) {
                return resultSelector(a, b, i, ii);
            }));
        }, concurrent));
    };
    else if (typeof resultSelector === "number") concurrent = resultSelector;
    return function(source) {
        return source.lift(new MergeMapOperator(project, concurrent));
    };
}
var MergeMapOperator = /*@__PURE__*/ function() {
    function MergeMapOperator1(project, concurrent) {
        if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator1.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator1;
}();
var MergeMapSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(MergeMapSubscriber1, _super);
    function MergeMapSubscriber1(destination, project, concurrent) {
        if (concurrent === void 0) concurrent = Number.POSITIVE_INFINITY;
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber1.prototype._next = function(value) {
        if (this.active < this.concurrent) this._tryNext(value);
        else this.buffer.push(value);
    };
    MergeMapSubscriber1.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber1.prototype._innerSub = function(ish) {
        var innerSubscriber = new (0, _innerSubscribe.SimpleInnerSubscriber)(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0, _innerSubscribe.innerSubscribe)(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) destination.add(innerSubscription);
    };
    MergeMapSubscriber1.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) this.destination.complete();
        this.unsubscribe();
    };
    MergeMapSubscriber1.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber1.prototype.notifyComplete = function() {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) this._next(buffer.shift());
        else if (this.active === 0 && this.hasCompleted) this.destination.complete();
    };
    return MergeMapSubscriber1;
}((0, _innerSubscribe.SimpleOuterSubscriber));
var flatMap = mergeMap;

},{"tslib":"99ylF","./map":"l6Oaa","../observable/from":"iYTWI","../innerSubscribe":"j1KrT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYTWI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "from", ()=>from);
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscribeTo = require("../util/subscribeTo");
var _scheduled = require("../scheduled/scheduled");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof (0, _observable.Observable)) return input;
        return new (0, _observable.Observable)((0, _subscribeTo.subscribeTo)(input));
    } else return (0, _scheduled.scheduled)(input, scheduler);
}

},{"../Observable":"1asgn","../util/subscribeTo":"jLuVQ","../scheduled/scheduled":"jHmGq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jHmGq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduled", ()=>scheduled);
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */ var _scheduleObservable = require("./scheduleObservable");
var _schedulePromise = require("./schedulePromise");
var _scheduleArray = require("./scheduleArray");
var _scheduleIterable = require("./scheduleIterable");
var _isInteropObservable = require("../util/isInteropObservable");
var _isPromise = require("../util/isPromise");
var _isArrayLike = require("../util/isArrayLike");
var _isIterable = require("../util/isIterable");
function scheduled(input, scheduler) {
    if (input != null) {
        if ((0, _isInteropObservable.isInteropObservable)(input)) return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
        else if ((0, _isPromise.isPromise)(input)) return (0, _schedulePromise.schedulePromise)(input, scheduler);
        else if ((0, _isArrayLike.isArrayLike)(input)) return (0, _scheduleArray.scheduleArray)(input, scheduler);
        else if ((0, _isIterable.isIterable)(input) || typeof input === "string") return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
    }
    throw new TypeError((input !== null && typeof input || input) + " is not observable");
}

},{"./scheduleObservable":"cnHjQ","./schedulePromise":"jKS5S","./scheduleArray":"bhg1a","./scheduleIterable":"8viBa","../util/isInteropObservable":"b66UI","../util/isPromise":"4fe5c","../util/isArrayLike":"ewYhA","../util/isIterable":"gNMJC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cnHjQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleObservable", ()=>scheduleObservable);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscription = require("../Subscription");
var _observable1 = require("../symbol/observable");
function scheduleObservable(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var sub = new (0, _subscription.Subscription)();
        sub.add(scheduler.schedule(function() {
            var observable = input[0, _observable1.observable]();
            sub.add(observable.subscribe({
                next: function(value) {
                    sub.add(scheduler.schedule(function() {
                        return subscriber.next(value);
                    }));
                },
                error: function(err) {
                    sub.add(scheduler.schedule(function() {
                        return subscriber.error(err);
                    }));
                },
                complete: function() {
                    sub.add(scheduler.schedule(function() {
                        return subscriber.complete();
                    }));
                }
            }));
        }));
        return sub;
    });
}

},{"../Observable":"1asgn","../Subscription":"7CEw9","../symbol/observable":"8PNwn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jKS5S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "schedulePromise", ()=>schedulePromise);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscription = require("../Subscription");
function schedulePromise(input, scheduler) {
    return new (0, _observable.Observable)(function(subscriber) {
        var sub = new (0, _subscription.Subscription)();
        sub.add(scheduler.schedule(function() {
            return input.then(function(value) {
                sub.add(scheduler.schedule(function() {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function() {
                        return subscriber.complete();
                    }));
                }));
            }, function(err) {
                sub.add(scheduler.schedule(function() {
                    return subscriber.error(err);
                }));
            });
        }));
        return sub;
    });
}

},{"../Observable":"1asgn","../Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8viBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "scheduleIterable", ()=>scheduleIterable);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscription = require("../Subscription");
var _iterator = require("../symbol/iterator");
function scheduleIterable(input, scheduler) {
    if (!input) throw new Error("Iterable cannot be null");
    return new (0, _observable.Observable)(function(subscriber) {
        var sub = new (0, _subscription.Subscription)();
        var iterator;
        sub.add(function() {
            if (iterator && typeof iterator.return === "function") iterator.return();
        });
        sub.add(scheduler.schedule(function() {
            iterator = input[0, _iterator.iterator]();
            sub.add(scheduler.schedule(function() {
                if (subscriber.closed) return;
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                } catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) subscriber.complete();
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}

},{"../Observable":"1asgn","../Subscription":"7CEw9","../symbol/iterator":"24vi3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b66UI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isInteropObservable", ()=>isInteropObservable);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */ var _observable = require("../symbol/observable");
function isInteropObservable(input) {
    return input && typeof input[0, _observable.observable] === "function";
}

},{"../symbol/observable":"8PNwn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gNMJC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isIterable", ()=>isIterable);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */ var _iterator = require("../symbol/iterator");
function isIterable(input) {
    return input && typeof input[0, _iterator.iterator] === "function";
}

},{"../symbol/iterator":"24vi3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j1KrT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SimpleInnerSubscriber", ()=>SimpleInnerSubscriber);
parcelHelpers.export(exports, "ComplexInnerSubscriber", ()=>ComplexInnerSubscriber);
parcelHelpers.export(exports, "SimpleOuterSubscriber", ()=>SimpleOuterSubscriber);
parcelHelpers.export(exports, "ComplexOuterSubscriber", ()=>ComplexOuterSubscriber);
parcelHelpers.export(exports, "innerSubscribe", ()=>innerSubscribe);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("./Subscriber");
var _observable = require("./Observable");
var _subscribeTo = require("./util/subscribeTo");
var SimpleInnerSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(SimpleInnerSubscriber1, _super);
    function SimpleInnerSubscriber1(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber1.prototype._next = function(value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber1.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber1.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber1;
}((0, _subscriber.Subscriber));
var ComplexInnerSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ComplexInnerSubscriber1, _super);
    function ComplexInnerSubscriber1(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber1.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber1.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber1.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber1;
}((0, _subscriber.Subscriber));
var SimpleOuterSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(SimpleOuterSubscriber1, _super);
    function SimpleOuterSubscriber1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber1.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber1.prototype.notifyError = function(err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber1.prototype.notifyComplete = function() {
        this.destination.complete();
    };
    return SimpleOuterSubscriber1;
}((0, _subscriber.Subscriber));
var ComplexOuterSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ComplexOuterSubscriber1, _super);
    function ComplexOuterSubscriber1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber1.prototype.notifyNext = function(_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber1.prototype.notifyError = function(error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber1.prototype.notifyComplete = function(_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber1;
}((0, _subscriber.Subscriber));
function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) return undefined;
    if (result instanceof (0, _observable.Observable)) return result.subscribe(innerSubscriber);
    var subscription;
    try {
        subscription = (0, _subscribeTo.subscribeTo)(result)(innerSubscriber);
    } catch (error) {
        innerSubscriber.error(error);
    }
    return subscription;
}

},{"tslib":"99ylF","./Subscriber":"bwPOT","./Observable":"1asgn","./util/subscribeTo":"jLuVQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iYBVz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defer", ()=>defer);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */ var _observable = require("../Observable");
var _from = require("./from");
var _empty = require("./empty");
function defer(observableFactory) {
    return new (0, _observable.Observable)(function(subscriber) {
        var input;
        try {
            input = observableFactory();
        } catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? (0, _from.from)(input) : (0, _empty.empty)();
        return source.subscribe(subscriber);
    });
}

},{"../Observable":"1asgn","./from":"iYTWI","./empty":"d0sAg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bT0Lu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forkJoin", ()=>forkJoin);
/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */ var _observable = require("../Observable");
var _isArray = require("../util/isArray");
var _map = require("../operators/map");
var _isObject = require("../util/isObject");
var _from = require("./from");
function forkJoin() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    if (sources.length === 1) {
        var first_1 = sources[0];
        if ((0, _isArray.isArray)(first_1)) return forkJoinInternal(first_1, null);
        if ((0, _isObject.isObject)(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function(key) {
                return first_1[key];
            }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === "function") {
        var resultSelector_1 = sources.pop();
        sources = sources.length === 1 && (0, _isArray.isArray)(sources[0]) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe((0, _map.map)(function(args) {
            return resultSelector_1.apply(void 0, args);
        }));
    }
    return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
    return new (0, _observable.Observable)(function(subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function(i2) {
            var source = (0, _from.from)(sources[i2]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function(value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i2] = value;
                },
                error: function(err) {
                    return subscriber.error(err);
                },
                complete: function() {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) subscriber.next(keys ? keys.reduce(function(result, key, i) {
                            return result[key] = values[i], result;
                        }, {}) : values);
                        subscriber.complete();
                    }
                }
            }));
        };
        for(var i1 = 0; i1 < len; i1++)_loop_1(i1);
    });
}

},{"../Observable":"1asgn","../util/isArray":"7twlV","../operators/map":"l6Oaa","../util/isObject":"dwhYy","./from":"iYTWI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5kZoa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromEvent", ()=>fromEvent);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */ var _observable = require("../Observable");
var _isArray = require("../util/isArray");
var _isFunction = require("../util/isFunction");
var _map = require("../operators/map");
var toString = /*@__PURE__*/ function() {
    return Object.prototype.toString;
}();
function fromEvent(target, eventName, options, resultSelector) {
    if ((0, _isFunction.isFunction)(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) return fromEvent(target, eventName, options).pipe((0, _map.map)(function(args) {
        return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
    return new (0, _observable.Observable)(function(subscriber) {
        function handler(e) {
            if (arguments.length > 1) subscriber.next(Array.prototype.slice.call(arguments));
            else subscriber.next(e);
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function() {
            return source_1.removeEventListener(eventName, handler, options);
        };
    } else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function() {
            return source_2.off(eventName, handler);
        };
    } else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function() {
            return source_3.removeListener(eventName, handler);
        };
    } else if (sourceObj && sourceObj.length) for(var i = 0, len = sourceObj.length; i < len; i++)setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    else throw new TypeError("Invalid event target");
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}

},{"../Observable":"1asgn","../util/isArray":"7twlV","../util/isFunction":"jxvPW","../operators/map":"l6Oaa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5bLz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromEventPattern", ()=>fromEventPattern);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */ var _observable = require("../Observable");
var _isArray = require("../util/isArray");
var _isFunction = require("../util/isFunction");
var _map = require("../operators/map");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) return fromEventPattern(addHandler, removeHandler).pipe((0, _map.map)(function(args) {
        return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
    return new (0, _observable.Observable)(function(subscriber) {
        var handler = function() {
            var e = [];
            for(var _i = 0; _i < arguments.length; _i++)e[_i] = arguments[_i];
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        } catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!(0, _isFunction.isFunction)(removeHandler)) return undefined;
        return function() {
            return removeHandler(handler, retValue);
        };
    });
}

},{"../Observable":"1asgn","../util/isArray":"7twlV","../util/isFunction":"jxvPW","../operators/map":"l6Oaa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZiPw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generate", ()=>generate);
/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */ var _observable = require("../Observable");
var _identity = require("../util/identity");
var _isScheduler = require("../util/isScheduler");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || (0, _identity.identity);
        scheduler = options.scheduler;
    } else if (resultSelectorOrObservable === undefined || (0, _isScheduler.isScheduler)(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = (0, _identity.identity);
        scheduler = resultSelectorOrObservable;
    } else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new (0, _observable.Observable)(function(subscriber) {
        var state = initialState;
        if (scheduler) return scheduler.schedule(dispatch, 0, {
            subscriber: subscriber,
            iterate: iterate,
            condition: condition,
            resultSelector: resultSelector,
            state: state
        });
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                } catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            } catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) break;
            try {
                state = iterate(state);
            } catch (err1) {
                subscriber.error(err1);
                return undefined;
            }
        }while (true);
        return undefined;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) return undefined;
    if (state.needIterate) try {
        state.state = state.iterate(state.state);
    } catch (err) {
        subscriber.error(err);
        return undefined;
    }
    else state.needIterate = true;
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        } catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) return undefined;
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    } catch (err2) {
        subscriber.error(err2);
        return undefined;
    }
    if (subscriber.closed) return undefined;
    subscriber.next(value);
    if (subscriber.closed) return undefined;
    return this.schedule(state);
}

},{"../Observable":"1asgn","../util/identity":"2wO6M","../util/isScheduler":"8B5Pf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ciOCA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "iif", ()=>iif);
/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */ var _defer = require("./defer");
var _empty = require("./empty");
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) trueResult = (0, _empty.EMPTY);
    if (falseResult === void 0) falseResult = (0, _empty.EMPTY);
    return (0, _defer.defer)(function() {
        return condition() ? trueResult : falseResult;
    });
}

},{"./defer":"iYBVz","./empty":"d0sAg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8kp6s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "interval", ()=>interval);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */ var _observable = require("../Observable");
var _async = require("../scheduler/async");
var _isNumeric = require("../util/isNumeric");
function interval(period, scheduler) {
    if (period === void 0) period = 0;
    if (scheduler === void 0) scheduler = (0, _async.async);
    if (!(0, _isNumeric.isNumeric)(period) || period < 0) period = 0;
    if (!scheduler || typeof scheduler.schedule !== "function") scheduler = (0, _async.async);
    return new (0, _observable.Observable)(function(subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, {
            subscriber: subscriber,
            counter: 0,
            period: period
        }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({
        subscriber: subscriber,
        counter: counter + 1,
        period: period
    }, period);
}

},{"../Observable":"1asgn","../scheduler/async":"04lHJ","../util/isNumeric":"eSGdv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eSGdv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNumeric", ()=>isNumeric);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */ var _isArray = require("./isArray");
function isNumeric(val) {
    return !(0, _isArray.isArray)(val) && val - parseFloat(val) + 1 >= 0;
}

},{"./isArray":"7twlV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3kGhP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "merge", ()=>merge);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */ var _observable = require("../Observable");
var _isScheduler = require("../util/isScheduler");
var _mergeAll = require("../operators/mergeAll");
var _fromArray = require("./fromArray");
function merge() {
    var observables = [];
    for(var _i = 0; _i < arguments.length; _i++)observables[_i] = arguments[_i];
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if ((0, _isScheduler.isScheduler)(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === "number") concurrent = observables.pop();
    } else if (typeof last === "number") concurrent = observables.pop();
    if (scheduler === null && observables.length === 1 && observables[0] instanceof (0, _observable.Observable)) return observables[0];
    return (0, _mergeAll.mergeAll)(concurrent)((0, _fromArray.fromArray)(observables, scheduler));
}

},{"../Observable":"1asgn","../util/isScheduler":"8B5Pf","../operators/mergeAll":"alg6S","./fromArray":"fv7fx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fpMWE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NEVER", ()=>NEVER);
parcelHelpers.export(exports, "never", ()=>never);
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */ var _observable = require("../Observable");
var _noop = require("../util/noop");
var NEVER = /*@__PURE__*/ new (0, _observable.Observable)((0, _noop.noop));
function never() {
    return NEVER;
}

},{"../Observable":"1asgn","../util/noop":"cB2ox","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3XoV6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "onErrorResumeNext", ()=>onErrorResumeNext);
/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */ var _observable = require("../Observable");
var _from = require("./from");
var _isArray = require("../util/isArray");
var _empty = require("./empty");
function onErrorResumeNext() {
    var sources = [];
    for(var _i = 0; _i < arguments.length; _i++)sources[_i] = arguments[_i];
    if (sources.length === 0) return 0, _empty.EMPTY;
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && (0, _isArray.isArray)(first)) return onErrorResumeNext.apply(void 0, first);
    return new (0, _observable.Observable)(function(subscriber) {
        var subNext = function() {
            return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
        };
        return (0, _from.from)(first).subscribe({
            next: function(value) {
                subscriber.next(value);
            },
            error: subNext,
            complete: subNext
        });
    });
}

},{"../Observable":"1asgn","./from":"iYTWI","../util/isArray":"7twlV","./empty":"d0sAg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GL3V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pairs", ()=>pairs);
parcelHelpers.export(exports, "dispatch", ()=>dispatch);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */ var _observable = require("../Observable");
var _subscription = require("../Subscription");
function pairs(obj, scheduler) {
    if (!scheduler) return new (0, _observable.Observable)(function(subscriber) {
        var keys = Object.keys(obj);
        for(var i = 0; i < keys.length && !subscriber.closed; i++){
            var key = keys[i];
            if (obj.hasOwnProperty(key)) subscriber.next([
                key,
                obj[key]
            ]);
        }
        subscriber.complete();
    });
    else return new (0, _observable.Observable)(function(subscriber) {
        var keys = Object.keys(obj);
        var subscription = new (0, _subscription.Subscription)();
        subscription.add(scheduler.schedule(dispatch, 0, {
            keys: keys,
            index: 0,
            subscriber: subscriber,
            subscription: subscription,
            obj: obj
        }));
        return subscription;
    });
}
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([
                key,
                obj[key]
            ]);
            subscription.add(this.schedule({
                keys: keys,
                index: index + 1,
                subscriber: subscriber,
                subscription: subscription,
                obj: obj
            }));
        } else subscriber.complete();
    }
}

},{"../Observable":"1asgn","../Subscription":"7CEw9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ya8q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "partition", ()=>partition);
/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */ var _not = require("../util/not");
var _subscribeTo = require("../util/subscribeTo");
var _filter = require("../operators/filter");
var _observable = require("../Observable");
function partition(source, predicate, thisArg) {
    return [
        (0, _filter.filter)(predicate, thisArg)(new (0, _observable.Observable)((0, _subscribeTo.subscribeTo)(source))),
        (0, _filter.filter)((0, _not.not)(predicate, thisArg))(new (0, _observable.Observable)((0, _subscribeTo.subscribeTo)(source)))
    ];
}

},{"../util/not":"abgIp","../util/subscribeTo":"jLuVQ","../operators/filter":"eU9Jz","../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"abgIp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "not", ()=>not);
function not(pred, thisArg) {
    function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eU9Jz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filter", ()=>filter);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ function() {
    function FilterOperator1(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator1;
}();
var FilterSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(FilterSubscriber1, _super);
    function FilterSubscriber1(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber1.prototype._next = function(value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) this.destination.next(value);
    };
    return FilterSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7v9a2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "race", ()=>race);
parcelHelpers.export(exports, "RaceOperator", ()=>RaceOperator);
parcelHelpers.export(exports, "RaceSubscriber", ()=>RaceSubscriber);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */ var _tslib = require("tslib");
var _isArray = require("../util/isArray");
var _fromArray = require("./fromArray");
var _outerSubscriber = require("../OuterSubscriber");
var _subscribeToResult = require("../util/subscribeToResult");
function race() {
    var observables = [];
    for(var _i = 0; _i < arguments.length; _i++)observables[_i] = arguments[_i];
    if (observables.length === 1) {
        if ((0, _isArray.isArray)(observables[0])) observables = observables[0];
        else return observables[0];
    }
    return (0, _fromArray.fromArray)(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ function() {
    function RaceOperator1() {}
    RaceOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator1;
}();
var RaceSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(RaceSubscriber1, _super);
    function RaceSubscriber1(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber1.prototype._next = function(observable) {
        this.observables.push(observable);
    };
    RaceSubscriber1.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) this.destination.complete();
        else {
            for(var i = 0; i < len && !this.hasFirst; i++){
                var observable = observables[i];
                var subscription = (0, _subscribeToResult.subscribeToResult)(this, observable, undefined, i);
                if (this.subscriptions) this.subscriptions.push(subscription);
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber1.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for(var i = 0; i < this.subscriptions.length; i++)if (i !== outerIndex) {
                var subscription = this.subscriptions[i];
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber1;
}((0, _outerSubscriber.OuterSubscriber));

},{"tslib":"99ylF","../util/isArray":"7twlV","./fromArray":"fv7fx","../OuterSubscriber":"fBdeN","../util/subscribeToResult":"iK8gJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"50mSF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "range", ()=>range);
parcelHelpers.export(exports, "dispatch", ()=>dispatch);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */ var _observable = require("../Observable");
function range(start, count, scheduler) {
    if (start === void 0) start = 0;
    return new (0, _observable.Observable)(function(subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) return scheduler.schedule(dispatch, 0, {
            index: index,
            count: count,
            start: start,
            subscriber: subscriber
        });
        else do {
            if ((index++) >= count) {
                subscriber.complete();
                break;
            }
            subscriber.next(current++);
            if (subscriber.closed) break;
        }while (true);
        return undefined;
    });
}
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) return;
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}

},{"../Observable":"1asgn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"yD2Dx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timer", ()=>timer);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */ var _observable = require("../Observable");
var _async = require("../scheduler/async");
var _isNumeric = require("../util/isNumeric");
var _isScheduler = require("../util/isScheduler");
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) dueTime = 0;
    var period = -1;
    if ((0, _isNumeric.isNumeric)(periodOrScheduler)) period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    else if ((0, _isScheduler.isScheduler)(periodOrScheduler)) scheduler = periodOrScheduler;
    if (!(0, _isScheduler.isScheduler)(scheduler)) scheduler = (0, _async.async);
    return new (0, _observable.Observable)(function(subscriber) {
        var due = (0, _isNumeric.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
            index: 0,
            period: period,
            subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) return;
    else if (period === -1) return subscriber.complete();
    state.index = index + 1;
    this.schedule(state, period);
}

},{"../Observable":"1asgn","../scheduler/async":"04lHJ","../util/isNumeric":"eSGdv","../util/isScheduler":"8B5Pf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bCt7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "using", ()=>using);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */ var _observable = require("../Observable");
var _from = require("./from");
var _empty = require("./empty");
function using(resourceFactory, observableFactory) {
    return new (0, _observable.Observable)(function(subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        } catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        } catch (err1) {
            subscriber.error(err1);
            return undefined;
        }
        var source = result ? (0, _from.from)(result) : (0, _empty.EMPTY);
        var subscription = source.subscribe(subscriber);
        return function() {
            subscription.unsubscribe();
            if (resource) resource.unsubscribe();
        };
    });
}

},{"../Observable":"1asgn","./from":"iYTWI","./empty":"d0sAg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cw7ce":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zip", ()=>zip);
parcelHelpers.export(exports, "ZipOperator", ()=>ZipOperator);
parcelHelpers.export(exports, "ZipSubscriber", ()=>ZipSubscriber);
/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_.._internal_symbol_iterator,_innerSubscribe PURE_IMPORTS_END */ var _tslib = require("tslib");
var _fromArray = require("./fromArray");
var _isArray = require("../util/isArray");
var _subscriber = require("../Subscriber");
var _iterator = require("../../internal/symbol/iterator");
var _innerSubscribe = require("../innerSubscribe");
function zip() {
    var observables = [];
    for(var _i = 0; _i < arguments.length; _i++)observables[_i] = arguments[_i];
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === "function") observables.pop();
    return (0, _fromArray.fromArray)(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ function() {
    function ZipOperator1(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator1;
}();
var ZipSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ZipSubscriber1, _super);
    function ZipSubscriber1(destination, resultSelector, values) {
        if (values === void 0) values = Object.create(null);
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : undefined;
        return _this;
    }
    ZipSubscriber1.prototype._next = function(value) {
        var iterators = this.iterators;
        if ((0, _isArray.isArray)(value)) iterators.push(new StaticArrayIterator(value));
        else if (typeof value[0, _iterator.iterator] === "function") iterators.push(new StaticIterator(value[0, _iterator.iterator]()));
        else iterators.push(new ZipBufferIterator(this.destination, this, value));
    };
    ZipSubscriber1.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for(var i = 0; i < len; i++){
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe());
            } else this.active--;
        }
    };
    ZipSubscriber1.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) this.destination.complete();
    };
    ZipSubscriber1.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for(var i = 0; i < len; i++){
            var iterator = iterators[i];
            if (typeof iterator.hasValue === "function" && !iterator.hasValue()) return;
        }
        var shouldComplete = false;
        var args = [];
        for(var i = 0; i < len; i++){
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) shouldComplete = true;
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) this._tryresultSelector(args);
        else destination.next(args);
        if (shouldComplete) destination.complete();
    };
    ZipSubscriber1.prototype._tryresultSelector = function(args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber1;
}((0, _subscriber.Subscriber));
var StaticIterator = /*@__PURE__*/ function() {
    function StaticIterator1(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator1.prototype.hasValue = function() {
        return true;
    };
    StaticIterator1.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator1.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator1;
}();
var StaticArrayIterator = /*@__PURE__*/ function() {
    function StaticArrayIterator1(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator1.prototype[0, _iterator.iterator] = function() {
        return this;
    };
    StaticArrayIterator1.prototype.next = function(value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? {
            value: array[i],
            done: false
        } : {
            value: null,
            done: true
        };
    };
    StaticArrayIterator1.prototype.hasValue = function() {
        return this.array.length > this.index;
    };
    StaticArrayIterator1.prototype.hasCompleted = function() {
        return this.array.length === this.index;
    };
    return StaticArrayIterator1;
}();
var ZipBufferIterator = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ZipBufferIterator1, _super);
    function ZipBufferIterator1(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator1.prototype[0, _iterator.iterator] = function() {
        return this;
    };
    ZipBufferIterator1.prototype.next = function() {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) return {
            value: null,
            done: true
        };
        else return {
            value: buffer.shift(),
            done: false
        };
    };
    ZipBufferIterator1.prototype.hasValue = function() {
        return this.buffer.length > 0;
    };
    ZipBufferIterator1.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator1.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else this.destination.complete();
    };
    ZipBufferIterator1.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator1.prototype.subscribe = function() {
        return (0, _innerSubscribe.innerSubscribe)(this.observable, new (0, _innerSubscribe.SimpleInnerSubscriber)(this));
    };
    return ZipBufferIterator1;
}((0, _innerSubscribe.SimpleOuterSubscriber));

},{"tslib":"99ylF","./fromArray":"fv7fx","../util/isArray":"7twlV","../Subscriber":"bwPOT","../../internal/symbol/iterator":"24vi3","../innerSubscribe":"j1KrT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4idmO":[function(require,module,exports) {
"use strict";
var Buffer = require("buffer").Buffer;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.receiveAPDU = void 0;
var _errors = require("@ledgerhq/errors");
var _rxjs = require("rxjs");
var _logs = require("@ledgerhq/logs");
const TagId = 0x05; // operator that transform the input raw stream into one apdu response and finishes
const receiveAPDU = (rawStream)=>_rxjs.Observable.create((o)=>{
        let notifiedIndex = 0;
        let notifiedDataLength = 0;
        let notifiedData = Buffer.alloc(0);
        const sub = rawStream.subscribe({
            complete: ()=>{
                o.error(new _errors.DisconnectedDevice());
                sub.unsubscribe();
            },
            error: (e)=>{
                (0, _logs.log)("ble-error", "in receiveAPDU " + String(e));
                o.error(e);
                sub.unsubscribe();
            },
            next: (value)=>{
                const tag = value.readUInt8(0);
                const index = value.readUInt16BE(1);
                let data = value.slice(3);
                if (tag !== TagId) {
                    o.error(new _errors.TransportError("Invalid tag " + tag.toString(16), "InvalidTag"));
                    return;
                }
                if (notifiedIndex !== index) {
                    o.error(new _errors.TransportError("BLE: Invalid sequence number. discontinued chunk. Received " + index + " but expected " + notifiedIndex, "InvalidSequence"));
                    return;
                }
                if (index === 0) {
                    notifiedDataLength = data.readUInt16BE(0);
                    data = data.slice(2);
                }
                notifiedIndex++;
                notifiedData = Buffer.concat([
                    notifiedData,
                    data
                ]);
                if (notifiedData.length > notifiedDataLength) {
                    o.error(new _errors.TransportError("BLE: received too much data. discontinued chunk. Received " + notifiedData.length + " but expected " + notifiedDataLength, "BLETooMuchData"));
                    return;
                }
                if (notifiedData.length === notifiedDataLength) {
                    o.next(notifiedData);
                    o.complete();
                    sub.unsubscribe();
                }
            }
        });
        return ()=>{
            sub.unsubscribe();
        };
    });
exports.receiveAPDU = receiveAPDU;

},{"buffer":"fCgem","@ledgerhq/errors":"e0rTV","rxjs":"eNCF7","@ledgerhq/logs":"i4OI0"}],"hZ5Xz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */ parcelHelpers.export(exports, "audit", ()=>(0, _audit.audit));
parcelHelpers.export(exports, "auditTime", ()=>(0, _auditTime.auditTime));
parcelHelpers.export(exports, "buffer", ()=>(0, _buffer.buffer));
parcelHelpers.export(exports, "bufferCount", ()=>(0, _bufferCount.bufferCount));
parcelHelpers.export(exports, "bufferTime", ()=>(0, _bufferTime.bufferTime));
parcelHelpers.export(exports, "bufferToggle", ()=>(0, _bufferToggle.bufferToggle));
parcelHelpers.export(exports, "bufferWhen", ()=>(0, _bufferWhen.bufferWhen));
parcelHelpers.export(exports, "catchError", ()=>(0, _catchError.catchError));
parcelHelpers.export(exports, "combineAll", ()=>(0, _combineAll.combineAll));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "concatAll", ()=>(0, _concatAll.concatAll));
parcelHelpers.export(exports, "concatMap", ()=>(0, _concatMap.concatMap));
parcelHelpers.export(exports, "concatMapTo", ()=>(0, _concatMapTo.concatMapTo));
parcelHelpers.export(exports, "count", ()=>(0, _count.count));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounce.debounce));
parcelHelpers.export(exports, "debounceTime", ()=>(0, _debounceTime.debounceTime));
parcelHelpers.export(exports, "defaultIfEmpty", ()=>(0, _defaultIfEmpty.defaultIfEmpty));
parcelHelpers.export(exports, "delay", ()=>(0, _delay.delay));
parcelHelpers.export(exports, "delayWhen", ()=>(0, _delayWhen.delayWhen));
parcelHelpers.export(exports, "dematerialize", ()=>(0, _dematerialize.dematerialize));
parcelHelpers.export(exports, "distinct", ()=>(0, _distinct.distinct));
parcelHelpers.export(exports, "distinctUntilChanged", ()=>(0, _distinctUntilChanged.distinctUntilChanged));
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>(0, _distinctUntilKeyChanged.distinctUntilKeyChanged));
parcelHelpers.export(exports, "elementAt", ()=>(0, _elementAt.elementAt));
parcelHelpers.export(exports, "endWith", ()=>(0, _endWith.endWith));
parcelHelpers.export(exports, "every", ()=>(0, _every.every));
parcelHelpers.export(exports, "exhaust", ()=>(0, _exhaust.exhaust));
parcelHelpers.export(exports, "exhaustMap", ()=>(0, _exhaustMap.exhaustMap));
parcelHelpers.export(exports, "expand", ()=>(0, _expand.expand));
parcelHelpers.export(exports, "filter", ()=>(0, _filter.filter));
parcelHelpers.export(exports, "finalize", ()=>(0, _finalize.finalize));
parcelHelpers.export(exports, "find", ()=>(0, _find.find));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndex.findIndex));
parcelHelpers.export(exports, "first", ()=>(0, _first.first));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupBy.groupBy));
parcelHelpers.export(exports, "ignoreElements", ()=>(0, _ignoreElements.ignoreElements));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmpty.isEmpty));
parcelHelpers.export(exports, "last", ()=>(0, _last.last));
parcelHelpers.export(exports, "map", ()=>(0, _map.map));
parcelHelpers.export(exports, "mapTo", ()=>(0, _mapTo.mapTo));
parcelHelpers.export(exports, "materialize", ()=>(0, _materialize.materialize));
parcelHelpers.export(exports, "max", ()=>(0, _max.max));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "mergeAll", ()=>(0, _mergeAll.mergeAll));
parcelHelpers.export(exports, "mergeMap", ()=>(0, _mergeMap.mergeMap));
parcelHelpers.export(exports, "flatMap", ()=>(0, _mergeMap.flatMap));
parcelHelpers.export(exports, "mergeMapTo", ()=>(0, _mergeMapTo.mergeMapTo));
parcelHelpers.export(exports, "mergeScan", ()=>(0, _mergeScan.mergeScan));
parcelHelpers.export(exports, "min", ()=>(0, _min.min));
parcelHelpers.export(exports, "multicast", ()=>(0, _multicast.multicast));
parcelHelpers.export(exports, "observeOn", ()=>(0, _observeOn.observeOn));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNext.onErrorResumeNext));
parcelHelpers.export(exports, "pairwise", ()=>(0, _pairwise.pairwise));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluck.pluck));
parcelHelpers.export(exports, "publish", ()=>(0, _publish.publish));
parcelHelpers.export(exports, "publishBehavior", ()=>(0, _publishBehavior.publishBehavior));
parcelHelpers.export(exports, "publishLast", ()=>(0, _publishLast.publishLast));
parcelHelpers.export(exports, "publishReplay", ()=>(0, _publishReplay.publishReplay));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduce.reduce));
parcelHelpers.export(exports, "repeat", ()=>(0, _repeat.repeat));
parcelHelpers.export(exports, "repeatWhen", ()=>(0, _repeatWhen.repeatWhen));
parcelHelpers.export(exports, "retry", ()=>(0, _retry.retry));
parcelHelpers.export(exports, "retryWhen", ()=>(0, _retryWhen.retryWhen));
parcelHelpers.export(exports, "refCount", ()=>(0, _refCount.refCount));
parcelHelpers.export(exports, "sample", ()=>(0, _sample.sample));
parcelHelpers.export(exports, "sampleTime", ()=>(0, _sampleTime.sampleTime));
parcelHelpers.export(exports, "scan", ()=>(0, _scan.scan));
parcelHelpers.export(exports, "sequenceEqual", ()=>(0, _sequenceEqual.sequenceEqual));
parcelHelpers.export(exports, "share", ()=>(0, _share.share));
parcelHelpers.export(exports, "shareReplay", ()=>(0, _shareReplay.shareReplay));
parcelHelpers.export(exports, "single", ()=>(0, _single.single));
parcelHelpers.export(exports, "skip", ()=>(0, _skip.skip));
parcelHelpers.export(exports, "skipLast", ()=>(0, _skipLast.skipLast));
parcelHelpers.export(exports, "skipUntil", ()=>(0, _skipUntil.skipUntil));
parcelHelpers.export(exports, "skipWhile", ()=>(0, _skipWhile.skipWhile));
parcelHelpers.export(exports, "startWith", ()=>(0, _startWith.startWith));
parcelHelpers.export(exports, "subscribeOn", ()=>(0, _subscribeOn.subscribeOn));
parcelHelpers.export(exports, "switchAll", ()=>(0, _switchAll.switchAll));
parcelHelpers.export(exports, "switchMap", ()=>(0, _switchMap.switchMap));
parcelHelpers.export(exports, "switchMapTo", ()=>(0, _switchMapTo.switchMapTo));
parcelHelpers.export(exports, "take", ()=>(0, _take.take));
parcelHelpers.export(exports, "takeLast", ()=>(0, _takeLast.takeLast));
parcelHelpers.export(exports, "takeUntil", ()=>(0, _takeUntil.takeUntil));
parcelHelpers.export(exports, "takeWhile", ()=>(0, _takeWhile.takeWhile));
parcelHelpers.export(exports, "tap", ()=>(0, _tap.tap));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttle.throttle));
parcelHelpers.export(exports, "throttleTime", ()=>(0, _throttleTime.throttleTime));
parcelHelpers.export(exports, "throwIfEmpty", ()=>(0, _throwIfEmpty.throwIfEmpty));
parcelHelpers.export(exports, "timeInterval", ()=>(0, _timeInterval.timeInterval));
parcelHelpers.export(exports, "timeout", ()=>(0, _timeout.timeout));
parcelHelpers.export(exports, "timeoutWith", ()=>(0, _timeoutWith.timeoutWith));
parcelHelpers.export(exports, "timestamp", ()=>(0, _timestamp.timestamp));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArray.toArray));
parcelHelpers.export(exports, "window", ()=>(0, _window.window));
parcelHelpers.export(exports, "windowCount", ()=>(0, _windowCount.windowCount));
parcelHelpers.export(exports, "windowTime", ()=>(0, _windowTime.windowTime));
parcelHelpers.export(exports, "windowToggle", ()=>(0, _windowToggle.windowToggle));
parcelHelpers.export(exports, "windowWhen", ()=>(0, _windowWhen.windowWhen));
parcelHelpers.export(exports, "withLatestFrom", ()=>(0, _withLatestFrom.withLatestFrom));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "zipAll", ()=>(0, _zipAll.zipAll));
var _audit = require("../internal/operators/audit");
var _auditTime = require("../internal/operators/auditTime");
var _buffer = require("../internal/operators/buffer");
var _bufferCount = require("../internal/operators/bufferCount");
var _bufferTime = require("../internal/operators/bufferTime");
var _bufferToggle = require("../internal/operators/bufferToggle");
var _bufferWhen = require("../internal/operators/bufferWhen");
var _catchError = require("../internal/operators/catchError");
var _combineAll = require("../internal/operators/combineAll");
var _combineLatest = require("../internal/operators/combineLatest");
var _concat = require("../internal/operators/concat");
var _concatAll = require("../internal/operators/concatAll");
var _concatMap = require("../internal/operators/concatMap");
var _concatMapTo = require("../internal/operators/concatMapTo");
var _count = require("../internal/operators/count");
var _debounce = require("../internal/operators/debounce");
var _debounceTime = require("../internal/operators/debounceTime");
var _defaultIfEmpty = require("../internal/operators/defaultIfEmpty");
var _delay = require("../internal/operators/delay");
var _delayWhen = require("../internal/operators/delayWhen");
var _dematerialize = require("../internal/operators/dematerialize");
var _distinct = require("../internal/operators/distinct");
var _distinctUntilChanged = require("../internal/operators/distinctUntilChanged");
var _distinctUntilKeyChanged = require("../internal/operators/distinctUntilKeyChanged");
var _elementAt = require("../internal/operators/elementAt");
var _endWith = require("../internal/operators/endWith");
var _every = require("../internal/operators/every");
var _exhaust = require("../internal/operators/exhaust");
var _exhaustMap = require("../internal/operators/exhaustMap");
var _expand = require("../internal/operators/expand");
var _filter = require("../internal/operators/filter");
var _finalize = require("../internal/operators/finalize");
var _find = require("../internal/operators/find");
var _findIndex = require("../internal/operators/findIndex");
var _first = require("../internal/operators/first");
var _groupBy = require("../internal/operators/groupBy");
var _ignoreElements = require("../internal/operators/ignoreElements");
var _isEmpty = require("../internal/operators/isEmpty");
var _last = require("../internal/operators/last");
var _map = require("../internal/operators/map");
var _mapTo = require("../internal/operators/mapTo");
var _materialize = require("../internal/operators/materialize");
var _max = require("../internal/operators/max");
var _merge = require("../internal/operators/merge");
var _mergeAll = require("../internal/operators/mergeAll");
var _mergeMap = require("../internal/operators/mergeMap");
var _mergeMapTo = require("../internal/operators/mergeMapTo");
var _mergeScan = require("../internal/operators/mergeScan");
var _min = require("../internal/operators/min");
var _multicast = require("../internal/operators/multicast");
var _observeOn = require("../internal/operators/observeOn");
var _onErrorResumeNext = require("../internal/operators/onErrorResumeNext");
var _pairwise = require("../internal/operators/pairwise");
var _partition = require("../internal/operators/partition");
var _pluck = require("../internal/operators/pluck");
var _publish = require("../internal/operators/publish");
var _publishBehavior = require("../internal/operators/publishBehavior");
var _publishLast = require("../internal/operators/publishLast");
var _publishReplay = require("../internal/operators/publishReplay");
var _race = require("../internal/operators/race");
var _reduce = require("../internal/operators/reduce");
var _repeat = require("../internal/operators/repeat");
var _repeatWhen = require("../internal/operators/repeatWhen");
var _retry = require("../internal/operators/retry");
var _retryWhen = require("../internal/operators/retryWhen");
var _refCount = require("../internal/operators/refCount");
var _sample = require("../internal/operators/sample");
var _sampleTime = require("../internal/operators/sampleTime");
var _scan = require("../internal/operators/scan");
var _sequenceEqual = require("../internal/operators/sequenceEqual");
var _share = require("../internal/operators/share");
var _shareReplay = require("../internal/operators/shareReplay");
var _single = require("../internal/operators/single");
var _skip = require("../internal/operators/skip");
var _skipLast = require("../internal/operators/skipLast");
var _skipUntil = require("../internal/operators/skipUntil");
var _skipWhile = require("../internal/operators/skipWhile");
var _startWith = require("../internal/operators/startWith");
var _subscribeOn = require("../internal/operators/subscribeOn");
var _switchAll = require("../internal/operators/switchAll");
var _switchMap = require("../internal/operators/switchMap");
var _switchMapTo = require("../internal/operators/switchMapTo");
var _take = require("../internal/operators/take");
var _takeLast = require("../internal/operators/takeLast");
var _takeUntil = require("../internal/operators/takeUntil");
var _takeWhile = require("../internal/operators/takeWhile");
var _tap = require("../internal/operators/tap");
var _throttle = require("../internal/operators/throttle");
var _throttleTime = require("../internal/operators/throttleTime");
var _throwIfEmpty = require("../internal/operators/throwIfEmpty");
var _timeInterval = require("../internal/operators/timeInterval");
var _timeout = require("../internal/operators/timeout");
var _timeoutWith = require("../internal/operators/timeoutWith");
var _timestamp = require("../internal/operators/timestamp");
var _toArray = require("../internal/operators/toArray");
var _window = require("../internal/operators/window");
var _windowCount = require("../internal/operators/windowCount");
var _windowTime = require("../internal/operators/windowTime");
var _windowToggle = require("../internal/operators/windowToggle");
var _windowWhen = require("../internal/operators/windowWhen");
var _withLatestFrom = require("../internal/operators/withLatestFrom");
var _zip = require("../internal/operators/zip");
var _zipAll = require("../internal/operators/zipAll");

},{"../internal/operators/audit":false,"../internal/operators/auditTime":false,"../internal/operators/buffer":false,"../internal/operators/bufferCount":false,"../internal/operators/bufferTime":false,"../internal/operators/bufferToggle":false,"../internal/operators/bufferWhen":false,"../internal/operators/catchError":false,"../internal/operators/combineAll":false,"../internal/operators/combineLatest":false,"../internal/operators/concat":false,"../internal/operators/concatAll":"kc5bR","../internal/operators/concatMap":false,"../internal/operators/concatMapTo":false,"../internal/operators/count":false,"../internal/operators/debounce":false,"../internal/operators/debounceTime":false,"../internal/operators/defaultIfEmpty":"lMGJ9","../internal/operators/delay":false,"../internal/operators/delayWhen":false,"../internal/operators/dematerialize":false,"../internal/operators/distinct":false,"../internal/operators/distinctUntilChanged":false,"../internal/operators/distinctUntilKeyChanged":false,"../internal/operators/elementAt":false,"../internal/operators/endWith":false,"../internal/operators/every":false,"../internal/operators/exhaust":false,"../internal/operators/exhaustMap":false,"../internal/operators/expand":false,"../internal/operators/filter":"eU9Jz","../internal/operators/finalize":false,"../internal/operators/find":false,"../internal/operators/findIndex":false,"../internal/operators/first":"ea0ny","../internal/operators/groupBy":"bCSbE","../internal/operators/ignoreElements":"bVSsy","../internal/operators/isEmpty":false,"../internal/operators/last":false,"../internal/operators/map":"l6Oaa","../internal/operators/mapTo":false,"../internal/operators/materialize":false,"../internal/operators/max":false,"../internal/operators/merge":false,"../internal/operators/mergeAll":"alg6S","../internal/operators/mergeMap":"7pq07","../internal/operators/mergeMapTo":false,"../internal/operators/mergeScan":false,"../internal/operators/min":false,"../internal/operators/multicast":"hzSi0","../internal/operators/observeOn":"eG2ED","../internal/operators/onErrorResumeNext":false,"../internal/operators/pairwise":false,"../internal/operators/partition":false,"../internal/operators/pluck":false,"../internal/operators/publish":false,"../internal/operators/publishBehavior":false,"../internal/operators/publishLast":false,"../internal/operators/publishReplay":false,"../internal/operators/race":false,"../internal/operators/reduce":false,"../internal/operators/repeat":false,"../internal/operators/repeatWhen":false,"../internal/operators/retry":false,"../internal/operators/retryWhen":false,"../internal/operators/refCount":"1xbxl","../internal/operators/sample":false,"../internal/operators/sampleTime":false,"../internal/operators/scan":false,"../internal/operators/sequenceEqual":false,"../internal/operators/share":"lbj48","../internal/operators/shareReplay":false,"../internal/operators/single":false,"../internal/operators/skip":false,"../internal/operators/skipLast":false,"../internal/operators/skipUntil":false,"../internal/operators/skipWhile":false,"../internal/operators/startWith":false,"../internal/operators/subscribeOn":false,"../internal/operators/switchAll":false,"../internal/operators/switchMap":false,"../internal/operators/switchMapTo":false,"../internal/operators/take":"gEcnY","../internal/operators/takeLast":false,"../internal/operators/takeUntil":false,"../internal/operators/takeWhile":false,"../internal/operators/tap":"dGqfD","../internal/operators/throttle":false,"../internal/operators/throttleTime":false,"../internal/operators/throwIfEmpty":"84X2U","../internal/operators/timeInterval":false,"../internal/operators/timeout":false,"../internal/operators/timeoutWith":false,"../internal/operators/timestamp":false,"../internal/operators/toArray":false,"../internal/operators/window":false,"../internal/operators/windowCount":false,"../internal/operators/windowTime":false,"../internal/operators/windowToggle":false,"../internal/operators/windowWhen":false,"../internal/operators/withLatestFrom":false,"../internal/operators/zip":false,"../internal/operators/zipAll":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lMGJ9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultIfEmpty", ()=>defaultIfEmpty);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) defaultValue = null;
    return function(source) {
        return source.lift(new DefaultIfEmptyOperator(defaultValue));
    };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ function() {
    function DefaultIfEmptyOperator1(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator1;
}();
var DefaultIfEmptySubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(DefaultIfEmptySubscriber1, _super);
    function DefaultIfEmptySubscriber1(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber1.prototype._next = function(value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber1.prototype._complete = function() {
        if (this.isEmpty) this.destination.next(this.defaultValue);
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ea0ny":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "first", ()=>first);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */ var _emptyError = require("../util/EmptyError");
var _filter = require("./filter");
var _take = require("./take");
var _defaultIfEmpty = require("./defaultIfEmpty");
var _throwIfEmpty = require("./throwIfEmpty");
var _identity = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
        return source.pipe(predicate ? (0, _filter.filter)(function(v, i) {
            return predicate(v, i, source);
        }) : (0, _identity.identity), (0, _take.take)(1), hasDefaultValue ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue) : (0, _throwIfEmpty.throwIfEmpty)(function() {
            return new (0, _emptyError.EmptyError)();
        }));
    };
}

},{"../util/EmptyError":"8nE0j","./filter":"eU9Jz","./take":"gEcnY","./defaultIfEmpty":"lMGJ9","./throwIfEmpty":"84X2U","../util/identity":"2wO6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gEcnY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "take", ()=>take);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
var _argumentOutOfRangeError = require("../util/ArgumentOutOfRangeError");
var _empty = require("../observable/empty");
function take(count) {
    return function(source) {
        if (count === 0) return (0, _empty.empty)();
        else return source.lift(new TakeOperator(count));
    };
}
var TakeOperator = /*@__PURE__*/ function() {
    function TakeOperator1(total) {
        this.total = total;
        if (this.total < 0) throw new (0, _argumentOutOfRangeError.ArgumentOutOfRangeError);
    }
    TakeOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator1;
}();
var TakeSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(TakeSubscriber1, _super);
    function TakeSubscriber1(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber1.prototype._next = function(value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","../util/ArgumentOutOfRangeError":"eVyky","../observable/empty":"d0sAg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84X2U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throwIfEmpty", ()=>throwIfEmpty);
/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _emptyError = require("../util/EmptyError");
var _subscriber = require("../Subscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) errorFactory = defaultErrorFactory;
    return function(source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
var ThrowIfEmptyOperator = /*@__PURE__*/ function() {
    function ThrowIfEmptyOperator1(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator1;
}();
var ThrowIfEmptySubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(ThrowIfEmptySubscriber1, _super);
    function ThrowIfEmptySubscriber1(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber1.prototype._next = function(value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber1.prototype._complete = function() {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            } catch (e) {
                err = e;
            }
            this.destination.error(err);
        } else return this.destination.complete();
    };
    return ThrowIfEmptySubscriber1;
}((0, _subscriber.Subscriber));
function defaultErrorFactory() {
    return new (0, _emptyError.EmptyError)();
}

},{"tslib":"99ylF","../util/EmptyError":"8nE0j","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bVSsy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ignoreElements", ()=>ignoreElements);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ function() {
    function IgnoreElementsOperator1() {}
    IgnoreElementsOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator1;
}();
var IgnoreElementsSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(IgnoreElementsSubscriber1, _super);
    function IgnoreElementsSubscriber1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber1.prototype._next = function(unused) {};
    return IgnoreElementsSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hzSi0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicast", ()=>multicast);
parcelHelpers.export(exports, "MulticastOperator", ()=>MulticastOperator);
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */ var _connectableObservable = require("../observable/ConnectableObservable");
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === "function") subjectFactory = subjectOrSubjectFactory;
        else subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
        if (typeof selector === "function") return source.lift(new MulticastOperator(subjectFactory, selector));
        var connectable = Object.create(source, (0, _connectableObservable.connectableObservableDescriptor));
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ function() {
    function MulticastOperator1(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator1.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator1;
}();

},{"../observable/ConnectableObservable":"hntQC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbj48":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "share", ()=>share);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */ var _multicast = require("./multicast");
var _refCount = require("./refCount");
var _subject = require("../Subject");
function shareSubjectFactory() {
    return new (0, _subject.Subject)();
}
function share() {
    return function(source) {
        return (0, _refCount.refCount)()((0, _multicast.multicast)(shareSubjectFactory)(source));
    };
}

},{"./multicast":"hzSi0","./refCount":"1xbxl","../Subject":"l0BZI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGqfD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tap", ()=>tap);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */ var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
var _noop = require("../util/noop");
var _isFunction = require("../util/isFunction");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ function() {
    function DoOperator1(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator1.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator1;
}();
var TapSubscriber = /*@__PURE__*/ function(_super) {
    _tslib.__extends(TapSubscriber1, _super);
    function TapSubscriber1(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = (0, _noop.noop);
        _this._tapError = (0, _noop.noop);
        _this._tapComplete = (0, _noop.noop);
        _this._tapError = error || (0, _noop.noop);
        _this._tapComplete = complete || (0, _noop.noop);
        if ((0, _isFunction.isFunction)(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || (0, _noop.noop);
            _this._tapError = observerOrNext.error || (0, _noop.noop);
            _this._tapComplete = observerOrNext.complete || (0, _noop.noop);
        }
        return _this;
    }
    TapSubscriber1.prototype._next = function(value) {
        try {
            this._tapNext.call(this._context, value);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber1.prototype._error = function(err) {
        try {
            this._tapError.call(this._context, err);
        } catch (err1) {
            this.destination.error(err1);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber1.prototype._complete = function() {
        try {
            this._tapComplete.call(this._context);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber1;
}((0, _subscriber.Subscriber));

},{"tslib":"99ylF","../Subscriber":"bwPOT","../util/noop":"cB2ox","../util/isFunction":"jxvPW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cIuop":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "monitorCharacteristic", ()=>monitorCharacteristic);
var _rxjs = require("rxjs");
var _logs = require("@ledgerhq/logs");
var Buffer = require("buffer").Buffer;
const monitorCharacteristic = (characteristic1)=>(0, _rxjs.Observable).create((o)=>{
        (0, _logs.log)("ble-verbose", "start monitor " + characteristic1.uuid);
        function onCharacteristicValueChanged(event) {
            const characteristic = event.target;
            if (characteristic.value) o.next(Buffer.from(characteristic.value.buffer));
        }
        characteristic1.startNotifications().then(()=>{
            characteristic1.addEventListener("characteristicvaluechanged", onCharacteristicValueChanged);
        });
        return ()=>{
            (0, _logs.log)("ble-verbose", "end monitor " + characteristic1.uuid);
            characteristic1.stopNotifications();
        };
    });

},{"rxjs":"eNCF7","@ledgerhq/logs":"i4OI0","buffer":"fCgem","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"abvtp":[function(require,module,exports) {
const Dns = require("./Dns").default;
const { DnsCollection  } = require("./DnsCollection");
const { DnsItem  } = require("./DnsItem");
module.exports.default = {
    Dns,
    DnsCollection,
    DnsItem
};

},{"./Dns":"aVEhx","./DnsCollection":"dkrqV","./DnsItem":"9Jlw3"}],"aVEhx":[function(require,module,exports) {
const { Cell  } = require("../../boc");
const { BN , Address  } = require("../../utils");
const { DNS_CATEGORY_NEXT_RESOLVER , DNS_CATEGORY_SITE , DNS_CATEGORY_WALLET , createSmartContractAddressRecord , createAdnlAddressRecord , createNextResolverRecord , parseNextResolverRecord , parseSmartContractAddressRecord , dnsResolve  } = require("./DnsUtils");
// Need to get this address from network Config #4
const rootDnsAddress = "Ef_BimcWrQ5pmAWfRqfeVHUCNV8XgsLqeAMBivKryXrghFW3";
class Dns {
    /**
     * @param provider  {HttpProvider}
     */ constructor(provider){
        this.provider = provider;
    }
    /**
     * @returns {Promise<Address>}
     */ async getRootDnsAddress() {
        if (this.provider.host.indexOf("testnet") === -1) return null;
        return new Address(rootDnsAddress);
    }
    /**
     * @param domain    {string} e.g "sub.alice.ton"
     * @param category  {string | undefined} category of requested DNS record, null for all categories
     * @param oneStep {boolean | undefined}  non-recursive
     * @returns {Promise<Cell | Address | BN | null>}
     */ resolve(domain, category, oneStep) {
        if (this.provider.host.indexOf("testnet") === -1) return null;
        return dnsResolve(this.provider, rootDnsAddress, domain, category, oneStep);
    }
    /**
     * @param domain    {string} e.g "sub.alice.ton"
     * @returns {Promise<Address | null>}
     */ getWalletAddress(domain) {
        if (this.provider.host.indexOf("testnet") === -1) return null;
        return this.resolve(domain, DNS_CATEGORY_WALLET);
    }
}
Dns.resolve = dnsResolve;
Dns.createSmartContractAddressRecord = createSmartContractAddressRecord;
Dns.createAdnlAddressRecord = createAdnlAddressRecord;
Dns.createNextResolverRecord = createNextResolverRecord;
Dns.parseNextResolverRecord = parseNextResolverRecord;
Dns.parseSmartContractAddressRecord = parseSmartContractAddressRecord;
Dns.DNS_CATEGORY_NEXT_RESOLVER = DNS_CATEGORY_NEXT_RESOLVER;
Dns.DNS_CATEGORY_WALLET = DNS_CATEGORY_WALLET;
Dns.DNS_CATEGORY_SITE = DNS_CATEGORY_SITE;
module.exports.default = Dns;

},{"../../boc":"4fqdK","../../utils":"57M1Z","./DnsUtils":"3i1BR"}],"3i1BR":[function(require,module,exports) {
const { parseAddress  } = require("../token/nft/NftUtils");
const { BN , sha256 , bytesToHex , bytesToBase64  } = require("../../utils");
const { Cell  } = require("../../boc");
const DNS_CATEGORY_NEXT_RESOLVER = "dns_next_resolver"; // Smart Contract address
const DNS_CATEGORY_WALLET = "wallet"; // Smart Contract address
const DNS_CATEGORY_SITE = "site"; // ADNL address
/**
 * @param category  {string | undefined}
 * @return  {BN}
 */ const categoryToBN = async (category)=>{
    if (!category) return new BN(0); // all categories
    const categoryBytes = new TextEncoder().encode(category);
    const categoryHash = new Uint8Array(await sha256(categoryBytes));
    return new BN(bytesToHex(categoryHash), 16);
};
/**
 * @param smartContractAddress   {Address}
 * @return {Cell}
 */ const createSmartContractAddressRecord = (smartContractAddress)=>{
    const cell = new Cell();
    cell.bits.writeUint(0x9fd3, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L827
    cell.bits.writeAddress(smartContractAddress);
    cell.bits.writeUint(0, 8); // flags
    return cell;
};
/**
 * @param adnlAddress   {BN}
 * @return {Cell}
 */ const createAdnlAddressRecord = (adnlAddress)=>{
    const cell = new Cell();
    cell.bits.writeUint(0xad01, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L821
    cell.bits.writeUint(adnlAddress, 256);
    cell.bits.writeUint(0, 8); // flags
    return cell;
};
/**
 * @param smartContractAddress   {Address}
 * @return {Cell}
 */ const createNextResolverRecord = (smartContractAddress)=>{
    const cell = new Cell();
    cell.bits.writeUint(0xba93, 16); // https://github.com/ton-blockchain/ton/blob/7e3df93ca2ab336716a230fceb1726d81bac0a06/crypto/block/block.tlb#L819
    cell.bits.writeAddress(smartContractAddress);
    return cell;
};
/**
 * @private
 * @param cell  {Cell}
 * @param prefix0 {number}
 * @param prefix1 {number}
 * @return {Address|null}
 */ const parseSmartContractAddressImpl = (cell, prefix0, prefix1)=>{
    if (cell.bits.array[0] !== prefix0 || cell.bits.array[1] !== prefix1) throw new Error("Invalid dns record value prefix");
    cell.bits.array = cell.bits.array.slice(2); // skip prefix - first 16 bits
    return parseAddress(cell);
};
/**
 * @param cell  {Cell}
 * @return {Address|null}
 */ const parseSmartContractAddressRecord = (cell)=>{
    return parseSmartContractAddressImpl(cell, 0x9f, 0xd3);
};
/**
 * @param cell  {Cell}
 * @return {Address|null}
 */ const parseNextResolverRecord = (cell)=>{
    return parseSmartContractAddressImpl(cell, 0xba, 0x93);
};
/**
 * @private
 * @param provider  {HttpProvider}
 * @param dnsAddress   {string} address of dns smart contract
 * @param rawDomainBytes {Uint8Array}
 * @param category  {string | undefined} category of requested DNS record
 * @param oneStep {boolean | undefined} non-recursive
 * @returns {Promise<Cell | Address | BN | null>}
 */ const dnsResolveImpl = async (provider, dnsAddress, rawDomainBytes, category, oneStep)=>{
    const len = rawDomainBytes.length * 8;
    const domainCell = new Cell();
    domainCell.bits.writeBytes(rawDomainBytes);
    const categoryBN = await categoryToBN(category);
    const result = await provider.call2(dnsAddress, "dnsresolve", [
        [
            "tvm.Slice",
            bytesToBase64(await domainCell.toBoc(false))
        ],
        [
            "num",
            categoryBN.toString()
        ]
    ]);
    if (result.length !== 2) throw new Error("Invalid dnsresolve response");
    const resultLen = result[0].toNumber();
    let cell = result[1];
    if (cell instanceof Array && cell.length === 0) cell = null;
    if (cell && !cell.bits) throw new Error("Invalid dnsresolve response");
    if (resultLen === 0) return null; // domain cannot be resolved
    if (resultLen % 8 !== 0) throw new Error("domain split not at a component boundary");
    // if (rawDomainBytes[resultLen] !== 0) {
    //     throw new Error('domain split not at a component boundary');
    // }
    if (resultLen > len) throw new Error("invalid response " + resultLen + "/" + len);
    else if (resultLen === len) {
        if (category === DNS_CATEGORY_NEXT_RESOLVER) return cell ? parseNextResolverRecord(cell) : null;
        else if (category === DNS_CATEGORY_WALLET) return cell ? parseSmartContractAddressRecord(cell) : null;
        else if (category === DNS_CATEGORY_SITE) return cell ? cell : null // todo: convert to BN;
        ;
        else return cell;
    } else {
        if (!cell) return null; // domain cannot be resolved
        else {
            const nextAddress = parseNextResolverRecord(cell);
            if (oneStep) {
                if (category === DNS_CATEGORY_NEXT_RESOLVER) return nextAddress;
                else return null;
            } else return await dnsResolveImpl(provider, nextAddress.toString(), rawDomainBytes.slice(resultLen / 8), category, false);
        }
    }
};
/**
 * Verify and convert domain
 * @param domain    {string}
 * @return {Uint8Array}
 */ const domainToBytes = (domain)=>{
    if (!domain || !domain.length) throw new Error("empty domain");
    if (domain === ".") return new Uint8Array([
        0
    ]);
    domain = domain.toLowerCase();
    for(let i = 0; i < domain.length; i++){
        if (domain.charCodeAt(i) <= 32) throw new Error("bytes in range 0..32 are not allowed in domain names");
    }
    for(let i1 = 0; i1 < domain.length; i1++){
        const s = domain.substring(i1, i1 + 1);
        for(let c = 127; c <= 159; c++){
            if (s === String.fromCharCode(c)) throw new Error("bytes in range 127..159 are not allowed in domain names");
        }
    }
    const arr = domain.split(".");
    arr.forEach((part)=>{
        if (!part.length) throw new Error("domain name cannot have an empty component");
    });
    const rawDomain = "\0" + arr.reverse().join("\0") + "\0";
    return new TextEncoder().encode(rawDomain);
};
/**
 * @param provider  {HttpProvider}
 * @param rootDnsAddress {string} address of root DNS smart contract
 * @param domain    {string} e.g "sub.alice.ton"
 * @param category  {string | undefined} category of requested DNS record
 * @param oneStep {boolean | undefined} non-recursive
 * @returns {Promise<Cell | Address | BN | null>}
 */ const dnsResolve = async (provider, rootDnsAddress, domain, category, oneStep)=>{
    const rawDomainBytes = domainToBytes(domain);
    return dnsResolveImpl(provider, rootDnsAddress, rawDomainBytes, category, oneStep);
};
module.exports = {
    DNS_CATEGORY_NEXT_RESOLVER,
    DNS_CATEGORY_SITE,
    DNS_CATEGORY_WALLET,
    categoryToBN,
    domainToBytes,
    createSmartContractAddressRecord,
    createAdnlAddressRecord,
    createNextResolverRecord,
    parseNextResolverRecord,
    parseSmartContractAddressRecord,
    dnsResolve
};

},{"../token/nft/NftUtils":"fLfHN","../../utils":"57M1Z","../../boc":"4fqdK"}],"dkrqV":[function(require,module,exports) {
const { Contract  } = require("../../contract/index.js");
const { Cell  } = require("../../boc");
const { Address  } = require("../../utils");
const { parseAddress  } = require("../token/nft/NftUtils.js");
const { dnsResolve  } = require("./DnsUtils.js");
const { parseOffchainUriCell  } = require("../token/nft/NftUtils");
class DnsCollection extends Contract {
    /**
     * @param provider
     * @param options   {{collectionContent: Cell, dnsItemCodeHex: string, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc("B5EE9C724102170100020E000114FF00F4A413F4BCF2C80B0102016202030202CC0405020120111202012006070201D40F1002012008090201200D0E01F543221C70094840FF2F0DED0D3030171B0915BE0FA403001D31FED44D0D4D4303122C0008E5032F00320D74920C218F2E0C8208103F0BBF2E0C978A908C000F2E0CA20F004F2E0CB20F9018050F833206EB38E10D0F4043052108307F40E6FA131F2D0CC9130E2C858CF16C9C85004CF1613CCC9F009E010235F0380A0201200B0C000EC007DC840FF2F000331C27C074C1C07000082CE500A98200B784B98C4830003CB43260004F3223880875D244B5C61673C58875D2883000082CE6C070007CB83280B50C3400A44C78B98C727420007F47021D7498E355CBA20B38E2E3002D30721C02D23C200B024A6F85240B9B022C22F23C13AB0B122C26003C17B13B012B1B320B39402A60802DE13DEE66C12BA8002D501C8CBFFF828CF16C97020C8CB0113F400F400CB00C98001B3E401D3232C084B281F2FFF274200039167C01DC087C021DE0063232C15633C59C3E80B2DAF3333260103EC020020120131402012015160007B8B5D318001FBA7A3ED44D0D4D43031F0077001F00880019B905BED44D0D4D4303070016D8009DBA30C3020D74978A908C000F2E04620D70A07C00021D749C0085210B0935B786DE0209501D3073101DE21F0025122D71830F9018200BA93C8CB0F01820167A3ED43D8CF16C90191789170E212A0018467EBCAB");
        super(provider, options);
        if (!options.collectionContent && !options.address) throw new Error("required collectionContent cell");
        this.methods.getCollectionData = this.getCollectionData.bind(this);
        this.methods.getNftItemAddressByIndex = this.getNftItemAddressByIndex.bind(this);
        this.methods.getNftItemContent = this.getNftItemContent.bind(this);
        this.methods.resolve = this.resolve.bind(this);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains dns collection data
     */ createDataCell() {
        const cell = new Cell();
        cell.refs[0] = this.options.collectionContent;
        cell.refs[1] = Cell.oneFromBoc(this.options.dnsItemCodeHex);
        return cell;
    }
    /**
     * @return {Promise<{collectionContent: Cell}>}
     */ async getCollectionData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_collection_data");
        const collectionContent = result[1];
        const collectionContentUri = parseOffchainUriCell(collectionContent);
        return {
            collectionContentUri,
            collectionContent,
            ownerAddress: null,
            nextItemIndex: 0
        };
    }
    /**
     * @param nftItem   {DnsItem}
     * @return {Promise<{isInitialized: boolean, index: BN, collectionAddress: Address|null, ownerAddress: Address|null, contentCell: Cell}>}
     */ async getNftItemContent(nftItem) {
        const nftData = await nftItem.getData();
        return nftData;
    }
    /**
     * @param index {BN}
     * @return {Promise<Address>}
     */ async getNftItemAddressByIndex(index) {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_nft_address_by_index", [
            [
                "num",
                index.toString()
            ]
        ]);
        return parseAddress(result);
    }
    /**
     * @param domain    {string} e.g "sub.alice.ton"
     * @param category?  {string} category of requested DNS record, null for all categories
     * @param oneStep? {boolean} non-recursive
     * @returns {Promise<Cell | Address | BN | null>}
     */ async resolve(domain, category, oneStep) {
        const myAddress = await this.getAddress();
        return dnsResolve(this.provider, myAddress.toString(), domain, category, oneStep);
    }
}
module.exports = {
    DnsCollection: DnsCollection
};

},{"../../contract/index.js":"drIoA","../../boc":"4fqdK","../../utils":"57M1Z","../token/nft/NftUtils.js":"fLfHN","./DnsUtils.js":"3i1BR","../token/nft/NftUtils":"fLfHN"}],"9Jlw3":[function(require,module,exports) {
const { Contract  } = require("../../contract/index.js");
const { Cell  } = require("../../boc");
const { Address , BN  } = require("../../utils");
const { parseAddress  } = require("./../token/nft/NftUtils.js");
const { dnsResolve , categoryToBN  } = require("./DnsUtils.js");
const DNS_ITEM_CODE_HEX = "B5EE9C7241022C010006F8000114FF00F4A413F4BCF2C80B0102016202030202CC0405020120232402012006070201481F2002014808090201201B1C03F7007434C0C05C6C2497C1383E903E900C7E800C5C75C87E800C7E800C3C0249ECF8C094D671C1462C238CC426D7C2FE900C1C14C01B60101C20043232C15401F3C594017E808572DA84B2C7F2CFC89BACE51633C5C0644CB88072407EC0380A71C0245C254274C7D42AB8887C01FE08C86F09300038C08C4374CFC9600A0B0C00113E910C1C2EBCB8536002FC5F056C22355242C705F2E19501FA40D4306D21D08B42E746F6E8F00682F082A3537FF0DBCE7EEC35D69EDC3A189EE6F17D82F353A553F9AA96CB0BE3CE89588307F4168BA544F4E20446F6D61696E86DF00682F0C9046F7A37AD0EA7CEE73355984FA5428982F8B37C8F7BCEC91F7AC71A7CD104588307F4168922D0F0060D0E013C343A3A3B8E1636363737375135C705F2E196102510241023F823F00AE30E0F03FC6EB31FB08E5A343652DDA1820AFAF0805210A15260BC9835820AFAF08015A1923004E220C2FF8E2F77706D722951454434708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00DE0C6D0DA150CC0B04923E5BE2F82328A18209E14320BC226EB0E30282105FCC3D145210BAE302101112003A68747470733A2F2F646E732E746F6E2E6F72672F69636F6E2E706E672300C682F06105D6CC76AF400325E94D588CE511BE5BFDBB73B437DC51ECA43917D7A43E3D588307F41670C8CB07F400C981012C8050F833206EB38E14D0F4043070018307F40E6FA19431D31F309130E29130E2F82301A0F0054466F00810351034F823F00A00F0302680698064A98452A0BCF2E197820AFAF08052B0A15270BC9836820AFAF0801AA1933A0905E220C2FF8E2C70206D21105B708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00923036E27A23F823A1A120C2009313A0029130E24464F00810451024F823F00A00305B6C55F005F82381012CA04470F0081045103412F823F00A0128305383C705F2E191105A104910381027103655021303FE82102FCB26A25210BA8E3F5F0535365B7082108B77173505C8CBFF5003CF164440138040708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00E082101A0B9D515210BA8E193032353537375135C705F2E19A03D4304015045033F823F00AE020C00AE3023A09C00BE3025F0B840F14151603F63603FA4021F001FA40D20031FA00820AFAF0801EA121945315A0A1DE22D70B01C300209206A19136E220C2FFF2E192218E3E821005138D91C8500CCF16500ECF1671244C145449D0708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00107A94102D3A5BE202E30F105618191A0086303739395155C705F2E19B05D3FF20D74AC20009D0D30701C000F2E19CF404300999D430D040188307F416983050078307F45B30E270C8CB07F400C91045034444F00A01DA8050F833D0F4043052508307F40E6FA18ED7D30721C0008E932510BD107A09105810471046105C4313504C1D96303B5F036C61E201C0018E2D7053006D8100A0708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB009130E2925F0CE2170004F2F003F83603FA4021F001FA40D20031FA00820AFAF0801EA121945315A0A1DE22D70B01C300209206A19136E220C2FFF2E192218E3E821005138D91C8500CCF16500ECF1671244C145449D0708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00107A94102D3A5BE202E30F10560118191A006A29F0018210D53276DB103A47046D71708010C8CB055007CF165005FA0215CB6A12CB1FCB3F226EB39458CF17019132E201C901FB00000A10293335300010104510344033F00A000D570C8CB01C9D080201201D1E00531C3232C1C8B3C5885BACE385C0B5D24875D2682040FDEEE4B3C5A5F20073C5B2407338A49B0878B274200021081BA50C1B5C0838343E903E8034CFCC200201202122002B406C8CBFF5005CF165003CF16CCCCF400CB3FC9ED5480017321400F3C5807E80B2CFF26000513B513434FFFE900835D2708027DFC07E9035353D0134CFCC0415C415B80C1C1B5B5B5B490415C415A0020120252602012027280013BBB39F009175F07F0078000DBA559F0096C718000DB8FCFF0095F038020120292A0013B64A5E012204EBE0FA1001FBB461843AE9240F152118001E5C08DE012206EBE0FA1A60E038001E5C339E8086047AE140E68078001E5C33B80111C344180012660F003C003060FE81CDF432CF190B19E2D93C060F0DBC06105E033E04883DCB11FB64DDC4964AD1BA06B879240DC23572F37CC5CAAAB143A2FFE03060FE81CDF432CF190B19E2D93C06102B0004786DA9E7FD01";
class DnsItem extends Contract {
    /**
     * @param provider
     * @param options   {{index: BN, collectionAddress: Address, address?: Address | string, code?: Cell}}
     */ constructor(provider, options){
        options.wc = 0;
        options.code = options.code || Cell.oneFromBoc(DNS_ITEM_CODE_HEX);
        super(provider, options);
        this.methods.getData = this.getData.bind(this);
        this.methods.getDomain = this.getDomain.bind(this);
        this.methods.getAuctionInfo = this.getAuctionInfo.bind(this);
        this.methods.getLastFillUpTime = this.getLastFillUpTime.bind(this);
        this.methods.resolve = this.resolve.bind(this);
    }
    /**
     * @override
     * @private
     * @return {Cell} cell contains nft data
     */ createDataCell() {
        const cell = new Cell();
        cell.bits.writeUint(this.options.index, 256);
        cell.bits.writeAddress(this.options.collectionAddress);
        return cell;
    }
    /**
     * @return {Promise<{isInitialized: boolean, index: BN, collectionAddress: Address|null, ownerAddress: Address|null, contentCell: Cell}>}
     */ async getData() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_nft_data");
        const isInitialized = result[0].toNumber() === -1;
        const index = result[1];
        const collectionAddress = parseAddress(result[2]);
        const ownerAddress = isInitialized ? parseAddress(result[3]) : null;
        const contentCell = result[4];
        return {
            isInitialized,
            index,
            collectionAddress,
            ownerAddress,
            contentCell
        };
    }
    /**
     * @param params    {{queryId?: number, newOwnerAddress: Address, forwardAmount?: BN, forwardPayload?: Uint8Array, responseAddress: Address}}
     */ async createTransferBody(params) {
        const cell = new Cell();
        cell.bits.writeUint(0x5fcc3d14, 32); // transfer op
        cell.bits.writeUint(params.queryId || 0, 64);
        cell.bits.writeAddress(params.newOwnerAddress);
        cell.bits.writeAddress(params.responseAddress);
        cell.bits.writeBit(false); // null custom_payload
        cell.bits.writeCoins(params.forwardAmount || new BN(0));
        cell.bits.writeBit(false); // forward_payload in this slice, not separate cell
        if (params.forwardPayload) cell.bits.writeBytes(params.forwardPayload);
        return cell;
    }
    /**
     * params   {{queryId?: number}}
     * @return {Cell}
     */ createGetStaticDataBody(params) {
        const body = new Cell();
        body.bits.writeUint(0x2fcb26a2, 32); // OP
        body.bits.writeUint(params.queryId || 0, 64); // query_id
        return body;
    }
    /**
     * @return {Promise<string>}
     */ async getDomain() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_domain");
        return new TextDecoder().decode(result.bits.array.buffer);
    }
    /**
     * @return {Promise<{maxBidAddress: Address|null, maxBidAmount: BN, auctionEndTime: number}>}
     */ async getAuctionInfo() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_auction_info");
        const maxBidAddress = parseAddress(result[0]);
        const maxBidAmount = result[1];
        const auctionEndTime = result[2].toNumber();
        return {
            maxBidAddress,
            maxBidAmount,
            auctionEndTime
        };
    }
    /**
     * @return {Promise<number>}
     */ async getLastFillUpTime() {
        const myAddress = await this.getAddress();
        const result = await this.provider.call2(myAddress.toString(), "get_last_fill_up_time");
        return result.toNumber();
    }
    /**
     * @param domain    {string} e.g "sub.alice.ton"
     * @param category?  {string} category of requested DNS record, null for all categories
     * @param oneStep? {boolean} non-recursive
     * @returns {Promise<Cell | Address | BN | null>}
     */ async resolve(domain, category, oneStep) {
        const myAddress = await this.getAddress();
        return dnsResolve(this.provider, myAddress.toString(), domain, category, oneStep);
    }
}
/**
 * params   {{category: string, value: Cell|null, queryId?: number}}
 * @return {Cell}
 */ DnsItem.createChangeContentEntryBody = async (params)=>{
    const body = new Cell();
    body.bits.writeUint(10, 32); // OP
    body.bits.writeUint(params.queryId || 0, 64); // query_id
    body.bits.writeUint(await categoryToBN(params.category), 256);
    if (params.value) body.refs[0] = params.value;
    return body;
};
DnsItem.codeHex = DNS_ITEM_CODE_HEX;
module.exports = {
    DnsItem: DnsItem
};

},{"../../contract/index.js":"drIoA","../../boc":"4fqdK","../../utils":"57M1Z","./../token/nft/NftUtils.js":"fLfHN","./DnsUtils.js":"3i1BR"}],"jL58h":[function(require,module,exports) {
!function(e, r) {
    module.exports = r();
}(self, function() {
    return (()=>{
        var e1 = {
            780: (e2, r2, t2)=>{
                !function(e3) {
                    "use strict";
                    var r3 = function(e) {
                        var r, t = new Float64Array(16);
                        if (e) for(r = 0; r < e.length; r++)t[r] = e[r];
                        return t;
                    }, a2 = function() {
                        throw new Error("no PRNG");
                    }, n1 = new Uint8Array(16), o1 = new Uint8Array(32);
                    o1[0] = 9;
                    var i1 = r3(), s1 = r3([
                        1
                    ]), l1 = r3([
                        56129,
                        1
                    ]), c1 = r3([
                        30883,
                        4953,
                        19914,
                        30187,
                        55467,
                        16705,
                        2637,
                        112,
                        59544,
                        30585,
                        16505,
                        36039,
                        65139,
                        11119,
                        27886,
                        20995
                    ]), u1 = r3([
                        61785,
                        9906,
                        39828,
                        60374,
                        45398,
                        33411,
                        5274,
                        224,
                        53552,
                        61171,
                        33010,
                        6542,
                        64743,
                        22239,
                        55772,
                        9222
                    ]), h1 = r3([
                        54554,
                        36645,
                        11616,
                        51542,
                        42930,
                        38181,
                        51040,
                        26924,
                        56412,
                        64982,
                        57905,
                        49316,
                        21502,
                        52590,
                        14035,
                        8553
                    ]), f1 = r3([
                        26200,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214,
                        26214
                    ]), d1 = r3([
                        41136,
                        18958,
                        6951,
                        50414,
                        58488,
                        44335,
                        6150,
                        12099,
                        55207,
                        15867,
                        153,
                        11085,
                        57099,
                        20417,
                        9344,
                        11139
                    ]);
                    function p1(e, r, t, a) {
                        e[r] = t >> 24 & 255, e[r + 1] = t >> 16 & 255, e[r + 2] = t >> 8 & 255, e[r + 3] = 255 & t, e[r + 4] = a >> 24 & 255, e[r + 5] = a >> 16 & 255, e[r + 6] = a >> 8 & 255, e[r + 7] = 255 & a;
                    }
                    function y1(e, r, t, a, n) {
                        var o, i = 0;
                        for(o = 0; o < n; o++)i |= e[r + o] ^ t[a + o];
                        return (1 & i - 1 >>> 8) - 1;
                    }
                    function g1(e, r, t, a) {
                        return y1(e, r, t, a, 16);
                    }
                    function m1(e, r, t, a) {
                        return y1(e, r, t, a, 32);
                    }
                    function b1(e4, r4, t3, a3) {
                        !function(e, r, t, a) {
                            for(var n, o = 255 & a[0] | (255 & a[1]) << 8 | (255 & a[2]) << 16 | (255 & a[3]) << 24, i = 255 & t[0] | (255 & t[1]) << 8 | (255 & t[2]) << 16 | (255 & t[3]) << 24, s = 255 & t[4] | (255 & t[5]) << 8 | (255 & t[6]) << 16 | (255 & t[7]) << 24, l = 255 & t[8] | (255 & t[9]) << 8 | (255 & t[10]) << 16 | (255 & t[11]) << 24, c = 255 & t[12] | (255 & t[13]) << 8 | (255 & t[14]) << 16 | (255 & t[15]) << 24, u = 255 & a[4] | (255 & a[5]) << 8 | (255 & a[6]) << 16 | (255 & a[7]) << 24, h = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, f = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, d = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, p = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, y = 255 & a[8] | (255 & a[9]) << 8 | (255 & a[10]) << 16 | (255 & a[11]) << 24, g = 255 & t[16] | (255 & t[17]) << 8 | (255 & t[18]) << 16 | (255 & t[19]) << 24, m = 255 & t[20] | (255 & t[21]) << 8 | (255 & t[22]) << 16 | (255 & t[23]) << 24, b = 255 & t[24] | (255 & t[25]) << 8 | (255 & t[26]) << 16 | (255 & t[27]) << 24, w = 255 & t[28] | (255 & t[29]) << 8 | (255 & t[30]) << 16 | (255 & t[31]) << 24, v = 255 & a[12] | (255 & a[13]) << 8 | (255 & a[14]) << 16 | (255 & a[15]) << 24, k = o, x = i, A = s, _ = l, U = c, E = u, M = h, z = f, j = d, S = p, B = y, T = g, K = m, P = b, Y = w, q = v, L = 0; L < 20; L += 2)k ^= (n = (K ^= (n = (j ^= (n = (U ^= (n = k + K | 0) << 7 | n >>> 25) + k | 0) << 9 | n >>> 23) + U | 0) << 13 | n >>> 19) + j | 0) << 18 | n >>> 14, E ^= (n = (x ^= (n = (P ^= (n = (S ^= (n = E + x | 0) << 7 | n >>> 25) + E | 0) << 9 | n >>> 23) + S | 0) << 13 | n >>> 19) + P | 0) << 18 | n >>> 14, B ^= (n = (M ^= (n = (A ^= (n = (Y ^= (n = B + M | 0) << 7 | n >>> 25) + B | 0) << 9 | n >>> 23) + Y | 0) << 13 | n >>> 19) + A | 0) << 18 | n >>> 14, q ^= (n = (T ^= (n = (z ^= (n = (_ ^= (n = q + T | 0) << 7 | n >>> 25) + q | 0) << 9 | n >>> 23) + _ | 0) << 13 | n >>> 19) + z | 0) << 18 | n >>> 14, k ^= (n = (_ ^= (n = (A ^= (n = (x ^= (n = k + _ | 0) << 7 | n >>> 25) + k | 0) << 9 | n >>> 23) + x | 0) << 13 | n >>> 19) + A | 0) << 18 | n >>> 14, E ^= (n = (U ^= (n = (z ^= (n = (M ^= (n = E + U | 0) << 7 | n >>> 25) + E | 0) << 9 | n >>> 23) + M | 0) << 13 | n >>> 19) + z | 0) << 18 | n >>> 14, B ^= (n = (S ^= (n = (j ^= (n = (T ^= (n = B + S | 0) << 7 | n >>> 25) + B | 0) << 9 | n >>> 23) + T | 0) << 13 | n >>> 19) + j | 0) << 18 | n >>> 14, q ^= (n = (Y ^= (n = (P ^= (n = (K ^= (n = q + Y | 0) << 7 | n >>> 25) + q | 0) << 9 | n >>> 23) + K | 0) << 13 | n >>> 19) + P | 0) << 18 | n >>> 14;
                            k = k + o | 0, x = x + i | 0, A = A + s | 0, _ = _ + l | 0, U = U + c | 0, E = E + u | 0, M = M + h | 0, z = z + f | 0, j = j + d | 0, S = S + p | 0, B = B + y | 0, T = T + g | 0, K = K + m | 0, P = P + b | 0, Y = Y + w | 0, q = q + v | 0, e[0] = k >>> 0 & 255, e[1] = k >>> 8 & 255, e[2] = k >>> 16 & 255, e[3] = k >>> 24 & 255, e[4] = x >>> 0 & 255, e[5] = x >>> 8 & 255, e[6] = x >>> 16 & 255, e[7] = x >>> 24 & 255, e[8] = A >>> 0 & 255, e[9] = A >>> 8 & 255, e[10] = A >>> 16 & 255, e[11] = A >>> 24 & 255, e[12] = _ >>> 0 & 255, e[13] = _ >>> 8 & 255, e[14] = _ >>> 16 & 255, e[15] = _ >>> 24 & 255, e[16] = U >>> 0 & 255, e[17] = U >>> 8 & 255, e[18] = U >>> 16 & 255, e[19] = U >>> 24 & 255, e[20] = E >>> 0 & 255, e[21] = E >>> 8 & 255, e[22] = E >>> 16 & 255, e[23] = E >>> 24 & 255, e[24] = M >>> 0 & 255, e[25] = M >>> 8 & 255, e[26] = M >>> 16 & 255, e[27] = M >>> 24 & 255, e[28] = z >>> 0 & 255, e[29] = z >>> 8 & 255, e[30] = z >>> 16 & 255, e[31] = z >>> 24 & 255, e[32] = j >>> 0 & 255, e[33] = j >>> 8 & 255, e[34] = j >>> 16 & 255, e[35] = j >>> 24 & 255, e[36] = S >>> 0 & 255, e[37] = S >>> 8 & 255, e[38] = S >>> 16 & 255, e[39] = S >>> 24 & 255, e[40] = B >>> 0 & 255, e[41] = B >>> 8 & 255, e[42] = B >>> 16 & 255, e[43] = B >>> 24 & 255, e[44] = T >>> 0 & 255, e[45] = T >>> 8 & 255, e[46] = T >>> 16 & 255, e[47] = T >>> 24 & 255, e[48] = K >>> 0 & 255, e[49] = K >>> 8 & 255, e[50] = K >>> 16 & 255, e[51] = K >>> 24 & 255, e[52] = P >>> 0 & 255, e[53] = P >>> 8 & 255, e[54] = P >>> 16 & 255, e[55] = P >>> 24 & 255, e[56] = Y >>> 0 & 255, e[57] = Y >>> 8 & 255, e[58] = Y >>> 16 & 255, e[59] = Y >>> 24 & 255, e[60] = q >>> 0 & 255, e[61] = q >>> 8 & 255, e[62] = q >>> 16 & 255, e[63] = q >>> 24 & 255;
                        }(e4, r4, t3, a3);
                    }
                    function w1(e5, r5, t4, a4) {
                        !function(e, r, t, a) {
                            for(var n, o = 255 & a[0] | (255 & a[1]) << 8 | (255 & a[2]) << 16 | (255 & a[3]) << 24, i = 255 & t[0] | (255 & t[1]) << 8 | (255 & t[2]) << 16 | (255 & t[3]) << 24, s = 255 & t[4] | (255 & t[5]) << 8 | (255 & t[6]) << 16 | (255 & t[7]) << 24, l = 255 & t[8] | (255 & t[9]) << 8 | (255 & t[10]) << 16 | (255 & t[11]) << 24, c = 255 & t[12] | (255 & t[13]) << 8 | (255 & t[14]) << 16 | (255 & t[15]) << 24, u = 255 & a[4] | (255 & a[5]) << 8 | (255 & a[6]) << 16 | (255 & a[7]) << 24, h = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, f = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, d = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, p = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, y = 255 & a[8] | (255 & a[9]) << 8 | (255 & a[10]) << 16 | (255 & a[11]) << 24, g = 255 & t[16] | (255 & t[17]) << 8 | (255 & t[18]) << 16 | (255 & t[19]) << 24, m = 255 & t[20] | (255 & t[21]) << 8 | (255 & t[22]) << 16 | (255 & t[23]) << 24, b = 255 & t[24] | (255 & t[25]) << 8 | (255 & t[26]) << 16 | (255 & t[27]) << 24, w = 255 & t[28] | (255 & t[29]) << 8 | (255 & t[30]) << 16 | (255 & t[31]) << 24, v = 255 & a[12] | (255 & a[13]) << 8 | (255 & a[14]) << 16 | (255 & a[15]) << 24, k = 0; k < 20; k += 2)o ^= (n = (m ^= (n = (d ^= (n = (c ^= (n = o + m | 0) << 7 | n >>> 25) + o | 0) << 9 | n >>> 23) + c | 0) << 13 | n >>> 19) + d | 0) << 18 | n >>> 14, u ^= (n = (i ^= (n = (b ^= (n = (p ^= (n = u + i | 0) << 7 | n >>> 25) + u | 0) << 9 | n >>> 23) + p | 0) << 13 | n >>> 19) + b | 0) << 18 | n >>> 14, y ^= (n = (h ^= (n = (s ^= (n = (w ^= (n = y + h | 0) << 7 | n >>> 25) + y | 0) << 9 | n >>> 23) + w | 0) << 13 | n >>> 19) + s | 0) << 18 | n >>> 14, v ^= (n = (g ^= (n = (f ^= (n = (l ^= (n = v + g | 0) << 7 | n >>> 25) + v | 0) << 9 | n >>> 23) + l | 0) << 13 | n >>> 19) + f | 0) << 18 | n >>> 14, o ^= (n = (l ^= (n = (s ^= (n = (i ^= (n = o + l | 0) << 7 | n >>> 25) + o | 0) << 9 | n >>> 23) + i | 0) << 13 | n >>> 19) + s | 0) << 18 | n >>> 14, u ^= (n = (c ^= (n = (f ^= (n = (h ^= (n = u + c | 0) << 7 | n >>> 25) + u | 0) << 9 | n >>> 23) + h | 0) << 13 | n >>> 19) + f | 0) << 18 | n >>> 14, y ^= (n = (p ^= (n = (d ^= (n = (g ^= (n = y + p | 0) << 7 | n >>> 25) + y | 0) << 9 | n >>> 23) + g | 0) << 13 | n >>> 19) + d | 0) << 18 | n >>> 14, v ^= (n = (w ^= (n = (b ^= (n = (m ^= (n = v + w | 0) << 7 | n >>> 25) + v | 0) << 9 | n >>> 23) + m | 0) << 13 | n >>> 19) + b | 0) << 18 | n >>> 14;
                            e[0] = o >>> 0 & 255, e[1] = o >>> 8 & 255, e[2] = o >>> 16 & 255, e[3] = o >>> 24 & 255, e[4] = u >>> 0 & 255, e[5] = u >>> 8 & 255, e[6] = u >>> 16 & 255, e[7] = u >>> 24 & 255, e[8] = y >>> 0 & 255, e[9] = y >>> 8 & 255, e[10] = y >>> 16 & 255, e[11] = y >>> 24 & 255, e[12] = v >>> 0 & 255, e[13] = v >>> 8 & 255, e[14] = v >>> 16 & 255, e[15] = v >>> 24 & 255, e[16] = h >>> 0 & 255, e[17] = h >>> 8 & 255, e[18] = h >>> 16 & 255, e[19] = h >>> 24 & 255, e[20] = f >>> 0 & 255, e[21] = f >>> 8 & 255, e[22] = f >>> 16 & 255, e[23] = f >>> 24 & 255, e[24] = d >>> 0 & 255, e[25] = d >>> 8 & 255, e[26] = d >>> 16 & 255, e[27] = d >>> 24 & 255, e[28] = p >>> 0 & 255, e[29] = p >>> 8 & 255, e[30] = p >>> 16 & 255, e[31] = p >>> 24 & 255;
                        }(e5, r5, t4, a4);
                    }
                    var v1 = new Uint8Array([
                        101,
                        120,
                        112,
                        97,
                        110,
                        100,
                        32,
                        51,
                        50,
                        45,
                        98,
                        121,
                        116,
                        101,
                        32,
                        107
                    ]);
                    function k1(e, r, t, a, n, o, i) {
                        var s, l, c = new Uint8Array(16), u = new Uint8Array(64);
                        for(l = 0; l < 16; l++)c[l] = 0;
                        for(l = 0; l < 8; l++)c[l] = o[l];
                        for(; n >= 64;){
                            for(b1(u, c, i, v1), l = 0; l < 64; l++)e[r + l] = t[a + l] ^ u[l];
                            for(s = 1, l = 8; l < 16; l++)s = s + (255 & c[l]) | 0, c[l] = 255 & s, s >>>= 8;
                            n -= 64, r += 64, a += 64;
                        }
                        if (n > 0) for(b1(u, c, i, v1), l = 0; l < n; l++)e[r + l] = t[a + l] ^ u[l];
                        return 0;
                    }
                    function x1(e, r, t, a, n) {
                        var o, i, s = new Uint8Array(16), l = new Uint8Array(64);
                        for(i = 0; i < 16; i++)s[i] = 0;
                        for(i = 0; i < 8; i++)s[i] = a[i];
                        for(; t >= 64;){
                            for(b1(l, s, n, v1), i = 0; i < 64; i++)e[r + i] = l[i];
                            for(o = 1, i = 8; i < 16; i++)o = o + (255 & s[i]) | 0, s[i] = 255 & o, o >>>= 8;
                            t -= 64, r += 64;
                        }
                        if (t > 0) for(b1(l, s, n, v1), i = 0; i < t; i++)e[r + i] = l[i];
                        return 0;
                    }
                    function A1(e, r, t, a, n) {
                        var o = new Uint8Array(32);
                        w1(o, a, n, v1);
                        for(var i = new Uint8Array(8), s = 0; s < 8; s++)i[s] = a[s + 16];
                        return x1(e, r, t, i, o);
                    }
                    function _1(e, r, t, a, n, o, i) {
                        var s = new Uint8Array(32);
                        w1(s, o, i, v1);
                        for(var l = new Uint8Array(8), c = 0; c < 8; c++)l[c] = o[c + 16];
                        return k1(e, r, t, a, n, l, s);
                    }
                    var U1 = function(e) {
                        var r, t, a, n, o, i, s, l;
                        this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, r = 255 & e[0] | (255 & e[1]) << 8, this.r[0] = 8191 & r, t = 255 & e[2] | (255 & e[3]) << 8, this.r[1] = 8191 & (r >>> 13 | t << 3), a = 255 & e[4] | (255 & e[5]) << 8, this.r[2] = 7939 & (t >>> 10 | a << 6), n = 255 & e[6] | (255 & e[7]) << 8, this.r[3] = 8191 & (a >>> 7 | n << 9), o = 255 & e[8] | (255 & e[9]) << 8, this.r[4] = 255 & (n >>> 4 | o << 12), this.r[5] = o >>> 1 & 8190, i = 255 & e[10] | (255 & e[11]) << 8, this.r[6] = 8191 & (o >>> 14 | i << 2), s = 255 & e[12] | (255 & e[13]) << 8, this.r[7] = 8065 & (i >>> 11 | s << 5), l = 255 & e[14] | (255 & e[15]) << 8, this.r[8] = 8191 & (s >>> 8 | l << 8), this.r[9] = l >>> 5 & 127, this.pad[0] = 255 & e[16] | (255 & e[17]) << 8, this.pad[1] = 255 & e[18] | (255 & e[19]) << 8, this.pad[2] = 255 & e[20] | (255 & e[21]) << 8, this.pad[3] = 255 & e[22] | (255 & e[23]) << 8, this.pad[4] = 255 & e[24] | (255 & e[25]) << 8, this.pad[5] = 255 & e[26] | (255 & e[27]) << 8, this.pad[6] = 255 & e[28] | (255 & e[29]) << 8, this.pad[7] = 255 & e[30] | (255 & e[31]) << 8;
                    };
                    function E1(e, r, t, a, n, o) {
                        var i = new U1(o);
                        return i.update(t, a, n), i.finish(e, r), 0;
                    }
                    function M1(e, r, t, a, n, o) {
                        var i = new Uint8Array(16);
                        return E1(i, 0, t, a, n, o), g1(e, r, i, 0);
                    }
                    function z1(e, r, t, a, n) {
                        var o;
                        if (t < 32) return -1;
                        for(_1(e, 0, r, 0, t, a, n), E1(e, 16, e, 32, t - 32, e), o = 0; o < 16; o++)e[o] = 0;
                        return 0;
                    }
                    function j1(e, r, t, a, n) {
                        var o, i = new Uint8Array(32);
                        if (t < 32) return -1;
                        if (A1(i, 0, 32, a, n), 0 !== M1(r, 16, r, 32, t - 32, i)) return -1;
                        for(_1(e, 0, r, 0, t, a, n), o = 0; o < 32; o++)e[o] = 0;
                        return 0;
                    }
                    function S1(e, r) {
                        var t;
                        for(t = 0; t < 16; t++)e[t] = 0 | r[t];
                    }
                    function B1(e) {
                        var r, t, a = 1;
                        for(r = 0; r < 16; r++)t = e[r] + a + 65535, a = Math.floor(t / 65536), e[r] = t - 65536 * a;
                        e[0] += a - 1 + 37 * (a - 1);
                    }
                    function T1(e, r, t) {
                        for(var a, n = ~(t - 1), o = 0; o < 16; o++)a = n & (e[o] ^ r[o]), e[o] ^= a, r[o] ^= a;
                    }
                    function K1(e, t) {
                        var a, n, o, i = r3(), s = r3();
                        for(a = 0; a < 16; a++)s[a] = t[a];
                        for(B1(s), B1(s), B1(s), n = 0; n < 2; n++){
                            for(i[0] = s[0] - 65517, a = 1; a < 15; a++)i[a] = s[a] - 65535 - (i[a - 1] >> 16 & 1), i[a - 1] &= 65535;
                            i[15] = s[15] - 32767 - (i[14] >> 16 & 1), o = i[15] >> 16 & 1, i[14] &= 65535, T1(s, i, 1 - o);
                        }
                        for(a = 0; a < 16; a++)e[2 * a] = 255 & s[a], e[2 * a + 1] = s[a] >> 8;
                    }
                    function P1(e, r) {
                        var t = new Uint8Array(32), a = new Uint8Array(32);
                        return K1(t, e), K1(a, r), m1(t, 0, a, 0);
                    }
                    function Y1(e) {
                        var r = new Uint8Array(32);
                        return K1(r, e), 1 & r[0];
                    }
                    function q1(e, r) {
                        var t;
                        for(t = 0; t < 16; t++)e[t] = r[2 * t] + (r[2 * t + 1] << 8);
                        e[15] &= 32767;
                    }
                    function L1(e, r, t) {
                        for(var a = 0; a < 16; a++)e[a] = r[a] + t[a];
                    }
                    function O1(e, r, t) {
                        for(var a = 0; a < 16; a++)e[a] = r[a] - t[a];
                    }
                    function R1(e, r, t) {
                        var a, n, o = 0, i = 0, s = 0, l = 0, c = 0, u = 0, h = 0, f = 0, d = 0, p = 0, y = 0, g = 0, m = 0, b = 0, w = 0, v = 0, k = 0, x = 0, A = 0, _ = 0, U = 0, E = 0, M = 0, z = 0, j = 0, S = 0, B = 0, T = 0, K = 0, P = 0, Y = 0, q = t[0], L = t[1], O = t[2], R = t[3], N = t[4], C = t[5], F = t[6], I = t[7], Z = t[8], D = t[9], G = t[10], H = t[11], V = t[12], W = t[13], X = t[14], $ = t[15];
                        o += (a = r[0]) * q, i += a * L, s += a * O, l += a * R, c += a * N, u += a * C, h += a * F, f += a * I, d += a * Z, p += a * D, y += a * G, g += a * H, m += a * V, b += a * W, w += a * X, v += a * $, i += (a = r[1]) * q, s += a * L, l += a * O, c += a * R, u += a * N, h += a * C, f += a * F, d += a * I, p += a * Z, y += a * D, g += a * G, m += a * H, b += a * V, w += a * W, v += a * X, k += a * $, s += (a = r[2]) * q, l += a * L, c += a * O, u += a * R, h += a * N, f += a * C, d += a * F, p += a * I, y += a * Z, g += a * D, m += a * G, b += a * H, w += a * V, v += a * W, k += a * X, x += a * $, l += (a = r[3]) * q, c += a * L, u += a * O, h += a * R, f += a * N, d += a * C, p += a * F, y += a * I, g += a * Z, m += a * D, b += a * G, w += a * H, v += a * V, k += a * W, x += a * X, A += a * $, c += (a = r[4]) * q, u += a * L, h += a * O, f += a * R, d += a * N, p += a * C, y += a * F, g += a * I, m += a * Z, b += a * D, w += a * G, v += a * H, k += a * V, x += a * W, A += a * X, _ += a * $, u += (a = r[5]) * q, h += a * L, f += a * O, d += a * R, p += a * N, y += a * C, g += a * F, m += a * I, b += a * Z, w += a * D, v += a * G, k += a * H, x += a * V, A += a * W, _ += a * X, U += a * $, h += (a = r[6]) * q, f += a * L, d += a * O, p += a * R, y += a * N, g += a * C, m += a * F, b += a * I, w += a * Z, v += a * D, k += a * G, x += a * H, A += a * V, _ += a * W, U += a * X, E += a * $, f += (a = r[7]) * q, d += a * L, p += a * O, y += a * R, g += a * N, m += a * C, b += a * F, w += a * I, v += a * Z, k += a * D, x += a * G, A += a * H, _ += a * V, U += a * W, E += a * X, M += a * $, d += (a = r[8]) * q, p += a * L, y += a * O, g += a * R, m += a * N, b += a * C, w += a * F, v += a * I, k += a * Z, x += a * D, A += a * G, _ += a * H, U += a * V, E += a * W, M += a * X, z += a * $, p += (a = r[9]) * q, y += a * L, g += a * O, m += a * R, b += a * N, w += a * C, v += a * F, k += a * I, x += a * Z, A += a * D, _ += a * G, U += a * H, E += a * V, M += a * W, z += a * X, j += a * $, y += (a = r[10]) * q, g += a * L, m += a * O, b += a * R, w += a * N, v += a * C, k += a * F, x += a * I, A += a * Z, _ += a * D, U += a * G, E += a * H, M += a * V, z += a * W, j += a * X, S += a * $, g += (a = r[11]) * q, m += a * L, b += a * O, w += a * R, v += a * N, k += a * C, x += a * F, A += a * I, _ += a * Z, U += a * D, E += a * G, M += a * H, z += a * V, j += a * W, S += a * X, B += a * $, m += (a = r[12]) * q, b += a * L, w += a * O, v += a * R, k += a * N, x += a * C, A += a * F, _ += a * I, U += a * Z, E += a * D, M += a * G, z += a * H, j += a * V, S += a * W, B += a * X, T += a * $, b += (a = r[13]) * q, w += a * L, v += a * O, k += a * R, x += a * N, A += a * C, _ += a * F, U += a * I, E += a * Z, M += a * D, z += a * G, j += a * H, S += a * V, B += a * W, T += a * X, K += a * $, w += (a = r[14]) * q, v += a * L, k += a * O, x += a * R, A += a * N, _ += a * C, U += a * F, E += a * I, M += a * Z, z += a * D, j += a * G, S += a * H, B += a * V, T += a * W, K += a * X, P += a * $, v += (a = r[15]) * q, i += 38 * (x += a * O), s += 38 * (A += a * R), l += 38 * (_ += a * N), c += 38 * (U += a * C), u += 38 * (E += a * F), h += 38 * (M += a * I), f += 38 * (z += a * Z), d += 38 * (j += a * D), p += 38 * (S += a * G), y += 38 * (B += a * H), g += 38 * (T += a * V), m += 38 * (K += a * W), b += 38 * (P += a * X), w += 38 * (Y += a * $), o = (a = (o += 38 * (k += a * L)) + (n = 1) + 65535) - 65536 * (n = Math.floor(a / 65536)), i = (a = i + n + 65535) - 65536 * (n = Math.floor(a / 65536)), s = (a = s + n + 65535) - 65536 * (n = Math.floor(a / 65536)), l = (a = l + n + 65535) - 65536 * (n = Math.floor(a / 65536)), c = (a = c + n + 65535) - 65536 * (n = Math.floor(a / 65536)), u = (a = u + n + 65535) - 65536 * (n = Math.floor(a / 65536)), h = (a = h + n + 65535) - 65536 * (n = Math.floor(a / 65536)), f = (a = f + n + 65535) - 65536 * (n = Math.floor(a / 65536)), d = (a = d + n + 65535) - 65536 * (n = Math.floor(a / 65536)), p = (a = p + n + 65535) - 65536 * (n = Math.floor(a / 65536)), y = (a = y + n + 65535) - 65536 * (n = Math.floor(a / 65536)), g = (a = g + n + 65535) - 65536 * (n = Math.floor(a / 65536)), m = (a = m + n + 65535) - 65536 * (n = Math.floor(a / 65536)), b = (a = b + n + 65535) - 65536 * (n = Math.floor(a / 65536)), w = (a = w + n + 65535) - 65536 * (n = Math.floor(a / 65536)), v = (a = v + n + 65535) - 65536 * (n = Math.floor(a / 65536)), o = (a = (o += n - 1 + 37 * (n - 1)) + (n = 1) + 65535) - 65536 * (n = Math.floor(a / 65536)), i = (a = i + n + 65535) - 65536 * (n = Math.floor(a / 65536)), s = (a = s + n + 65535) - 65536 * (n = Math.floor(a / 65536)), l = (a = l + n + 65535) - 65536 * (n = Math.floor(a / 65536)), c = (a = c + n + 65535) - 65536 * (n = Math.floor(a / 65536)), u = (a = u + n + 65535) - 65536 * (n = Math.floor(a / 65536)), h = (a = h + n + 65535) - 65536 * (n = Math.floor(a / 65536)), f = (a = f + n + 65535) - 65536 * (n = Math.floor(a / 65536)), d = (a = d + n + 65535) - 65536 * (n = Math.floor(a / 65536)), p = (a = p + n + 65535) - 65536 * (n = Math.floor(a / 65536)), y = (a = y + n + 65535) - 65536 * (n = Math.floor(a / 65536)), g = (a = g + n + 65535) - 65536 * (n = Math.floor(a / 65536)), m = (a = m + n + 65535) - 65536 * (n = Math.floor(a / 65536)), b = (a = b + n + 65535) - 65536 * (n = Math.floor(a / 65536)), w = (a = w + n + 65535) - 65536 * (n = Math.floor(a / 65536)), v = (a = v + n + 65535) - 65536 * (n = Math.floor(a / 65536)), o += n - 1 + 37 * (n - 1), e[0] = o, e[1] = i, e[2] = s, e[3] = l, e[4] = c, e[5] = u, e[6] = h, e[7] = f, e[8] = d, e[9] = p, e[10] = y, e[11] = g, e[12] = m, e[13] = b, e[14] = w, e[15] = v;
                    }
                    function N1(e, r) {
                        R1(e, r, r);
                    }
                    function C1(e, t) {
                        var a, n = r3();
                        for(a = 0; a < 16; a++)n[a] = t[a];
                        for(a = 253; a >= 0; a--)N1(n, n), 2 !== a && 4 !== a && R1(n, n, t);
                        for(a = 0; a < 16; a++)e[a] = n[a];
                    }
                    function F1(e, t) {
                        var a, n = r3();
                        for(a = 0; a < 16; a++)n[a] = t[a];
                        for(a = 250; a >= 0; a--)N1(n, n), 1 !== a && R1(n, n, t);
                        for(a = 0; a < 16; a++)e[a] = n[a];
                    }
                    function I1(e, t, a) {
                        var n, o, i = new Uint8Array(32), s = new Float64Array(80), c = r3(), u = r3(), h = r3(), f = r3(), d = r3(), p = r3();
                        for(o = 0; o < 31; o++)i[o] = t[o];
                        for(i[31] = 127 & t[31] | 64, i[0] &= 248, q1(s, a), o = 0; o < 16; o++)u[o] = s[o], f[o] = c[o] = h[o] = 0;
                        for(c[0] = f[0] = 1, o = 254; o >= 0; --o)T1(c, u, n = i[o >>> 3] >>> (7 & o) & 1), T1(h, f, n), L1(d, c, h), O1(c, c, h), L1(h, u, f), O1(u, u, f), N1(f, d), N1(p, c), R1(c, h, c), R1(h, u, d), L1(d, c, h), O1(c, c, h), N1(u, c), O1(h, f, p), R1(c, h, l1), L1(c, c, f), R1(h, h, c), R1(c, f, p), R1(f, u, s), N1(u, d), T1(c, u, n), T1(h, f, n);
                        for(o = 0; o < 16; o++)s[o + 16] = c[o], s[o + 32] = h[o], s[o + 48] = u[o], s[o + 64] = f[o];
                        var y = s.subarray(32), g = s.subarray(16);
                        return C1(y, y), R1(g, g, y), K1(e, g), 0;
                    }
                    function Z1(e, r) {
                        return I1(e, r, o1);
                    }
                    function D1(e, r) {
                        return a2(r, 32), Z1(e, r);
                    }
                    function G1(e, r, t) {
                        var a = new Uint8Array(32);
                        return I1(a, t, r), w1(e, n1, a, v1);
                    }
                    U1.prototype.blocks = function(e, r, t) {
                        for(var a, n, o, i, s, l, c, u, h, f, d, p, y, g, m, b, w, v, k, x = this.fin ? 0 : 2048, A = this.h[0], _ = this.h[1], U = this.h[2], E = this.h[3], M = this.h[4], z = this.h[5], j = this.h[6], S = this.h[7], B = this.h[8], T = this.h[9], K = this.r[0], P = this.r[1], Y = this.r[2], q = this.r[3], L = this.r[4], O = this.r[5], R = this.r[6], N = this.r[7], C = this.r[8], F = this.r[9]; t >= 16;)f = h = 0, f += (A += 8191 & (a = 255 & e[r + 0] | (255 & e[r + 1]) << 8)) * K, f += (_ += 8191 & (a >>> 13 | (n = 255 & e[r + 2] | (255 & e[r + 3]) << 8) << 3)) * (5 * F), f += (U += 8191 & (n >>> 10 | (o = 255 & e[r + 4] | (255 & e[r + 5]) << 8) << 6)) * (5 * C), f += (E += 8191 & (o >>> 7 | (i = 255 & e[r + 6] | (255 & e[r + 7]) << 8) << 9)) * (5 * N), h = (f += (M += 8191 & (i >>> 4 | (s = 255 & e[r + 8] | (255 & e[r + 9]) << 8) << 12)) * (5 * R)) >>> 13, f &= 8191, f += (z += s >>> 1 & 8191) * (5 * O), f += (j += 8191 & (s >>> 14 | (l = 255 & e[r + 10] | (255 & e[r + 11]) << 8) << 2)) * (5 * L), f += (S += 8191 & (l >>> 11 | (c = 255 & e[r + 12] | (255 & e[r + 13]) << 8) << 5)) * (5 * q), f += (B += 8191 & (c >>> 8 | (u = 255 & e[r + 14] | (255 & e[r + 15]) << 8) << 8)) * (5 * Y), d = h += (f += (T += u >>> 5 | x) * (5 * P)) >>> 13, d += A * P, d += _ * K, d += U * (5 * F), d += E * (5 * C), h = (d += M * (5 * N)) >>> 13, d &= 8191, d += z * (5 * R), d += j * (5 * O), d += S * (5 * L), d += B * (5 * q), h += (d += T * (5 * Y)) >>> 13, d &= 8191, p = h, p += A * Y, p += _ * P, p += U * K, p += E * (5 * F), h = (p += M * (5 * C)) >>> 13, p &= 8191, p += z * (5 * N), p += j * (5 * R), p += S * (5 * O), p += B * (5 * L), y = h += (p += T * (5 * q)) >>> 13, y += A * q, y += _ * Y, y += U * P, y += E * K, h = (y += M * (5 * F)) >>> 13, y &= 8191, y += z * (5 * C), y += j * (5 * N), y += S * (5 * R), y += B * (5 * O), g = h += (y += T * (5 * L)) >>> 13, g += A * L, g += _ * q, g += U * Y, g += E * P, h = (g += M * K) >>> 13, g &= 8191, g += z * (5 * F), g += j * (5 * C), g += S * (5 * N), g += B * (5 * R), m = h += (g += T * (5 * O)) >>> 13, m += A * O, m += _ * L, m += U * q, m += E * Y, h = (m += M * P) >>> 13, m &= 8191, m += z * K, m += j * (5 * F), m += S * (5 * C), m += B * (5 * N), b = h += (m += T * (5 * R)) >>> 13, b += A * R, b += _ * O, b += U * L, b += E * q, h = (b += M * Y) >>> 13, b &= 8191, b += z * P, b += j * K, b += S * (5 * F), b += B * (5 * C), w = h += (b += T * (5 * N)) >>> 13, w += A * N, w += _ * R, w += U * O, w += E * L, h = (w += M * q) >>> 13, w &= 8191, w += z * Y, w += j * P, w += S * K, w += B * (5 * F), v = h += (w += T * (5 * C)) >>> 13, v += A * C, v += _ * N, v += U * R, v += E * O, h = (v += M * L) >>> 13, v &= 8191, v += z * q, v += j * Y, v += S * P, v += B * K, k = h += (v += T * (5 * F)) >>> 13, k += A * F, k += _ * C, k += U * N, k += E * R, h = (k += M * O) >>> 13, k &= 8191, k += z * L, k += j * q, k += S * Y, k += B * P, A = f = 8191 & (h = (h = ((h += (k += T * K) >>> 13) << 2) + h | 0) + (f &= 8191) | 0), _ = d += h >>>= 13, U = p &= 8191, E = y &= 8191, M = g &= 8191, z = m &= 8191, j = b &= 8191, S = w &= 8191, B = v &= 8191, T = k &= 8191, r += 16, t -= 16;
                        this.h[0] = A, this.h[1] = _, this.h[2] = U, this.h[3] = E, this.h[4] = M, this.h[5] = z, this.h[6] = j, this.h[7] = S, this.h[8] = B, this.h[9] = T;
                    }, U1.prototype.finish = function(e, r) {
                        var t, a, n, o, i = new Uint16Array(10);
                        if (this.leftover) {
                            for(o = this.leftover, this.buffer[o++] = 1; o < 16; o++)this.buffer[o] = 0;
                            this.fin = 1, this.blocks(this.buffer, 0, 16);
                        }
                        for(t = this.h[1] >>> 13, this.h[1] &= 8191, o = 2; o < 10; o++)this.h[o] += t, t = this.h[o] >>> 13, this.h[o] &= 8191;
                        for(this.h[0] += 5 * t, t = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += t, t = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += t, i[0] = this.h[0] + 5, t = i[0] >>> 13, i[0] &= 8191, o = 1; o < 10; o++)i[o] = this.h[o] + t, t = i[o] >>> 13, i[o] &= 8191;
                        for(i[9] -= 8192, a = (1 ^ t) - 1, o = 0; o < 10; o++)i[o] &= a;
                        for(a = ~a, o = 0; o < 10; o++)this.h[o] = this.h[o] & a | i[o];
                        for(this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), n = this.h[0] + this.pad[0], this.h[0] = 65535 & n, o = 1; o < 8; o++)n = (this.h[o] + this.pad[o] | 0) + (n >>> 16) | 0, this.h[o] = 65535 & n;
                        e[r + 0] = this.h[0] >>> 0 & 255, e[r + 1] = this.h[0] >>> 8 & 255, e[r + 2] = this.h[1] >>> 0 & 255, e[r + 3] = this.h[1] >>> 8 & 255, e[r + 4] = this.h[2] >>> 0 & 255, e[r + 5] = this.h[2] >>> 8 & 255, e[r + 6] = this.h[3] >>> 0 & 255, e[r + 7] = this.h[3] >>> 8 & 255, e[r + 8] = this.h[4] >>> 0 & 255, e[r + 9] = this.h[4] >>> 8 & 255, e[r + 10] = this.h[5] >>> 0 & 255, e[r + 11] = this.h[5] >>> 8 & 255, e[r + 12] = this.h[6] >>> 0 & 255, e[r + 13] = this.h[6] >>> 8 & 255, e[r + 14] = this.h[7] >>> 0 & 255, e[r + 15] = this.h[7] >>> 8 & 255;
                    }, U1.prototype.update = function(e, r, t) {
                        var a, n;
                        if (this.leftover) {
                            for((n = 16 - this.leftover) > t && (n = t), a = 0; a < n; a++)this.buffer[this.leftover + a] = e[r + a];
                            if (t -= n, r += n, this.leftover += n, this.leftover < 16) return;
                            this.blocks(this.buffer, 0, 16), this.leftover = 0;
                        }
                        if (t >= 16 && (n = t - t % 16, this.blocks(e, r, n), r += n, t -= n), t) {
                            for(a = 0; a < t; a++)this.buffer[this.leftover + a] = e[r + a];
                            this.leftover += t;
                        }
                    };
                    var H1 = z1, V1 = j1, W1 = [
                        1116352408,
                        3609767458,
                        1899447441,
                        602891725,
                        3049323471,
                        3964484399,
                        3921009573,
                        2173295548,
                        961987163,
                        4081628472,
                        1508970993,
                        3053834265,
                        2453635748,
                        2937671579,
                        2870763221,
                        3664609560,
                        3624381080,
                        2734883394,
                        310598401,
                        1164996542,
                        607225278,
                        1323610764,
                        1426881987,
                        3590304994,
                        1925078388,
                        4068182383,
                        2162078206,
                        991336113,
                        2614888103,
                        633803317,
                        3248222580,
                        3479774868,
                        3835390401,
                        2666613458,
                        4022224774,
                        944711139,
                        264347078,
                        2341262773,
                        604807628,
                        2007800933,
                        770255983,
                        1495990901,
                        1249150122,
                        1856431235,
                        1555081692,
                        3175218132,
                        1996064986,
                        2198950837,
                        2554220882,
                        3999719339,
                        2821834349,
                        766784016,
                        2952996808,
                        2566594879,
                        3210313671,
                        3203337956,
                        3336571891,
                        1034457026,
                        3584528711,
                        2466948901,
                        113926993,
                        3758326383,
                        338241895,
                        168717936,
                        666307205,
                        1188179964,
                        773529912,
                        1546045734,
                        1294757372,
                        1522805485,
                        1396182291,
                        2643833823,
                        1695183700,
                        2343527390,
                        1986661051,
                        1014477480,
                        2177026350,
                        1206759142,
                        2456956037,
                        344077627,
                        2730485921,
                        1290863460,
                        2820302411,
                        3158454273,
                        3259730800,
                        3505952657,
                        3345764771,
                        106217008,
                        3516065817,
                        3606008344,
                        3600352804,
                        1432725776,
                        4094571909,
                        1467031594,
                        275423344,
                        851169720,
                        430227734,
                        3100823752,
                        506948616,
                        1363258195,
                        659060556,
                        3750685593,
                        883997877,
                        3785050280,
                        958139571,
                        3318307427,
                        1322822218,
                        3812723403,
                        1537002063,
                        2003034995,
                        1747873779,
                        3602036899,
                        1955562222,
                        1575990012,
                        2024104815,
                        1125592928,
                        2227730452,
                        2716904306,
                        2361852424,
                        442776044,
                        2428436474,
                        593698344,
                        2756734187,
                        3733110249,
                        3204031479,
                        2999351573,
                        3329325298,
                        3815920427,
                        3391569614,
                        3928383900,
                        3515267271,
                        566280711,
                        3940187606,
                        3454069534,
                        4118630271,
                        4000239992,
                        116418474,
                        1914138554,
                        174292421,
                        2731055270,
                        289380356,
                        3203993006,
                        460393269,
                        320620315,
                        685471733,
                        587496836,
                        852142971,
                        1086792851,
                        1017036298,
                        365543100,
                        1126000580,
                        2618297676,
                        1288033470,
                        3409855158,
                        1501505948,
                        4234509866,
                        1607167915,
                        987167468,
                        1816402316,
                        1246189591
                    ];
                    function X1(e, r, t, a) {
                        for(var n, o, i, s, l, c, u, h, f, d, p, y, g, m, b, w, v, k, x, A, _, U, E, M, z, j, S = new Int32Array(16), B = new Int32Array(16), T = e[0], K = e[1], P = e[2], Y = e[3], q = e[4], L = e[5], O = e[6], R = e[7], N = r[0], C = r[1], F = r[2], I = r[3], Z = r[4], D = r[5], G = r[6], H = r[7], V = 0; a >= 128;){
                            for(x = 0; x < 16; x++)A = 8 * x + V, S[x] = t[A + 0] << 24 | t[A + 1] << 16 | t[A + 2] << 8 | t[A + 3], B[x] = t[A + 4] << 24 | t[A + 5] << 16 | t[A + 6] << 8 | t[A + 7];
                            for(x = 0; x < 80; x++)if (n = T, o = K, i = P, s = Y, l = q, c = L, u = O, f = N, d = C, p = F, y = I, g = Z, m = D, b = G, E = 65535 & (U = H), M = U >>> 16, z = 65535 & (_ = R), j = _ >>> 16, E += 65535 & (U = (Z >>> 14 | q << 18) ^ (Z >>> 18 | q << 14) ^ (q >>> 9 | Z << 23)), M += U >>> 16, z += 65535 & (_ = (q >>> 14 | Z << 18) ^ (q >>> 18 | Z << 14) ^ (Z >>> 9 | q << 23)), j += _ >>> 16, E += 65535 & (U = Z & D ^ ~Z & G), M += U >>> 16, z += 65535 & (_ = q & L ^ ~q & O), j += _ >>> 16, E += 65535 & (U = W1[2 * x + 1]), M += U >>> 16, z += 65535 & (_ = W1[2 * x]), j += _ >>> 16, _ = S[x % 16], M += (U = B[x % 16]) >>> 16, z += 65535 & _, j += _ >>> 16, z += (M += (E += 65535 & U) >>> 16) >>> 16, E = 65535 & (U = k = 65535 & E | M << 16), M = U >>> 16, z = 65535 & (_ = v = 65535 & z | (j += z >>> 16) << 16), j = _ >>> 16, E += 65535 & (U = (N >>> 28 | T << 4) ^ (T >>> 2 | N << 30) ^ (T >>> 7 | N << 25)), M += U >>> 16, z += 65535 & (_ = (T >>> 28 | N << 4) ^ (N >>> 2 | T << 30) ^ (N >>> 7 | T << 25)), j += _ >>> 16, M += (U = N & C ^ N & F ^ C & F) >>> 16, z += 65535 & (_ = T & K ^ T & P ^ K & P), j += _ >>> 16, h = 65535 & (z += (M += (E += 65535 & U) >>> 16) >>> 16) | (j += z >>> 16) << 16, w = 65535 & E | M << 16, E = 65535 & (U = y), M = U >>> 16, z = 65535 & (_ = s), j = _ >>> 16, M += (U = k) >>> 16, z += 65535 & (_ = v), j += _ >>> 16, K = n, P = o, Y = i, q = s = 65535 & (z += (M += (E += 65535 & U) >>> 16) >>> 16) | (j += z >>> 16) << 16, L = l, O = c, R = u, T = h, C = f, F = d, I = p, Z = y = 65535 & E | M << 16, D = g, G = m, H = b, N = w, x % 16 == 15) for(A = 0; A < 16; A++)_ = S[A], E = 65535 & (U = B[A]), M = U >>> 16, z = 65535 & _, j = _ >>> 16, _ = S[(A + 9) % 16], E += 65535 & (U = B[(A + 9) % 16]), M += U >>> 16, z += 65535 & _, j += _ >>> 16, v = S[(A + 1) % 16], E += 65535 & (U = ((k = B[(A + 1) % 16]) >>> 1 | v << 31) ^ (k >>> 8 | v << 24) ^ (k >>> 7 | v << 25)), M += U >>> 16, z += 65535 & (_ = (v >>> 1 | k << 31) ^ (v >>> 8 | k << 24) ^ v >>> 7), j += _ >>> 16, v = S[(A + 14) % 16], M += (U = ((k = B[(A + 14) % 16]) >>> 19 | v << 13) ^ (v >>> 29 | k << 3) ^ (k >>> 6 | v << 26)) >>> 16, z += 65535 & (_ = (v >>> 19 | k << 13) ^ (k >>> 29 | v << 3) ^ v >>> 6), j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, S[A] = 65535 & z | j << 16, B[A] = 65535 & E | M << 16;
                            E = 65535 & (U = N), M = U >>> 16, z = 65535 & (_ = T), j = _ >>> 16, _ = e[0], M += (U = r[0]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[0] = T = 65535 & z | j << 16, r[0] = N = 65535 & E | M << 16, E = 65535 & (U = C), M = U >>> 16, z = 65535 & (_ = K), j = _ >>> 16, _ = e[1], M += (U = r[1]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[1] = K = 65535 & z | j << 16, r[1] = C = 65535 & E | M << 16, E = 65535 & (U = F), M = U >>> 16, z = 65535 & (_ = P), j = _ >>> 16, _ = e[2], M += (U = r[2]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[2] = P = 65535 & z | j << 16, r[2] = F = 65535 & E | M << 16, E = 65535 & (U = I), M = U >>> 16, z = 65535 & (_ = Y), j = _ >>> 16, _ = e[3], M += (U = r[3]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[3] = Y = 65535 & z | j << 16, r[3] = I = 65535 & E | M << 16, E = 65535 & (U = Z), M = U >>> 16, z = 65535 & (_ = q), j = _ >>> 16, _ = e[4], M += (U = r[4]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[4] = q = 65535 & z | j << 16, r[4] = Z = 65535 & E | M << 16, E = 65535 & (U = D), M = U >>> 16, z = 65535 & (_ = L), j = _ >>> 16, _ = e[5], M += (U = r[5]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[5] = L = 65535 & z | j << 16, r[5] = D = 65535 & E | M << 16, E = 65535 & (U = G), M = U >>> 16, z = 65535 & (_ = O), j = _ >>> 16, _ = e[6], M += (U = r[6]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[6] = O = 65535 & z | j << 16, r[6] = G = 65535 & E | M << 16, E = 65535 & (U = H), M = U >>> 16, z = 65535 & (_ = R), j = _ >>> 16, _ = e[7], M += (U = r[7]) >>> 16, z += 65535 & _, j += _ >>> 16, j += (z += (M += (E += 65535 & U) >>> 16) >>> 16) >>> 16, e[7] = R = 65535 & z | j << 16, r[7] = H = 65535 & E | M << 16, V += 128, a -= 128;
                        }
                        return a;
                    }
                    function $1(e, r, t) {
                        var a, n = new Int32Array(8), o = new Int32Array(8), i = new Uint8Array(256), s = t;
                        for(n[0] = 1779033703, n[1] = 3144134277, n[2] = 1013904242, n[3] = 2773480762, n[4] = 1359893119, n[5] = 2600822924, n[6] = 528734635, n[7] = 1541459225, o[0] = 4089235720, o[1] = 2227873595, o[2] = 4271175723, o[3] = 1595750129, o[4] = 2917565137, o[5] = 725511199, o[6] = 4215389547, o[7] = 327033209, X1(n, o, r, t), t %= 128, a = 0; a < t; a++)i[a] = r[s - t + a];
                        for(i[t] = 128, i[(t = 256 - 128 * (t < 112 ? 1 : 0)) - 9] = 0, p1(i, t - 8, s / 536870912 | 0, s << 3), X1(n, o, i, t), a = 0; a < 8; a++)p1(e, 8 * a, n[a], o[a]);
                        return 0;
                    }
                    function J(e, t) {
                        var a = r3(), n = r3(), o = r3(), i = r3(), s = r3(), l = r3(), c = r3(), h = r3(), f = r3();
                        O1(a, e[1], e[0]), O1(f, t[1], t[0]), R1(a, a, f), L1(n, e[0], e[1]), L1(f, t[0], t[1]), R1(n, n, f), R1(o, e[3], t[3]), R1(o, o, u1), R1(i, e[2], t[2]), L1(i, i, i), O1(s, n, a), O1(l, i, o), L1(c, i, o), L1(h, n, a), R1(e[0], s, l), R1(e[1], h, c), R1(e[2], c, l), R1(e[3], s, h);
                    }
                    function Q(e, r, t) {
                        var a;
                        for(a = 0; a < 4; a++)T1(e[a], r[a], t);
                    }
                    function ee(e, t) {
                        var a = r3(), n = r3(), o = r3();
                        C1(o, t[2]), R1(a, t[0], o), R1(n, t[1], o), K1(e, n), e[31] ^= Y1(a) << 7;
                    }
                    function re(e, r, t) {
                        var a, n;
                        for(S1(e[0], i1), S1(e[1], s1), S1(e[2], s1), S1(e[3], i1), n = 255; n >= 0; --n)Q(e, r, a = t[n / 8 | 0] >> (7 & n) & 1), J(r, e), J(e, e), Q(e, r, a);
                    }
                    function te(e, t) {
                        var a = [
                            r3(),
                            r3(),
                            r3(),
                            r3()
                        ];
                        S1(a[0], h1), S1(a[1], f1), S1(a[2], s1), R1(a[3], h1, f1), re(e, a, t);
                    }
                    function ae(e, t, n) {
                        var o, i = new Uint8Array(64), s = [
                            r3(),
                            r3(),
                            r3(),
                            r3()
                        ];
                        for(n || a2(t, 32), $1(i, t, 32), i[0] &= 248, i[31] &= 127, i[31] |= 64, te(s, i), ee(e, s), o = 0; o < 32; o++)t[o + 32] = e[o];
                        return 0;
                    }
                    var ne = new Float64Array([
                        237,
                        211,
                        245,
                        92,
                        26,
                        99,
                        18,
                        88,
                        214,
                        156,
                        247,
                        162,
                        222,
                        249,
                        222,
                        20,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        16
                    ]);
                    function oe(e, r) {
                        var t, a, n, o;
                        for(a = 63; a >= 32; --a){
                            for(t = 0, n = a - 32, o = a - 12; n < o; ++n)r[n] += t - 16 * r[a] * ne[n - (a - 32)], t = Math.floor((r[n] + 128) / 256), r[n] -= 256 * t;
                            r[n] += t, r[a] = 0;
                        }
                        for(t = 0, n = 0; n < 32; n++)r[n] += t - (r[31] >> 4) * ne[n], t = r[n] >> 8, r[n] &= 255;
                        for(n = 0; n < 32; n++)r[n] -= t * ne[n];
                        for(a = 0; a < 32; a++)r[a + 1] += r[a] >> 8, e[a] = 255 & r[a];
                    }
                    function ie(e) {
                        var r, t = new Float64Array(64);
                        for(r = 0; r < 64; r++)t[r] = e[r];
                        for(r = 0; r < 64; r++)e[r] = 0;
                        oe(e, t);
                    }
                    function se(e, t, a, n) {
                        var o, i, s = new Uint8Array(64), l = new Uint8Array(64), c = new Uint8Array(64), u = new Float64Array(64), h = [
                            r3(),
                            r3(),
                            r3(),
                            r3()
                        ];
                        $1(s, n, 32), s[0] &= 248, s[31] &= 127, s[31] |= 64;
                        var f = a + 64;
                        for(o = 0; o < a; o++)e[64 + o] = t[o];
                        for(o = 0; o < 32; o++)e[32 + o] = s[32 + o];
                        for($1(c, e.subarray(32), a + 32), ie(c), te(h, c), ee(e, h), o = 32; o < 64; o++)e[o] = n[o];
                        for($1(l, e, a + 64), ie(l), o = 0; o < 64; o++)u[o] = 0;
                        for(o = 0; o < 32; o++)u[o] = c[o];
                        for(o = 0; o < 32; o++)for(i = 0; i < 32; i++)u[o + i] += l[o] * s[i];
                        return oe(e.subarray(32), u), f;
                    }
                    function le(e6, t5, a5, n2) {
                        var o2, l2 = new Uint8Array(32), u2 = new Uint8Array(64), h2 = [
                            r3(),
                            r3(),
                            r3(),
                            r3()
                        ], f2 = [
                            r3(),
                            r3(),
                            r3(),
                            r3()
                        ];
                        if (a5 < 64) return -1;
                        if (function(e, t) {
                            var a = r3(), n = r3(), o = r3(), l = r3(), u = r3(), h = r3(), f = r3();
                            return S1(e[2], s1), q1(e[1], t), N1(o, e[1]), R1(l, o, c1), O1(o, o, e[2]), L1(l, e[2], l), N1(u, l), N1(h, u), R1(f, h, u), R1(a, f, o), R1(a, a, l), F1(a, a), R1(a, a, o), R1(a, a, l), R1(a, a, l), R1(e[0], a, l), N1(n, e[0]), R1(n, n, l), P1(n, o) && R1(e[0], e[0], d1), N1(n, e[0]), R1(n, n, l), P1(n, o) ? -1 : (Y1(e[0]) === t[31] >> 7 && O1(e[0], i1, e[0]), R1(e[3], e[0], e[1]), 0);
                        }(f2, n2)) return -1;
                        for(o2 = 0; o2 < a5; o2++)e6[o2] = t5[o2];
                        for(o2 = 0; o2 < 32; o2++)e6[o2 + 32] = n2[o2];
                        if ($1(u2, e6, a5), ie(u2), re(h2, f2, u2), te(f2, t5.subarray(32)), J(h2, f2), ee(l2, h2), a5 -= 64, m1(t5, 0, l2, 0)) {
                            for(o2 = 0; o2 < a5; o2++)e6[o2] = 0;
                            return -1;
                        }
                        for(o2 = 0; o2 < a5; o2++)e6[o2] = t5[o2 + 64];
                        return a5;
                    }
                    var ce, ue = 64, he = 32, fe = 64;
                    function de(e, r) {
                        if (32 !== e.length) throw new Error("bad key size");
                        if (24 !== r.length) throw new Error("bad nonce size");
                    }
                    function pe() {
                        for(var e = 0; e < arguments.length; e++)if (!(arguments[e] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
                    }
                    function ye(e) {
                        for(var r = 0; r < e.length; r++)e[r] = 0;
                    }
                    e3.lowlevel = {
                        crypto_core_hsalsa20: w1,
                        crypto_stream_xor: _1,
                        crypto_stream: A1,
                        crypto_stream_salsa20_xor: k1,
                        crypto_stream_salsa20: x1,
                        crypto_onetimeauth: E1,
                        crypto_onetimeauth_verify: M1,
                        crypto_verify_16: g1,
                        crypto_verify_32: m1,
                        crypto_secretbox: z1,
                        crypto_secretbox_open: j1,
                        crypto_scalarmult: I1,
                        crypto_scalarmult_base: Z1,
                        crypto_box_beforenm: G1,
                        crypto_box_afternm: H1,
                        crypto_box: function(e, r, t, a, n, o) {
                            var i = new Uint8Array(32);
                            return G1(i, n, o), H1(e, r, t, a, i);
                        },
                        crypto_box_open: function(e, r, t, a, n, o) {
                            var i = new Uint8Array(32);
                            return G1(i, n, o), V1(e, r, t, a, i);
                        },
                        crypto_box_keypair: D1,
                        crypto_hash: $1,
                        crypto_sign: se,
                        crypto_sign_keypair: ae,
                        crypto_sign_open: le,
                        crypto_secretbox_KEYBYTES: 32,
                        crypto_secretbox_NONCEBYTES: 24,
                        crypto_secretbox_ZEROBYTES: 32,
                        crypto_secretbox_BOXZEROBYTES: 16,
                        crypto_scalarmult_BYTES: 32,
                        crypto_scalarmult_SCALARBYTES: 32,
                        crypto_box_PUBLICKEYBYTES: 32,
                        crypto_box_SECRETKEYBYTES: 32,
                        crypto_box_BEFORENMBYTES: 32,
                        crypto_box_NONCEBYTES: 24,
                        crypto_box_ZEROBYTES: 32,
                        crypto_box_BOXZEROBYTES: 16,
                        crypto_sign_BYTES: ue,
                        crypto_sign_PUBLICKEYBYTES: he,
                        crypto_sign_SECRETKEYBYTES: fe,
                        crypto_sign_SEEDBYTES: 32,
                        crypto_hash_BYTES: 64,
                        gf: r3,
                        D: c1,
                        L: ne,
                        pack25519: K1,
                        unpack25519: q1,
                        M: R1,
                        A: L1,
                        S: N1,
                        Z: O1,
                        pow2523: F1,
                        add: J,
                        set25519: S1,
                        modL: oe,
                        scalarmult: re,
                        scalarbase: te
                    }, e3.randomBytes = function(e) {
                        var r = new Uint8Array(e);
                        return a2(r, e), r;
                    }, e3.secretbox = function(e, r, t) {
                        pe(e, r, t), de(t, r);
                        for(var a = new Uint8Array(32 + e.length), n = new Uint8Array(a.length), o = 0; o < e.length; o++)a[o + 32] = e[o];
                        return z1(n, a, a.length, r, t), n.subarray(16);
                    }, e3.secretbox.open = function(e, r, t) {
                        pe(e, r, t), de(t, r);
                        for(var a = new Uint8Array(16 + e.length), n = new Uint8Array(a.length), o = 0; o < e.length; o++)a[o + 16] = e[o];
                        return a.length < 32 || 0 !== j1(n, a, a.length, r, t) ? null : n.subarray(32);
                    }, e3.secretbox.keyLength = 32, e3.secretbox.nonceLength = 24, e3.secretbox.overheadLength = 16, e3.scalarMult = function(e, r) {
                        if (pe(e, r), 32 !== e.length) throw new Error("bad n size");
                        if (32 !== r.length) throw new Error("bad p size");
                        var t = new Uint8Array(32);
                        return I1(t, e, r), t;
                    }, e3.scalarMult.base = function(e) {
                        if (pe(e), 32 !== e.length) throw new Error("bad n size");
                        var r = new Uint8Array(32);
                        return Z1(r, e), r;
                    }, e3.scalarMult.scalarLength = 32, e3.scalarMult.groupElementLength = 32, e3.box = function(r, t, a, n) {
                        var o = e3.box.before(a, n);
                        return e3.secretbox(r, t, o);
                    }, e3.box.before = function(e7, r6) {
                        pe(e7, r6), function(e, r) {
                            if (32 !== e.length) throw new Error("bad public key size");
                            if (32 !== r.length) throw new Error("bad secret key size");
                        }(e7, r6);
                        var t = new Uint8Array(32);
                        return G1(t, e7, r6), t;
                    }, e3.box.after = e3.secretbox, e3.box.open = function(r, t, a, n) {
                        var o = e3.box.before(a, n);
                        return e3.secretbox.open(r, t, o);
                    }, e3.box.open.after = e3.secretbox.open, e3.box.keyPair = function() {
                        var e = new Uint8Array(32), r = new Uint8Array(32);
                        return D1(e, r), {
                            publicKey: e,
                            secretKey: r
                        };
                    }, e3.box.keyPair.fromSecretKey = function(e) {
                        if (pe(e), 32 !== e.length) throw new Error("bad secret key size");
                        var r = new Uint8Array(32);
                        return Z1(r, e), {
                            publicKey: r,
                            secretKey: new Uint8Array(e)
                        };
                    }, e3.box.publicKeyLength = 32, e3.box.secretKeyLength = 32, e3.box.sharedKeyLength = 32, e3.box.nonceLength = 24, e3.box.overheadLength = e3.secretbox.overheadLength, e3.sign = function(e, r) {
                        if (pe(e, r), r.length !== fe) throw new Error("bad secret key size");
                        var t = new Uint8Array(ue + e.length);
                        return se(t, e, e.length, r), t;
                    }, e3.sign.open = function(e, r) {
                        if (pe(e, r), r.length !== he) throw new Error("bad public key size");
                        var t = new Uint8Array(e.length), a = le(t, e, e.length, r);
                        if (a < 0) return null;
                        for(var n = new Uint8Array(a), o = 0; o < n.length; o++)n[o] = t[o];
                        return n;
                    }, e3.sign.detached = function(r, t) {
                        for(var a = e3.sign(r, t), n = new Uint8Array(ue), o = 0; o < n.length; o++)n[o] = a[o];
                        return n;
                    }, e3.sign.detached.verify = function(e, r, t) {
                        if (pe(e, r, t), r.length !== ue) throw new Error("bad signature size");
                        if (t.length !== he) throw new Error("bad public key size");
                        var a, n = new Uint8Array(ue + e.length), o = new Uint8Array(ue + e.length);
                        for(a = 0; a < ue; a++)n[a] = r[a];
                        for(a = 0; a < e.length; a++)n[a + ue] = e[a];
                        return le(o, n, n.length, t) >= 0;
                    }, e3.sign.keyPair = function() {
                        var e = new Uint8Array(he), r = new Uint8Array(fe);
                        return ae(e, r), {
                            publicKey: e,
                            secretKey: r
                        };
                    }, e3.sign.keyPair.fromSecretKey = function(e) {
                        if (pe(e), e.length !== fe) throw new Error("bad secret key size");
                        for(var r = new Uint8Array(he), t = 0; t < r.length; t++)r[t] = e[32 + t];
                        return {
                            publicKey: r,
                            secretKey: new Uint8Array(e)
                        };
                    }, e3.sign.keyPair.fromSeed = function(e) {
                        if (pe(e), 32 !== e.length) throw new Error("bad seed size");
                        for(var r = new Uint8Array(he), t = new Uint8Array(fe), a = 0; a < 32; a++)t[a] = e[a];
                        return ae(r, t, !0), {
                            publicKey: r,
                            secretKey: t
                        };
                    }, e3.sign.publicKeyLength = he, e3.sign.secretKeyLength = fe, e3.sign.seedLength = 32, e3.sign.signatureLength = ue, e3.hash = function(e) {
                        pe(e);
                        var r = new Uint8Array(64);
                        return $1(r, e, e.length), r;
                    }, e3.hash.hashLength = 64, e3.verify = function(e, r) {
                        return pe(e, r), 0 !== e.length && 0 !== r.length && e.length === r.length && 0 === y1(e, 0, r, 0, e.length);
                    }, e3.setPRNG = function(e) {
                        a2 = e;
                    }, (ce = "undefined" != typeof self ? self.crypto || self.msCrypto : null) && ce.getRandomValues ? e3.setPRNG(function(e, r) {
                        var t, a = new Uint8Array(r);
                        for(t = 0; t < r; t += 65536)ce.getRandomValues(a.subarray(t, t + Math.min(r - t, 65536)));
                        for(t = 0; t < r; t++)e[t] = a[t];
                        ye(a);
                    }) : (ce = t2(24)) && ce.randomBytes && e3.setPRNG(function(e, r) {
                        var t, a = ce.randomBytes(r);
                        for(t = 0; t < r; t++)e[t] = a[t];
                        ye(a);
                    });
                }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
            },
            24: ()=>{}
        }, r1 = {};
        function t1(a) {
            var n = r1[a];
            if (void 0 !== n) return n.exports;
            var o = r1[a] = {
                exports: {}
            };
            return e1[a](o, o.exports, t1), o.exports;
        }
        t1.n = (e)=>{
            var r = e && e.__esModule ? ()=>e.default : ()=>e;
            return t1.d(r, {
                a: r
            }), r;
        }, t1.d = (e, r)=>{
            for(var a in r)t1.o(r, a) && !t1.o(e, a) && Object.defineProperty(e, a, {
                enumerable: !0,
                get: r[a]
            });
        }, t1.o = (e, r)=>Object.prototype.hasOwnProperty.call(e, r), t1.r = (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        };
        var a1 = {};
        return (()=>{
            "use strict";
            t1.r(a1), t1.d(a1, {
                KeyPair: ()=>e8.KeyPair,
                generateMnemonic: ()=>h,
                isPasswordNeeded: ()=>u,
                mnemonicToKeyPair: ()=>y,
                mnemonicToSeed: ()=>p,
                validateMnemonic: ()=>g,
                wordlists: ()=>r7
            });
            var e8 = {};
            t1.r(e8), t1.d(e8, {
                I: ()=>y
            });
            var r7 = {};
            t1.r(r7), t1.d(r7, {
                EN: ()=>o3,
                default: ()=>o3,
                english: ()=>o3
            });
            const n = self.crypto, o3 = [
                "abandon",
                "ability",
                "able",
                "about",
                "above",
                "absent",
                "absorb",
                "abstract",
                "absurd",
                "abuse",
                "access",
                "accident",
                "account",
                "accuse",
                "achieve",
                "acid",
                "acoustic",
                "acquire",
                "across",
                "act",
                "action",
                "actor",
                "actress",
                "actual",
                "adapt",
                "add",
                "addict",
                "address",
                "adjust",
                "admit",
                "adult",
                "advance",
                "advice",
                "aerobic",
                "affair",
                "afford",
                "afraid",
                "again",
                "age",
                "agent",
                "agree",
                "ahead",
                "aim",
                "air",
                "airport",
                "aisle",
                "alarm",
                "album",
                "alcohol",
                "alert",
                "alien",
                "all",
                "alley",
                "allow",
                "almost",
                "alone",
                "alpha",
                "already",
                "also",
                "alter",
                "always",
                "amateur",
                "amazing",
                "among",
                "amount",
                "amused",
                "analyst",
                "anchor",
                "ancient",
                "anger",
                "angle",
                "angry",
                "animal",
                "ankle",
                "announce",
                "annual",
                "another",
                "answer",
                "antenna",
                "antique",
                "anxiety",
                "any",
                "apart",
                "apology",
                "appear",
                "apple",
                "approve",
                "april",
                "arch",
                "arctic",
                "area",
                "arena",
                "argue",
                "arm",
                "armed",
                "armor",
                "army",
                "around",
                "arrange",
                "arrest",
                "arrive",
                "arrow",
                "art",
                "artefact",
                "artist",
                "artwork",
                "ask",
                "aspect",
                "assault",
                "asset",
                "assist",
                "assume",
                "asthma",
                "athlete",
                "atom",
                "attack",
                "attend",
                "attitude",
                "attract",
                "auction",
                "audit",
                "august",
                "aunt",
                "author",
                "auto",
                "autumn",
                "average",
                "avocado",
                "avoid",
                "awake",
                "aware",
                "away",
                "awesome",
                "awful",
                "awkward",
                "axis",
                "baby",
                "bachelor",
                "bacon",
                "badge",
                "bag",
                "balance",
                "balcony",
                "ball",
                "bamboo",
                "banana",
                "banner",
                "bar",
                "barely",
                "bargain",
                "barrel",
                "base",
                "basic",
                "basket",
                "battle",
                "beach",
                "bean",
                "beauty",
                "because",
                "become",
                "beef",
                "before",
                "begin",
                "behave",
                "behind",
                "believe",
                "below",
                "belt",
                "bench",
                "benefit",
                "best",
                "betray",
                "better",
                "between",
                "beyond",
                "bicycle",
                "bid",
                "bike",
                "bind",
                "biology",
                "bird",
                "birth",
                "bitter",
                "black",
                "blade",
                "blame",
                "blanket",
                "blast",
                "bleak",
                "bless",
                "blind",
                "blood",
                "blossom",
                "blouse",
                "blue",
                "blur",
                "blush",
                "board",
                "boat",
                "body",
                "boil",
                "bomb",
                "bone",
                "bonus",
                "book",
                "boost",
                "border",
                "boring",
                "borrow",
                "boss",
                "bottom",
                "bounce",
                "box",
                "boy",
                "bracket",
                "brain",
                "brand",
                "brass",
                "brave",
                "bread",
                "breeze",
                "brick",
                "bridge",
                "brief",
                "bright",
                "bring",
                "brisk",
                "broccoli",
                "broken",
                "bronze",
                "broom",
                "brother",
                "brown",
                "brush",
                "bubble",
                "buddy",
                "budget",
                "buffalo",
                "build",
                "bulb",
                "bulk",
                "bullet",
                "bundle",
                "bunker",
                "burden",
                "burger",
                "burst",
                "bus",
                "business",
                "busy",
                "butter",
                "buyer",
                "buzz",
                "cabbage",
                "cabin",
                "cable",
                "cactus",
                "cage",
                "cake",
                "call",
                "calm",
                "camera",
                "camp",
                "can",
                "canal",
                "cancel",
                "candy",
                "cannon",
                "canoe",
                "canvas",
                "canyon",
                "capable",
                "capital",
                "captain",
                "car",
                "carbon",
                "card",
                "cargo",
                "carpet",
                "carry",
                "cart",
                "case",
                "cash",
                "casino",
                "castle",
                "casual",
                "cat",
                "catalog",
                "catch",
                "category",
                "cattle",
                "caught",
                "cause",
                "caution",
                "cave",
                "ceiling",
                "celery",
                "cement",
                "census",
                "century",
                "cereal",
                "certain",
                "chair",
                "chalk",
                "champion",
                "change",
                "chaos",
                "chapter",
                "charge",
                "chase",
                "chat",
                "cheap",
                "check",
                "cheese",
                "chef",
                "cherry",
                "chest",
                "chicken",
                "chief",
                "child",
                "chimney",
                "choice",
                "choose",
                "chronic",
                "chuckle",
                "chunk",
                "churn",
                "cigar",
                "cinnamon",
                "circle",
                "citizen",
                "city",
                "civil",
                "claim",
                "clap",
                "clarify",
                "claw",
                "clay",
                "clean",
                "clerk",
                "clever",
                "click",
                "client",
                "cliff",
                "climb",
                "clinic",
                "clip",
                "clock",
                "clog",
                "close",
                "cloth",
                "cloud",
                "clown",
                "club",
                "clump",
                "cluster",
                "clutch",
                "coach",
                "coast",
                "coconut",
                "code",
                "coffee",
                "coil",
                "coin",
                "collect",
                "color",
                "column",
                "combine",
                "come",
                "comfort",
                "comic",
                "common",
                "company",
                "concert",
                "conduct",
                "confirm",
                "congress",
                "connect",
                "consider",
                "control",
                "convince",
                "cook",
                "cool",
                "copper",
                "copy",
                "coral",
                "core",
                "corn",
                "correct",
                "cost",
                "cotton",
                "couch",
                "country",
                "couple",
                "course",
                "cousin",
                "cover",
                "coyote",
                "crack",
                "cradle",
                "craft",
                "cram",
                "crane",
                "crash",
                "crater",
                "crawl",
                "crazy",
                "cream",
                "credit",
                "creek",
                "crew",
                "cricket",
                "crime",
                "crisp",
                "critic",
                "crop",
                "cross",
                "crouch",
                "crowd",
                "crucial",
                "cruel",
                "cruise",
                "crumble",
                "crunch",
                "crush",
                "cry",
                "crystal",
                "cube",
                "culture",
                "cup",
                "cupboard",
                "curious",
                "current",
                "curtain",
                "curve",
                "cushion",
                "custom",
                "cute",
                "cycle",
                "dad",
                "damage",
                "damp",
                "dance",
                "danger",
                "daring",
                "dash",
                "daughter",
                "dawn",
                "day",
                "deal",
                "debate",
                "debris",
                "decade",
                "december",
                "decide",
                "decline",
                "decorate",
                "decrease",
                "deer",
                "defense",
                "define",
                "defy",
                "degree",
                "delay",
                "deliver",
                "demand",
                "demise",
                "denial",
                "dentist",
                "deny",
                "depart",
                "depend",
                "deposit",
                "depth",
                "deputy",
                "derive",
                "describe",
                "desert",
                "design",
                "desk",
                "despair",
                "destroy",
                "detail",
                "detect",
                "develop",
                "device",
                "devote",
                "diagram",
                "dial",
                "diamond",
                "diary",
                "dice",
                "diesel",
                "diet",
                "differ",
                "digital",
                "dignity",
                "dilemma",
                "dinner",
                "dinosaur",
                "direct",
                "dirt",
                "disagree",
                "discover",
                "disease",
                "dish",
                "dismiss",
                "disorder",
                "display",
                "distance",
                "divert",
                "divide",
                "divorce",
                "dizzy",
                "doctor",
                "document",
                "dog",
                "doll",
                "dolphin",
                "domain",
                "donate",
                "donkey",
                "donor",
                "door",
                "dose",
                "double",
                "dove",
                "draft",
                "dragon",
                "drama",
                "drastic",
                "draw",
                "dream",
                "dress",
                "drift",
                "drill",
                "drink",
                "drip",
                "drive",
                "drop",
                "drum",
                "dry",
                "duck",
                "dumb",
                "dune",
                "during",
                "dust",
                "dutch",
                "duty",
                "dwarf",
                "dynamic",
                "eager",
                "eagle",
                "early",
                "earn",
                "earth",
                "easily",
                "east",
                "easy",
                "echo",
                "ecology",
                "economy",
                "edge",
                "edit",
                "educate",
                "effort",
                "egg",
                "eight",
                "either",
                "elbow",
                "elder",
                "electric",
                "elegant",
                "element",
                "elephant",
                "elevator",
                "elite",
                "else",
                "embark",
                "embody",
                "embrace",
                "emerge",
                "emotion",
                "employ",
                "empower",
                "empty",
                "enable",
                "enact",
                "end",
                "endless",
                "endorse",
                "enemy",
                "energy",
                "enforce",
                "engage",
                "engine",
                "enhance",
                "enjoy",
                "enlist",
                "enough",
                "enrich",
                "enroll",
                "ensure",
                "enter",
                "entire",
                "entry",
                "envelope",
                "episode",
                "equal",
                "equip",
                "era",
                "erase",
                "erode",
                "erosion",
                "error",
                "erupt",
                "escape",
                "essay",
                "essence",
                "estate",
                "eternal",
                "ethics",
                "evidence",
                "evil",
                "evoke",
                "evolve",
                "exact",
                "example",
                "excess",
                "exchange",
                "excite",
                "exclude",
                "excuse",
                "execute",
                "exercise",
                "exhaust",
                "exhibit",
                "exile",
                "exist",
                "exit",
                "exotic",
                "expand",
                "expect",
                "expire",
                "explain",
                "expose",
                "express",
                "extend",
                "extra",
                "eye",
                "eyebrow",
                "fabric",
                "face",
                "faculty",
                "fade",
                "faint",
                "faith",
                "fall",
                "false",
                "fame",
                "family",
                "famous",
                "fan",
                "fancy",
                "fantasy",
                "farm",
                "fashion",
                "fat",
                "fatal",
                "father",
                "fatigue",
                "fault",
                "favorite",
                "feature",
                "february",
                "federal",
                "fee",
                "feed",
                "feel",
                "female",
                "fence",
                "festival",
                "fetch",
                "fever",
                "few",
                "fiber",
                "fiction",
                "field",
                "figure",
                "file",
                "film",
                "filter",
                "final",
                "find",
                "fine",
                "finger",
                "finish",
                "fire",
                "firm",
                "first",
                "fiscal",
                "fish",
                "fit",
                "fitness",
                "fix",
                "flag",
                "flame",
                "flash",
                "flat",
                "flavor",
                "flee",
                "flight",
                "flip",
                "float",
                "flock",
                "floor",
                "flower",
                "fluid",
                "flush",
                "fly",
                "foam",
                "focus",
                "fog",
                "foil",
                "fold",
                "follow",
                "food",
                "foot",
                "force",
                "forest",
                "forget",
                "fork",
                "fortune",
                "forum",
                "forward",
                "fossil",
                "foster",
                "found",
                "fox",
                "fragile",
                "frame",
                "frequent",
                "fresh",
                "friend",
                "fringe",
                "frog",
                "front",
                "frost",
                "frown",
                "frozen",
                "fruit",
                "fuel",
                "fun",
                "funny",
                "furnace",
                "fury",
                "future",
                "gadget",
                "gain",
                "galaxy",
                "gallery",
                "game",
                "gap",
                "garage",
                "garbage",
                "garden",
                "garlic",
                "garment",
                "gas",
                "gasp",
                "gate",
                "gather",
                "gauge",
                "gaze",
                "general",
                "genius",
                "genre",
                "gentle",
                "genuine",
                "gesture",
                "ghost",
                "giant",
                "gift",
                "giggle",
                "ginger",
                "giraffe",
                "girl",
                "give",
                "glad",
                "glance",
                "glare",
                "glass",
                "glide",
                "glimpse",
                "globe",
                "gloom",
                "glory",
                "glove",
                "glow",
                "glue",
                "goat",
                "goddess",
                "gold",
                "good",
                "goose",
                "gorilla",
                "gospel",
                "gossip",
                "govern",
                "gown",
                "grab",
                "grace",
                "grain",
                "grant",
                "grape",
                "grass",
                "gravity",
                "great",
                "green",
                "grid",
                "grief",
                "grit",
                "grocery",
                "group",
                "grow",
                "grunt",
                "guard",
                "guess",
                "guide",
                "guilt",
                "guitar",
                "gun",
                "gym",
                "habit",
                "hair",
                "half",
                "hammer",
                "hamster",
                "hand",
                "happy",
                "harbor",
                "hard",
                "harsh",
                "harvest",
                "hat",
                "have",
                "hawk",
                "hazard",
                "head",
                "health",
                "heart",
                "heavy",
                "hedgehog",
                "height",
                "hello",
                "helmet",
                "help",
                "hen",
                "hero",
                "hidden",
                "high",
                "hill",
                "hint",
                "hip",
                "hire",
                "history",
                "hobby",
                "hockey",
                "hold",
                "hole",
                "holiday",
                "hollow",
                "home",
                "honey",
                "hood",
                "hope",
                "horn",
                "horror",
                "horse",
                "hospital",
                "host",
                "hotel",
                "hour",
                "hover",
                "hub",
                "huge",
                "human",
                "humble",
                "humor",
                "hundred",
                "hungry",
                "hunt",
                "hurdle",
                "hurry",
                "hurt",
                "husband",
                "hybrid",
                "ice",
                "icon",
                "idea",
                "identify",
                "idle",
                "ignore",
                "ill",
                "illegal",
                "illness",
                "image",
                "imitate",
                "immense",
                "immune",
                "impact",
                "impose",
                "improve",
                "impulse",
                "inch",
                "include",
                "income",
                "increase",
                "index",
                "indicate",
                "indoor",
                "industry",
                "infant",
                "inflict",
                "inform",
                "inhale",
                "inherit",
                "initial",
                "inject",
                "injury",
                "inmate",
                "inner",
                "innocent",
                "input",
                "inquiry",
                "insane",
                "insect",
                "inside",
                "inspire",
                "install",
                "intact",
                "interest",
                "into",
                "invest",
                "invite",
                "involve",
                "iron",
                "island",
                "isolate",
                "issue",
                "item",
                "ivory",
                "jacket",
                "jaguar",
                "jar",
                "jazz",
                "jealous",
                "jeans",
                "jelly",
                "jewel",
                "job",
                "join",
                "joke",
                "journey",
                "joy",
                "judge",
                "juice",
                "jump",
                "jungle",
                "junior",
                "junk",
                "just",
                "kangaroo",
                "keen",
                "keep",
                "ketchup",
                "key",
                "kick",
                "kid",
                "kidney",
                "kind",
                "kingdom",
                "kiss",
                "kit",
                "kitchen",
                "kite",
                "kitten",
                "kiwi",
                "knee",
                "knife",
                "knock",
                "know",
                "lab",
                "label",
                "labor",
                "ladder",
                "lady",
                "lake",
                "lamp",
                "language",
                "laptop",
                "large",
                "later",
                "latin",
                "laugh",
                "laundry",
                "lava",
                "law",
                "lawn",
                "lawsuit",
                "layer",
                "lazy",
                "leader",
                "leaf",
                "learn",
                "leave",
                "lecture",
                "left",
                "leg",
                "legal",
                "legend",
                "leisure",
                "lemon",
                "lend",
                "length",
                "lens",
                "leopard",
                "lesson",
                "letter",
                "level",
                "liar",
                "liberty",
                "library",
                "license",
                "life",
                "lift",
                "light",
                "like",
                "limb",
                "limit",
                "link",
                "lion",
                "liquid",
                "list",
                "little",
                "live",
                "lizard",
                "load",
                "loan",
                "lobster",
                "local",
                "lock",
                "logic",
                "lonely",
                "long",
                "loop",
                "lottery",
                "loud",
                "lounge",
                "love",
                "loyal",
                "lucky",
                "luggage",
                "lumber",
                "lunar",
                "lunch",
                "luxury",
                "lyrics",
                "machine",
                "mad",
                "magic",
                "magnet",
                "maid",
                "mail",
                "main",
                "major",
                "make",
                "mammal",
                "man",
                "manage",
                "mandate",
                "mango",
                "mansion",
                "manual",
                "maple",
                "marble",
                "march",
                "margin",
                "marine",
                "market",
                "marriage",
                "mask",
                "mass",
                "master",
                "match",
                "material",
                "math",
                "matrix",
                "matter",
                "maximum",
                "maze",
                "meadow",
                "mean",
                "measure",
                "meat",
                "mechanic",
                "medal",
                "media",
                "melody",
                "melt",
                "member",
                "memory",
                "mention",
                "menu",
                "mercy",
                "merge",
                "merit",
                "merry",
                "mesh",
                "message",
                "metal",
                "method",
                "middle",
                "midnight",
                "milk",
                "million",
                "mimic",
                "mind",
                "minimum",
                "minor",
                "minute",
                "miracle",
                "mirror",
                "misery",
                "miss",
                "mistake",
                "mix",
                "mixed",
                "mixture",
                "mobile",
                "model",
                "modify",
                "mom",
                "moment",
                "monitor",
                "monkey",
                "monster",
                "month",
                "moon",
                "moral",
                "more",
                "morning",
                "mosquito",
                "mother",
                "motion",
                "motor",
                "mountain",
                "mouse",
                "move",
                "movie",
                "much",
                "muffin",
                "mule",
                "multiply",
                "muscle",
                "museum",
                "mushroom",
                "music",
                "must",
                "mutual",
                "myself",
                "mystery",
                "myth",
                "naive",
                "name",
                "napkin",
                "narrow",
                "nasty",
                "nation",
                "nature",
                "near",
                "neck",
                "need",
                "negative",
                "neglect",
                "neither",
                "nephew",
                "nerve",
                "nest",
                "net",
                "network",
                "neutral",
                "never",
                "news",
                "next",
                "nice",
                "night",
                "noble",
                "noise",
                "nominee",
                "noodle",
                "normal",
                "north",
                "nose",
                "notable",
                "note",
                "nothing",
                "notice",
                "novel",
                "now",
                "nuclear",
                "number",
                "nurse",
                "nut",
                "oak",
                "obey",
                "object",
                "oblige",
                "obscure",
                "observe",
                "obtain",
                "obvious",
                "occur",
                "ocean",
                "october",
                "odor",
                "off",
                "offer",
                "office",
                "often",
                "oil",
                "okay",
                "old",
                "olive",
                "olympic",
                "omit",
                "once",
                "one",
                "onion",
                "online",
                "only",
                "open",
                "opera",
                "opinion",
                "oppose",
                "option",
                "orange",
                "orbit",
                "orchard",
                "order",
                "ordinary",
                "organ",
                "orient",
                "original",
                "orphan",
                "ostrich",
                "other",
                "outdoor",
                "outer",
                "output",
                "outside",
                "oval",
                "oven",
                "over",
                "own",
                "owner",
                "oxygen",
                "oyster",
                "ozone",
                "pact",
                "paddle",
                "page",
                "pair",
                "palace",
                "palm",
                "panda",
                "panel",
                "panic",
                "panther",
                "paper",
                "parade",
                "parent",
                "park",
                "parrot",
                "party",
                "pass",
                "patch",
                "path",
                "patient",
                "patrol",
                "pattern",
                "pause",
                "pave",
                "payment",
                "peace",
                "peanut",
                "pear",
                "peasant",
                "pelican",
                "pen",
                "penalty",
                "pencil",
                "people",
                "pepper",
                "perfect",
                "permit",
                "person",
                "pet",
                "phone",
                "photo",
                "phrase",
                "physical",
                "piano",
                "picnic",
                "picture",
                "piece",
                "pig",
                "pigeon",
                "pill",
                "pilot",
                "pink",
                "pioneer",
                "pipe",
                "pistol",
                "pitch",
                "pizza",
                "place",
                "planet",
                "plastic",
                "plate",
                "play",
                "please",
                "pledge",
                "pluck",
                "plug",
                "plunge",
                "poem",
                "poet",
                "point",
                "polar",
                "pole",
                "police",
                "pond",
                "pony",
                "pool",
                "popular",
                "portion",
                "position",
                "possible",
                "post",
                "potato",
                "pottery",
                "poverty",
                "powder",
                "power",
                "practice",
                "praise",
                "predict",
                "prefer",
                "prepare",
                "present",
                "pretty",
                "prevent",
                "price",
                "pride",
                "primary",
                "print",
                "priority",
                "prison",
                "private",
                "prize",
                "problem",
                "process",
                "produce",
                "profit",
                "program",
                "project",
                "promote",
                "proof",
                "property",
                "prosper",
                "protect",
                "proud",
                "provide",
                "public",
                "pudding",
                "pull",
                "pulp",
                "pulse",
                "pumpkin",
                "punch",
                "pupil",
                "puppy",
                "purchase",
                "purity",
                "purpose",
                "purse",
                "push",
                "put",
                "puzzle",
                "pyramid",
                "quality",
                "quantum",
                "quarter",
                "question",
                "quick",
                "quit",
                "quiz",
                "quote",
                "rabbit",
                "raccoon",
                "race",
                "rack",
                "radar",
                "radio",
                "rail",
                "rain",
                "raise",
                "rally",
                "ramp",
                "ranch",
                "random",
                "range",
                "rapid",
                "rare",
                "rate",
                "rather",
                "raven",
                "raw",
                "razor",
                "ready",
                "real",
                "reason",
                "rebel",
                "rebuild",
                "recall",
                "receive",
                "recipe",
                "record",
                "recycle",
                "reduce",
                "reflect",
                "reform",
                "refuse",
                "region",
                "regret",
                "regular",
                "reject",
                "relax",
                "release",
                "relief",
                "rely",
                "remain",
                "remember",
                "remind",
                "remove",
                "render",
                "renew",
                "rent",
                "reopen",
                "repair",
                "repeat",
                "replace",
                "report",
                "require",
                "rescue",
                "resemble",
                "resist",
                "resource",
                "response",
                "result",
                "retire",
                "retreat",
                "return",
                "reunion",
                "reveal",
                "review",
                "reward",
                "rhythm",
                "rib",
                "ribbon",
                "rice",
                "rich",
                "ride",
                "ridge",
                "rifle",
                "right",
                "rigid",
                "ring",
                "riot",
                "ripple",
                "risk",
                "ritual",
                "rival",
                "river",
                "road",
                "roast",
                "robot",
                "robust",
                "rocket",
                "romance",
                "roof",
                "rookie",
                "room",
                "rose",
                "rotate",
                "rough",
                "round",
                "route",
                "royal",
                "rubber",
                "rude",
                "rug",
                "rule",
                "run",
                "runway",
                "rural",
                "sad",
                "saddle",
                "sadness",
                "safe",
                "sail",
                "salad",
                "salmon",
                "salon",
                "salt",
                "salute",
                "same",
                "sample",
                "sand",
                "satisfy",
                "satoshi",
                "sauce",
                "sausage",
                "save",
                "say",
                "scale",
                "scan",
                "scare",
                "scatter",
                "scene",
                "scheme",
                "school",
                "science",
                "scissors",
                "scorpion",
                "scout",
                "scrap",
                "screen",
                "script",
                "scrub",
                "sea",
                "search",
                "season",
                "seat",
                "second",
                "secret",
                "section",
                "security",
                "seed",
                "seek",
                "segment",
                "select",
                "sell",
                "seminar",
                "senior",
                "sense",
                "sentence",
                "series",
                "service",
                "session",
                "settle",
                "setup",
                "seven",
                "shadow",
                "shaft",
                "shallow",
                "share",
                "shed",
                "shell",
                "sheriff",
                "shield",
                "shift",
                "shine",
                "ship",
                "shiver",
                "shock",
                "shoe",
                "shoot",
                "shop",
                "short",
                "shoulder",
                "shove",
                "shrimp",
                "shrug",
                "shuffle",
                "shy",
                "sibling",
                "sick",
                "side",
                "siege",
                "sight",
                "sign",
                "silent",
                "silk",
                "silly",
                "silver",
                "similar",
                "simple",
                "since",
                "sing",
                "siren",
                "sister",
                "situate",
                "six",
                "size",
                "skate",
                "sketch",
                "ski",
                "skill",
                "skin",
                "skirt",
                "skull",
                "slab",
                "slam",
                "sleep",
                "slender",
                "slice",
                "slide",
                "slight",
                "slim",
                "slogan",
                "slot",
                "slow",
                "slush",
                "small",
                "smart",
                "smile",
                "smoke",
                "smooth",
                "snack",
                "snake",
                "snap",
                "sniff",
                "snow",
                "soap",
                "soccer",
                "social",
                "sock",
                "soda",
                "soft",
                "solar",
                "soldier",
                "solid",
                "solution",
                "solve",
                "someone",
                "song",
                "soon",
                "sorry",
                "sort",
                "soul",
                "sound",
                "soup",
                "source",
                "south",
                "space",
                "spare",
                "spatial",
                "spawn",
                "speak",
                "special",
                "speed",
                "spell",
                "spend",
                "sphere",
                "spice",
                "spider",
                "spike",
                "spin",
                "spirit",
                "split",
                "spoil",
                "sponsor",
                "spoon",
                "sport",
                "spot",
                "spray",
                "spread",
                "spring",
                "spy",
                "square",
                "squeeze",
                "squirrel",
                "stable",
                "stadium",
                "staff",
                "stage",
                "stairs",
                "stamp",
                "stand",
                "start",
                "state",
                "stay",
                "steak",
                "steel",
                "stem",
                "step",
                "stereo",
                "stick",
                "still",
                "sting",
                "stock",
                "stomach",
                "stone",
                "stool",
                "story",
                "stove",
                "strategy",
                "street",
                "strike",
                "strong",
                "struggle",
                "student",
                "stuff",
                "stumble",
                "style",
                "subject",
                "submit",
                "subway",
                "success",
                "such",
                "sudden",
                "suffer",
                "sugar",
                "suggest",
                "suit",
                "summer",
                "sun",
                "sunny",
                "sunset",
                "super",
                "supply",
                "supreme",
                "sure",
                "surface",
                "surge",
                "surprise",
                "surround",
                "survey",
                "suspect",
                "sustain",
                "swallow",
                "swamp",
                "swap",
                "swarm",
                "swear",
                "sweet",
                "swift",
                "swim",
                "swing",
                "switch",
                "sword",
                "symbol",
                "symptom",
                "syrup",
                "system",
                "table",
                "tackle",
                "tag",
                "tail",
                "talent",
                "talk",
                "tank",
                "tape",
                "target",
                "task",
                "taste",
                "tattoo",
                "taxi",
                "teach",
                "team",
                "tell",
                "ten",
                "tenant",
                "tennis",
                "tent",
                "term",
                "test",
                "text",
                "thank",
                "that",
                "theme",
                "then",
                "theory",
                "there",
                "they",
                "thing",
                "this",
                "thought",
                "three",
                "thrive",
                "throw",
                "thumb",
                "thunder",
                "ticket",
                "tide",
                "tiger",
                "tilt",
                "timber",
                "time",
                "tiny",
                "tip",
                "tired",
                "tissue",
                "title",
                "toast",
                "tobacco",
                "today",
                "toddler",
                "toe",
                "together",
                "toilet",
                "token",
                "tomato",
                "tomorrow",
                "tone",
                "tongue",
                "tonight",
                "tool",
                "tooth",
                "top",
                "topic",
                "topple",
                "torch",
                "tornado",
                "tortoise",
                "toss",
                "total",
                "tourist",
                "toward",
                "tower",
                "town",
                "toy",
                "track",
                "trade",
                "traffic",
                "tragic",
                "train",
                "transfer",
                "trap",
                "trash",
                "travel",
                "tray",
                "treat",
                "tree",
                "trend",
                "trial",
                "tribe",
                "trick",
                "trigger",
                "trim",
                "trip",
                "trophy",
                "trouble",
                "truck",
                "true",
                "truly",
                "trumpet",
                "trust",
                "truth",
                "try",
                "tube",
                "tuition",
                "tumble",
                "tuna",
                "tunnel",
                "turkey",
                "turn",
                "turtle",
                "twelve",
                "twenty",
                "twice",
                "twin",
                "twist",
                "two",
                "type",
                "typical",
                "ugly",
                "umbrella",
                "unable",
                "unaware",
                "uncle",
                "uncover",
                "under",
                "undo",
                "unfair",
                "unfold",
                "unhappy",
                "uniform",
                "unique",
                "unit",
                "universe",
                "unknown",
                "unlock",
                "until",
                "unusual",
                "unveil",
                "update",
                "upgrade",
                "uphold",
                "upon",
                "upper",
                "upset",
                "urban",
                "urge",
                "usage",
                "use",
                "used",
                "useful",
                "useless",
                "usual",
                "utility",
                "vacant",
                "vacuum",
                "vague",
                "valid",
                "valley",
                "valve",
                "van",
                "vanish",
                "vapor",
                "various",
                "vast",
                "vault",
                "vehicle",
                "velvet",
                "vendor",
                "venture",
                "venue",
                "verb",
                "verify",
                "version",
                "very",
                "vessel",
                "veteran",
                "viable",
                "vibrant",
                "vicious",
                "victory",
                "video",
                "view",
                "village",
                "vintage",
                "violin",
                "virtual",
                "virus",
                "visa",
                "visit",
                "visual",
                "vital",
                "vivid",
                "vocal",
                "voice",
                "void",
                "volcano",
                "volume",
                "vote",
                "voyage",
                "wage",
                "wagon",
                "wait",
                "walk",
                "wall",
                "walnut",
                "want",
                "warfare",
                "warm",
                "warrior",
                "wash",
                "wasp",
                "waste",
                "water",
                "wave",
                "way",
                "wealth",
                "weapon",
                "wear",
                "weasel",
                "weather",
                "web",
                "wedding",
                "weekend",
                "weird",
                "welcome",
                "west",
                "wet",
                "whale",
                "what",
                "wheat",
                "wheel",
                "when",
                "where",
                "whip",
                "whisper",
                "wide",
                "width",
                "wife",
                "wild",
                "will",
                "win",
                "window",
                "wine",
                "wing",
                "wink",
                "winner",
                "winter",
                "wire",
                "wisdom",
                "wise",
                "wish",
                "witness",
                "wolf",
                "woman",
                "wonder",
                "wood",
                "wool",
                "word",
                "work",
                "world",
                "worry",
                "worth",
                "wrap",
                "wreck",
                "wrestle",
                "wrist",
                "write",
                "wrong",
                "yard",
                "year",
                "yellow",
                "you",
                "young",
                "youth",
                "zebra",
                "zero",
                "zone",
                "zoo"
            ];
            async function i2(e) {
                return 0 == (await l3(e, "TON seed version", Math.max(1, Math.floor(390.625))))[0];
            }
            async function s(e9, r8 = "") {
                const t6 = e9.join(" ");
                return await async function(e, r) {
                    const t = c(e).buffer, a = r.length ? c(r).buffer : new ArrayBuffer(0), o = {
                        name: "HMAC",
                        hash: "SHA-512"
                    }, i = await n.subtle.importKey("raw", t, o, !1, [
                        "sign"
                    ]);
                    return await n.subtle.sign(o, i, a);
                }(t6, r8);
            }
            async function l3(e, r, t) {
                const a = c(r).buffer, o = await n.subtle.importKey("raw", e, {
                    name: "PBKDF2"
                }, !1, [
                    "deriveBits"
                ]), i = await n.subtle.deriveBits({
                    name: "PBKDF2",
                    hash: "SHA-512",
                    salt: a,
                    iterations: t
                }, o, 512);
                return new Uint8Array(i);
            }
            function c(e, r = 1) {
                let t, a;
                switch(r){
                    case 1:
                        t = new ArrayBuffer(e.length), a = new Uint8Array(t);
                        break;
                    case 2:
                        t = new ArrayBuffer(2 * e.length), a = new Uint16Array(t);
                        break;
                    case 4:
                        t = new ArrayBuffer(4 * e.length), a = new Uint32Array(t);
                        break;
                    default:
                        throw new Error(`Incorrect size specified: ${r}`);
                }
                for(let r9 = 0, t7 = e.length; r9 < t7; r9++)a[r9] = e.charCodeAt(r9);
                return new Uint8Array(a.buffer);
            }
            async function u(e10) {
                const r = await s(e10, "");
                return await async function(e) {
                    return 1 == (await l3(e, "TON fast seed version", 1))[0];
                }(r) && !await i2(r);
            }
            async function h(e = 24, r = "", t = o3) {
                let a = 0, l = [];
                for(;;){
                    a += 1, l = [];
                    const o = n.getRandomValues(new Uint16Array(e));
                    for(let r10 = 0; r10 < e; r10++)l.push(t[2047 & o[r10]]);
                    if ((!(r.length > 0) || await u(l)) && await i2(await s(l, r))) break;
                }
                return l;
            }
            var f = t1(780), d = t1.n(f);
            async function p(e, r = "") {
                const t = await s(e, r);
                return (await l3(t, "TON default seed", 1e5)).slice(0, 32);
            }
            async function y(e, r = "") {
                const t = await p(e, r);
                return d().sign.keyPair.fromSeed(t);
            }
            async function g(e, r = "", t = o3) {
                for (let r11 of e)if (-1 === t.indexOf(r11)) return !1;
                return !(r.length > 0 && !await u(e)) && await i2(await s(e, r));
            }
        })(), a1;
    })();
});

},{}]},["j2mbD","9T4CR"], "9T4CR", "parcelRequire8bbf")

//# sourceMappingURL=index.ef1b1901.js.map
